<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DDD简介科普</title>
    <url>/2021/09/10/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="名词科普"><a href="#名词科普" class="headerlink" title="名词科普"></a>名词科普</h2><h3 id="集群、分布式、SOA、微服务"><a href="#集群、分布式、SOA、微服务" class="headerlink" title="集群、分布式、SOA、微服务"></a>集群、分布式、SOA、微服务</h3><p><strong>单体</strong>：一个应用里包含完整的服务</p>
<p><strong>集群</strong>：不同服务器部署同一套应用对外提供服务，指同一组件的多个实例，是一种物理形态。</p>
<p><strong>分布式</strong>：与集群不同，强调的是不同的模块部署在不同服务器上，提供完整的服务（可以存在相同服务部署在多个节点上），强调的是工作方式</p>
<p><strong>SOA</strong>（Service-Oriented Architecture）:面向服务的架构，是一种设计方法。服务拆分，多个服务相互依赖通过接口和协议联系起来</p>
<p>​    中心化实现：ESB（Enterprise Service Bus ） 企业服务总线，各服务通过ESB交互的方式实现与其他服务的通信，解决异构系统的连通性，屏蔽其他服务的细节。</p>
<pre><code> 去中心化：微服务，SOA的升华
</code></pre>
<p><strong>微服务</strong>：强调业务的彻底组件化和服务化，每个服务可单独开发，迭代运行，更符合单一职责原则，通过网关</p>
<p>服务发现与注册，restful api风格轻量级通信等等，各司其职</p>
<h2 id="系统老化谁的锅"><a href="#系统老化谁的锅" class="headerlink" title="系统老化谁的锅"></a>系统老化谁的锅</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902221412119.png" alt="image-20210902221412119"></p>
<h1 id="DDD的特点"><a href="#DDD的特点" class="headerlink" title="DDD的特点"></a>DDD的特点</h1><h2 id="基于充血模型的面向对象开发"><a href="#基于充血模型的面向对象开发" class="headerlink" title="基于充血模型的面向对象开发"></a>基于充血模型的面向对象开发</h2><p>贫血模型：</p>
<p>​    定义对象的简单的属性值，没有业务逻辑上的方法（个人理解）</p>
<p>​    MVC模式开发是是面向过程的编程方式，符合人类大脑逻辑。定义DTO，定义数据库Model，BO等，对其进行get set方法，然后通过service 对Bo对象进行操作，最后通过copy属性持久化数据库和DTO传输。</p>
<p>充血模型：</p>
<p>​    就是我们在定义属性的同时也会定义方法，我们的属性是可以通过某些方式直接得到属性值，那我们也就可以在对象中嵌入方法直接创建出一个具有属性值的对象。也就是说这个对象不再需要我们在进行进一步的操作，这也就复合了OOP的三大特性之一的封装</p>
<h2 id="DDD四层架构"><a href="#DDD四层架构" class="headerlink" title="DDD四层架构"></a>DDD四层架构</h2><ul>
<li><p>interface（接口层）</p>
<ul>
<li>很薄的一层</li>
<li>类似于MVC中的controller层 只能直接注入app层</li>
</ul>
</li>
<li><p>application（应用层）</p>
<ul>
<li>很薄的一层</li>
<li>注入领域对象，可以设置状态参数（领域层是无状态的，可以在app层设置用户状态，系统标志等等参数）调用领域服务</li>
</ul>
</li>
<li><p>domain（领域服务层）</p>
<ul>
<li>Aservice 只能注入execute、query聚合根来操作持久层<ul>
<li>A1子领域<ul>
<li>repository 存放领域内部仓库，操作持久化层<ul>
<li>dao 存放Mybatis Mapper接口和实现的XML文件</li>
<li>data（可选）查询前后的数据计算、转化</li>
<li><strong>execute聚合根</strong> 定义所有增删改操作</li>
<li><strong>query聚合根</strong> 定义所有查询操作</li>
</ul>
</li>
</ul>
</li>
<li>A2子领域</li>
<li>transfer层 领域内部之前通过该层调用 如 A1service -&gt; A2transfer</li>
</ul>
</li>
</ul>
</li>
<li><p>infrastructure（基础设施层）（配置、自研组件、缓存、防腐层（client）、工具包）</p>
<ul>
<li><p>client</p>
<ul>
<li>native<ul>
<li>外围、外部服务client客户端</li>
</ul>
</li>
<li>local 本地大领域之间调用 比如 A调用B Aservice -&gt; BLocalClient <ul>
<li>BLocalClient</li>
<li>ALocalClient</li>
</ul>
</li>
</ul>
</li>
<li><p>helper 工具类包</p>
</li>
<li><p>config 引入各组件的配置</p>
</li>
<li><p>component 存放着系统无关、可以随时迁移的自定义组件</p>
</li>
<li><p>common 存放着系统无关、可以随时迁移的实体、常量类、异常类</p>
</li>
</ul>
</li>
</ul>
<h2 id="DDD代码编排："><a href="#DDD代码编排：" class="headerlink" title="DDD代码编排："></a>DDD代码编排：</h2><ol>
<li><p>interfaces-&gt;</p>
<ol>
<li>application-&gt;<ol>
<li>domainService-&gt;<ol>
<li>Repository(聚合跟DeviceExecuteRepo)-&gt;<ol>
<li>DeviceMapper-&gt;<ol>
<li>DeviceDao-&gt;DeviceDao.xml</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>domainService-&gt;<ol>
<li>发布事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Job/Mq/Eventlistener 监听到事件或MQ-&gt;</p>
<ol>
<li>application-&gt; <ol>
<li>domainService-&gt;<ol>
<li>业务逻辑    </li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222626509.png" alt="image-20210902222626509"></p>
<h2 id="DDD可指导单体项目和微服务架构"><a href="#DDD可指导单体项目和微服务架构" class="headerlink" title="DDD可指导单体项目和微服务架构"></a>DDD可指导单体项目和微服务架构</h2><h3 id="微服务架构治标不治本"><a href="#微服务架构治标不治本" class="headerlink" title="微服务架构治标不治本"></a>微服务架构治标不治本</h3><p>​    几遍在微服务架构下，比如订单服务部署了多个节点，也避免不了每个节点内代码的复杂和凌乱，因此，在DDD指导下，无论单体还是微服务架构下，每个领域后续都可拆分或者当成一个微服务来看待</p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902221834222.png" alt="image-20210902221834222"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222916470.png" alt="image-20210902222916470"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222841017.png" alt="image-20210902222841017"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223018287.png" alt="image-20210902223018287"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223029121.png" alt="image-20210902223029121"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902215335205.png" alt="image-20210902215335205"></p>
<h2 id="DDD与中台"><a href="#DDD与中台" class="headerlink" title="DDD与中台"></a>DDD与中台</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223538517.png" alt="image-20210902223538517"></p>
<h2 id="DDD并非银弹"><a href="#DDD并非银弹" class="headerlink" title="DDD并非银弹"></a>DDD并非银弹</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902224541628.png" alt="image-20210902224541628"></p>
<p>数据中台的定义：<a href="https://www.sohu.com/a/425913998_114819">https://www.sohu.com/a/425913998_114819</a></p>
<blockquote>
<p>在数据应用和统计分散化的背景下，通过建设统一的数据服务体系，结合业务、安全、风控等相关诉求，完成数据的采集、清晰、建模等行为，并提供准确以及及时的数据服务、以满足企业不断复杂变化的数据统计与数据应用的需求</p>
</blockquote>
<p>实例一：今年我们的库存周转率如何协调财务、库存、运营的口径或者标准</p>
<p>实例二：如何统一提供sku管理和服务（商品中台）</p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210903000820115.png" alt="image-20210903000820115"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2>]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>中台</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 入门简介</title>
    <url>/2021/02/14/MyArticle/</url>
    <content><![CDATA[<p>学习笔记！2020年2月5日13点13分<br>—    #安装Nodejs<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本<br>mkdir blog    #创建blog目录<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>-—<br>#配置_config.yml<br>-—-</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
</code></pre>
<p>​    deploy:<br>          type: git<br>         repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>          branch: master<br>-—-<br>hexo d    #部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p>
<p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p>
<p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p>
<p>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
      <categories>
        <category>随心记</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>myBatis基础</title>
    <url>/2021/05/05/Mybatis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、myBatis-核心概念"><a href="#一、myBatis-核心概念" class="headerlink" title="一、myBatis 核心概念"></a>一、myBatis 核心概念</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​    MyBatis 是一款优秀的<strong>持久层</strong>框架，它支持<strong>定制化 SQL</strong>、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p>
<p>其它持久层解决方案对比：</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/image-20210505210233881.png"></p>
<p>如图所示：普通的操作SQL的流程包括：</p>
<p>​    获取连接、声明预处理器、设置参数、拼装SQL、执行获取结果集、封装成Java对象</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>​    Java DataBase Connectivity ，java数据库连接技术） 用来访问各种数据库 。JDBC 规范定义接口 ， 具体的实现由各大数据库厂商来实现。每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动，数据库驱动由数据库厂商提供。</p>
<h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><p>​    就是Spring对JDBC的封装，目的是使JDBC更加易于使用。</p>
<h3 id="Hibernate-全自动"><a href="#Hibernate-全自动" class="headerlink" title="Hibernate( 全自动)"></a>Hibernate( 全自动)</h3><p>​    基于ORM,对象关系映射(Object Relational Mapping),简单的说ORM框架就是数据库的表和简单Java对象的映射关系模型，我们通过这层映射关系就可以简单迅速地把数据库表的数据转化为POJO</p>
<p>​    缺点：定制化或者优化SQL学习成本较高，需要学习HQL</p>
<p>​    <strong>智能机器人，但研发它（学习、熟练度）的成本很高，工作都可以摆脱他了，但仅限于它能做的事。（强大、方便、高效、复杂、绕弯子、全自动）</strong></p>
<h3 id="Mybatis-半自动化"><a href="#Mybatis-半自动化" class="headerlink" title="Mybatis(半自动化)"></a>Mybatis(半自动化)</h3><p>​    <strong>机械工具，使用方便，拿来就用，但工作还是要自己来作，不过工具是活的，怎么使由我决定。（小巧、方便、高效、简单、直接、半自动）</strong></p>
<p>​    方便，学习成本低、便于优化SQL</p>
<h2 id="2、核心对象的作用域与生命周期"><a href="#2、核心对象的作用域与生命周期" class="headerlink" title="2、核心对象的作用域与生命周期"></a>2、核心对象的作用域与生命周期</h2><h3 id="1、mybatis-config-xml"><a href="#1、mybatis-config-xml" class="headerlink" title="1、mybatis-config.xml"></a>1、mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.0.147/luban&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/tuling/mybatis/dao/xml/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="2、UserMapper-xml"><a href="#2、UserMapper-xml" class="headerlink" title="2、UserMapper.xml"></a>2、UserMapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>    select * from User where id = #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3、测试代码"><a href="#3、测试代码" class="headerlink" title="3、测试代码"></a>3、测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br><span class="hljs-comment">//读取配置文件</span><br>InputStream inputStream = Resources.getResourceAsStream(resource);<br><span class="hljs-comment">//文件流转成configuration对象构建出 SqlSessionFactory</span><br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br><span class="hljs-comment">//SqlSessionFactory获取session对象</span><br>SqlSession session = sqlSessionFactory.openSession();<br>User result = session.selectOne(<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper.selectUser&quot;</span>, <span class="hljs-number">1</span>);<br>System.out.println(result.toString());<br></code></pre></td></tr></table></figure>

<h3 id="4、SqlSessionFactoryBuilder："><a href="#4、SqlSessionFactoryBuilder：" class="headerlink" title="4、SqlSessionFactoryBuilder："></a>4、SqlSessionFactoryBuilder：</h3><p> 用于构建会话工厂，基于 config.xml environment 、props 构建会话工厂,构建完成后即可丢弃。</p>
<h3 id="5、SqlSessionFactory："><a href="#5、SqlSessionFactory：" class="headerlink" title="5、SqlSessionFactory："></a>5、SqlSessionFactory：</h3><p>用于生成会话的工厂，<strong>作用于整个应用运行期间</strong>，一般不需要构造多个工厂对像</p>
<h3 id="6、SqlSession："><a href="#6、SqlSession：" class="headerlink" title="6、SqlSession："></a>6、SqlSession：</h3><p><strong>作用于单次会话</strong>，如WEB一次请求期间，不能用作于某个对像属性，也不能在多个线程间共享，因为它是==<strong>线程不安全的</strong>==</p>
<h3 id="7、接口式编程"><a href="#7、接口式编程" class="headerlink" title="7、接口式编程"></a>7、接口式编程</h3><p>由于每次调用时都去找对应用 statement 以及拼装参数，使用上不是特别友好，myBatis 引入了接口的机制，将接口与mapper.xml  的namespace 名称绑定，MyBatis就可以根据ASM工具动态构建该接口的实例。</p>
<p>mapper 映射器接口实例</p>
<p>通过 session.getMapper(Class<T> type) 就可以获取mapper 实例，该实例一般作用于方法域。</T></p>
<h1 id="二、全局的-configuration-配置"><a href="#二、全局的-configuration-配置" class="headerlink" title="二、全局的 configuration 配置"></a>二、全局的 configuration 配置</h1><h2 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h2><p>properties 元素可以通过 resource 或url 加载外部 properties文件中的属性，也可以直接设置property 属性。然后在xml 中就可以通过${属性名}进行引用替换。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;app.properties&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.oracle.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>resource= app.properties  从class path中加载</p>
<p>url=<a href="file:///G:/git/tuling-mybatis/src/main/resources/app.properties">file:///G:/git/tuling-mybatis/src/main/resources/app.properties</a> 基于url加载</p>
<p>引用属性方式：</p>
<p>${jdbc.user}</p>
<p>从 MyBatis 3.4.2 开始，位符指定一个默认值。例如：${jdbc.user:root}</p>
<h2 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h2><p>一个项目经常需要在例如开发坏境、测试环境、预演环境、生产环境中等不同环境中进行部署，每个环境所对应的参数是不一样的，myBatis 中可以通过 environment 来设置不同环境的属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--type=JDBC|MANAGED--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- type=UNPOOLED|POOLED|JNDI--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;UNPOOLED&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可通过 SqlSessionFactoryBuilder.build( environment) 来指定初始化哪套环境。</p>
<h2 id="3、设置"><a href="#3、设置" class="headerlink" title="3、设置"></a>3、设置</h2><p>设置MyBatis 全局参数，约定myBatis 的全局行为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 开启二级缓存--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-comment">&lt;!-- 开启驼峰命名适配--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>示例驼峰命名开启与关闭：</p>
<p>l 尝试开关 mapUnderscoreToCamelCase 属性 来观察Account 数据查询情况。</p>
<h2 id="4、别名"><a href="#4、别名" class="headerlink" title="4、别名"></a>4、别名</h2><p>在myBatis 中经常会用到 java 中类型，如sql 块中中 parameterType  参数引用中 javaType 结果集映射的javaType ,都要使用java 全路径名，可以通过 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>提示：建议不要设置。因为常用的类 mybatis 已经内置别名，而自定义的类设置别反而不好去找，影响阅读。</p>
<h2 id="5、类型处理器"><a href="#5、类型处理器" class="headerlink" title="5、类型处理器"></a>5、类型处理器</h2><p>持久层框架其中比较重要的工作就是处理数据的映射转换，把java 类型转换成jdbc 类型的参数，又需要把jdbc 类型的结果集转换成java 类型。在mybatis 中是通过 TypeHandler 接口来实现的。</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps4.jpg" alt="img"> </p>
<p> 可以看到 typeHandler 就是两个作用 设置参数 与获取结果。</p>
<p>你可以设置自定义处理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">typeHandler</span> <span class="hljs-attr">handler</span>=<span class="hljs-string">&quot;org.mybatis.example.ExampleTypeHandler&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeHandlers</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以通过以下两种方式指定处理的范围</p>
<p>1、javaType=”long”, jdbcType=”Date”</p>
<p>2、@MappedJdbcTypes( jdbc类型) @MappedTypes    java类型</p>
<h3 id="1、示例：long-类型时间戳转换成-日期类型"><a href="#1、示例：long-类型时间戳转换成-日期类型" class="headerlink" title="1、示例：long 类型时间戳转换成 日期类型"></a>1、示例：long 类型时间戳转换成 日期类型</h3><h3 id="2、添加算定义处理类："><a href="#2、添加算定义处理类：" class="headerlink" title="2、添加算定义处理类："></a>2、添加算定义处理类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MappedJdbcTypes(JdbcType.TIMESTAMP)</span><br><span class="hljs-meta">@MappedTypes(Long.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongTimeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTypeHandler</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNonNullParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-keyword">int</span> i, Long parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	ps.setDate(i, <span class="hljs-keyword">new</span> Date(parameter));<br>  &#125;<br>    <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> rs.getDate(columnName).getTime();<br>  &#125;<br>    <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> rs.getDate(columnIndex).getTime();<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> cs.getDate(columnIndex).getTime();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在resultMap中指定 typeHandler：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.LongTimeHandler&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;account2&quot;</span>&gt;</span><br>	 select a.*,a.createTime as createTimestamp from account a where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="6、mappers映谢器"><a href="#6、mappers映谢器" class="headerlink" title="6、mappers映谢器"></a>6、mappers映谢器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;http://www.xxx.com/xml/BlogMapper.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>加载方式：</p>
<p>1、 resource 基于classPath 加载xml文件</p>
<p>2、url:基于资源定位加载xml 文件</p>
<p>3、class:基于接口加载</p>
<p>4、package ：扫描包下所有class 然后进行加载</p>
<p>约定规则：</p>
<p><strong>1、mapper 中的 namespace必须与对应的接口名称对应。</strong></p>
<p><strong>2、通过 class 或package 中加载时 .xml 文件必须与接口在同一级目录。</strong></p>
<h1 id="三、mapper-文件"><a href="#三、mapper-文件" class="headerlink" title="三、mapper 文件"></a>三、mapper 文件</h1><h2 id="1、sql语句块statement"><a href="#1、sql语句块statement" class="headerlink" title="1、sql语句块statement"></a>1、sql语句块statement</h2><p>通过原生JDBC写DAO的年代 ，程序员最怕莫过于 拼接SQL语句，拼接参数与设置返回结果集，Hibernate 将拼接SQL时代成为过去，通过ORM映谢，完全不需要处理任何SQL，但这又带来了新的问题就是。无法编写自定义SQL从而丧失了灵活活及更好的性能。MyBatis 通过 mapper 映射SQL很好解决了这一点。它无需在JAVA代码中拼接SQL，而是将其移至mapper 文件集中处理SQL节约了大量的开发时间。</p>
<h3 id="2、Mapper中的元素"><a href="#2、Mapper中的元素" class="headerlink" title="2、Mapper中的元素"></a>2、Mapper中的元素</h3><blockquote>
<p>cache – 对给定命名空间的缓存配置。</p>
<p>resultMap – 结果集映射。</p>
<p>sql – 可被其他语句引用的可重用语句块。</p>
<p>insert – 插入语句</p>
<p>update – 更新语句</p>
<p>delete –删除语句</p>
<p>select – 查询语句</p>
</blockquote>
<h3 id="3、select-用法及属性"><a href="#3、select-用法及属性" class="headerlink" title="3、select 用法及属性"></a><strong>3、select 用法及属性</strong></h3><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br> select * from account where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--属性：--&gt;</span><br>&lt;select<br> id=&quot;selectById&quot;     <span class="hljs-comment">&lt;!-- 语句块的唯一标识 与接口中方法名称对应 --&gt;</span><br> parameterType=&quot;User&quot;  <span class="hljs-comment">&lt;!--参数java类型--&gt;</span><br> resultType=&quot;hashmap&quot;  <span class="hljs-comment">&lt;!--返回结果java类型--&gt;</span><br> resultMap=&quot;userResultMap&quot; <span class="hljs-comment">&lt;!--返回结果映射--&gt;</span><br> flushCache=&quot;false&quot;    <span class="hljs-comment">&lt;!--true 每次调用都会刷新 一二级缓存--&gt;</span><br> useCache=&quot;true&quot;     <span class="hljs-comment">&lt;!--true 是否保存至二级缓存当中去--&gt;</span><br> timeout=&quot;10&quot;<br> statementType= PREPARED&quot;&gt;<br></code></pre></td></tr></table></figure>

<h3 id="4、insert-amp-update-amp-delete-用法"><a href="#4、insert-amp-update-amp-delete-用法" class="headerlink" title="4、insert&amp;update&amp;delete 用法"></a><strong>4、insert&amp;update&amp;delete 用法</strong></h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&lt;insert<br> id=&quot;addUser&quot;  <span class="hljs-comment">&lt;!-- 语句块的唯一标识 与接口中方法名称对应 --&gt;</span><br> parameterType=&quot;User&quot;  <span class="hljs-comment">&lt;!--参数java类型--&gt;</span><br> flushCache=&quot;true&quot;  <span class="hljs-comment">&lt;!--true 每次调用都会刷新 一二级缓存--&gt;</span><br> statementType=&quot;PREPARED&quot; &lt;执行类型&gt;<br> keyProperty=&quot;&quot;    <span class="hljs-comment">&lt;!--主键对应的java 属性，多个用 逗号分割--&gt;</span><br> keyColumn=&quot;&quot;     <span class="hljs-comment">&lt;!--主键列，多个用 逗号分割--&gt;</span><br> useGeneratedKeys=&quot;&quot;  <span class="hljs-comment">&lt;!--插入成功后将 将值回设至 原参数-&gt;</span><br><span class="hljs-comment"> timeout=&quot;20&quot;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;!--示例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>  insert into  user (name,updateTime,createTime) values (#&#123;name&#125;,#&#123;updateTime&#125;,#&#123;createTime&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="5、参数映射"><a href="#5、参数映射" class="headerlink" title="5、参数映射"></a>5、参数映射</h3><p>参数映射是最强大功能之一，基可以通过以下方式进行引用</p>
<blockquote>
<p>1、单个简单参数引用 :如果方法中只有一个参数可通过任意名称 进行引用<br>2、多个简单参数引用：通过参数下标引用 #{arg0} #{arg1}  或 #{param1} ,#{param2}<br>3、对像属性引用: 直接通过对象属性名称引用，嵌套对像通过. 号进行引用<br>4、map key值引用：变量名称引用(需要jdk1.8支持) ：通过方法中参数名称引用，需要jdk1.8支持，且在编译时必须加上 -parameters 编译命令</p>
</blockquote>
<p>在idea 中添加 编译参数</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps5.jpg" alt="img"> </p>
<p>在maven中添加 编译参数</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps6.jpg" alt="img"> </p>
<p>注：一但可通过变量名称引入不在支持arg0获取！</p>
<p>参数引用 相关属性</p>
<p>javaType=int, #参数java类型</p>
<p>jdbcType=NUMERIC,# jdbc类型</p>
<p>typeHandler=MyTypeHandler#  指定类型处理器</p>
<h3 id="6、参数拼接"><a href="#6、参数拼接" class="headerlink" title="6、参数拼接${}"></a><strong>6、参数拼接${}</strong></h3><p>​    基于#的参数引用 其原理是通过 ？占位其通过预处理能获得<strong>更好的性能 和安全性（防止SQL注入）</strong></p>
<p>但有些需求是通过?占位无法实现的，比如在一些分库分表的场景中我们需要 动态的拼接表结构。</p>
<p>比如某系统日志表是按年进行切割的 2018_systemlog,2019_systemlog这时就可以通过</p>
<p> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;SELECT * FROM $&#123;table&#125; WHERE id = #&#123;id&#125;&quot;)</span><br><span class="hljs-function">User <span class="hljs-title">selectByTable</span><span class="hljs-params">(String table, <span class="hljs-keyword">int</span> id)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="7、结果集映射"><a href="#7、结果集映射" class="headerlink" title="7、结果集映射"></a>7、结果集映射</h3><h4 id="1、结果集映射"><a href="#1、结果集映射" class="headerlink" title="1、结果集映射"></a>1、结果集映射</h4><p>结果集映射是指 将resultSet 中内容封装转换成java对像，在纯jdbc时代全部都是用调用resultSet的getXXX(columnName) 来获取属性并封装。代码量大，编程效率低尤其当数据模型是1对多，或多对多这种复杂关系，这种封装代码将会变得非常复杂。结果集映射就是为解决这个问题 通过resultMap 集中处理 结果集与JAVA对像的关系。</p>
<h5 id="1、结果集自动映射"><a href="#1、结果集自动映射" class="headerlink" title="1、结果集自动映射"></a>1、结果集自动映射</h5><p>在select 中指定 resultType=“” 后无需要任何配置 myBatis 会基于 resultType中的java类型及属性自动推断生成 一个隐示的resultMap  从而完成结果映谢resultMap但有时jdbc   并不是与java Bean 完全贴合这时就需要手动设置resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.LongTimeHandler&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这时在select元素中用 resultMap =”account2” 即可引用该map映射。</p>
<p>基本元素与属性</p>
<blockquote>
<p>ID：用于结果集中的唯一标识<br>result：设置一个某通过字段<br>property:<br>jdbcType:<br>javaType:<br>column:<br>typeHandler:</p>
</blockquote>
<h5 id="2、嵌套结果映射"><a href="#2、嵌套结果映射" class="headerlink" title="2、嵌套结果映射"></a>2、嵌套结果映射</h5><p>关联 association<br>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountAndUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;userName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAccountAndUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;accountAndUser&quot;</span>&gt;</span><br>    SELECT a.*, b.name userName from account a,user b where a.user_id=b.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="3、引入外部Select"><a href="#3、引入外部Select" class="headerlink" title="3、引入外部Select"></a>3、引入外部Select</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--基于多次查询拼装引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountAndUser2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span> 		                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>    select * from user  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码</title>
    <url>/2021/06/14/Spring-01-%E5%B7%A5%E5%8E%82%E7%B1%BB%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring框架功能整体介绍"><a href="#Spring框架功能整体介绍" class="headerlink" title="Spring框架功能整体介绍"></a>Spring框架功能整体介绍</h1><img src="/images/Spring-01-工厂类与常用注解/image-20210614232348569.png" alt="image-20210614232348569" style="zoom: 67%;">

<h2 id="Spring-Core-Container"><a href="#Spring-Core-Container" class="headerlink" title="Spring Core Container"></a>Spring Core Container</h2><p>​    Core 和 Beans 模块是框架的基础部分，提供 IoC （转控制）和依赖注入特性。 这里的基础 概念是 BeanFactory，它提供对 Factory 模式的经典实 现来消除对程序’性单例模式的需要，并真 正地允许你从程序逻辑中分离出依赖关系和配置</p>
<p>​    <strong>Core</strong>：主要包含 Spring 框架基本的核心工具类， Spring 的其他组件都要用到这个包 里的类， Core模块是其他组件的基 本核心。</p>
<p>​    <strong>Beans</strong> (BeanFacotry)：它包含访问配直文件、创建和管理 bean 以及进行 Inversion of Control I Dependency Injection ( IoC/DI ）操作相关的所有类</p>
<p>​    <strong>Context</strong>(处理BeanFactory，一般还是ApplicationContext起作用)：构建于 Core 和 Beans 模块基础之上，提供了一种类似JNDI 注册器的框 架式的对象访问方法。 Context 模块继承了 Beans 的特性，为 Spring 核 心提供了大量 扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对 Context 的透明创 建的支持。 Context 模块同时也支持 J2EE 的一些特 性， ApplicationContext 接口是 Context 模块的关键</p>
<p>​    Expression Language：模块提供了强大的表达式语言，用于在运行时查询和操纵对象。 它是 JSP 2.1 规范中定义的 unifed expression language 的扩展。 该语言支持设直／获取属 性的值，属性的分配，方法的调用，访问数组上下文（ accessiong the context of arrays ）、 容器和索引器、逻辑和算术运算符、命名变量以及从Spring的 IoC 容器中根据名称检 索对象。 它也支持 list 投影、选择和一般的 list 聚合</p>
<h2 id="Spring-Data-Access-Integration"><a href="#Spring-Data-Access-Integration" class="headerlink" title="Spring Data Access/Integration"></a>Spring Data Access/Integration</h2><p>​    <strong>JDBC：</strong>模块提供了一个 JDBC 抽象层，它可以消除冗长的 JDBC 编码和解析数据库厂 商特有的错误代码。这个模块包含了 Spring 对 JDBC 数据访问进行封装的所有类</p>
<p>​    <strong>ORM：</strong>模块为流行的对象－关系映射API，如 JPA、 JDO、 Hibernate、 iBatis 等，提供了 一个交互层。 利用 ORM 封装包，可以混合使用所有 Spring 提供的特性进行 O/R 映射， 如前边提到的简单声 明性事务管理。</p>
<p>​    <strong>OXM：</strong> <strong>模块提供了一个对</strong> ObjecνXML <strong>映射实现的抽象层，</strong></p>
<p>​    <strong>JMS ( Java Messaging Service )：</strong>模块主要包含了 一些制造和消 费消息的特性。</p>
<p>​    <strong>Transaction：</strong>支持编程和声明性的事务管理，这些事务类必须实现特定的接口，并 且对所有的 POJO 都适用</p>
<h2 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h2><p>​    Web 模块：提供了基础的面向 Web 的集成特性c.例如，多文件上传、使用 servlet listeners 初始化IoC 容器以及一个面向 Web 的应用上下文。 它还包含 Spring 远程支持中 Web 的相关部分。</p>
<h2 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h2><p>​    <strong>Aspects</strong> 模块提供了对 AspectJ 的集成支持。</p>
<p>​    <strong>Instrumentation</strong> 模块提供了 class instrumentation 支持和     classloader 实现，使得可以在特定的应用服务器上使用</p>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Test 模块支持使用 JUnit 和 TestNG 对 Spring 组件进行测试</p>
<h2 id="Spring容器继承图"><a href="#Spring容器继承图" class="headerlink" title="Spring容器继承图"></a>Spring容器继承图</h2><p><img src="/images/Spring-01-%E5%B7%A5%E5%8E%82%E7%B1%BB%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/BeanFactory.png"></p>
<h2 id="IOC和DI-控制反转和依赖注入"><a href="#IOC和DI-控制反转和依赖注入" class="headerlink" title="IOC和DI(控制反转和依赖注入)"></a>IOC和DI(控制反转和依赖注入)</h2><p>​        <strong>DI：</strong>软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）</p>
<p>​        <strong>IOC：</strong>的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度</p>
<h1 id="SpringIOC容器底层注解使用"><a href="#SpringIOC容器底层注解使用" class="headerlink" title="SpringIOC容器底层注解使用"></a>SpringIOC容器底层注解使用</h1><h2 id="往容器中定义bean信息的方式"><a href="#往容器中定义bean信息的方式" class="headerlink" title="往容器中定义bean信息的方式"></a>往容器中定义bean信息的方式</h2><p>在标有@Configuration的类上</p>
<ol>
<li>@Bean(<strong>适用于导入第三方组件的类</strong>)</li>
<li>通过@CompentScan +@Controller @Service @Respository @compent<ol>
<li>排除用法 excludeFilters(排除@Controller注解的,和TulingService的)</li>
<li>包含用法 includeFilters ,注意，若使用包含的用法，需要把useDefaultFilters属性设置为false（true表<br>示扫描全部的）</li>
<li>@ComponentScan.Filter type的类型<ol>
<li>注解形式的FilterType.ANNOTATION @Controller @Service @Repository @Compent</li>
<li>指定类型的 FilterType.ASSIGNABLE_TYPE @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = {TulingService.class})</li>
<li>aspectj类型的 FilterType.ASPECTJ(不常用) d)正则表达式的 FilterType.REGEX(不常用)</li>
<li>e)自定义的 FilterType.CUSTOM</li>
</ol>
</li>
<li>适用场景: 针对我们自己写的组件可以通过该方式来进行加载到容器中。</li>
</ol>
</li>
<li>@Import<strong>（导入组件的</strong>id<strong>为全类名路径）</strong><ol>
<li>ImportSeletor</li>
<li>ImportBeanDefinitionRegister</li>
</ol>
</li>
<li>@BeanFactory（创建复杂对象如SqlSessionFactoryBean）</li>
</ol>
<h2 id="配置Bean的作用域对象"><a href="#配置Bean的作用域对象" class="headerlink" title="配置Bean的作用域对象"></a>配置Bean的作用域对象</h2><h3 id="Scope指定的作用域方法取值"><a href="#Scope指定的作用域方法取值" class="headerlink" title="@Scope指定的作用域方法取值"></a>@Scope指定的作用域方法取值</h3><ul>
<li>singleton 单实例的(默认)</li>
<li>prototype 多实例的</li>
<li>request 同一次请求</li>
<li>session 同一个会话级别</li>
</ul>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>​    bean的创建—–&gt;初始化    &gt;销毁方法</p>
<h3 id="bean的初始化和销毁"><a href="#bean的初始化和销毁" class="headerlink" title="bean的初始化和销毁"></a>bean的初始化和销毁</h3><p>由容器管理Bean的生命周期，我们可以通过自己指定bean的初始化方法和bean的销毁方法</p>
<p>​    <strong>针对单实例bean的话，容器启动的时候，bean的对象就创建了，而且容器销毁的时候，也会调用Bean的销毁方法</strong></p>
<p>​    <strong>针对多实例bean的话,容器启动的时候，bean是不会被创建的而是在获取bean的时候被创建，而且bean的销毁不受IOC容器的管理.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br><span class="hljs-comment">//指定了bean的生命周期的初始化方法和销毁方法.</span><br>	<span class="hljs-meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过 InitializingBean和DisposableBean 的二个接口实现bean的初始化以及销毁方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;<br>    	System.out.println(<span class="hljs-string">&quot;book 的构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    	System.out.println(<span class="hljs-string">&quot;book 的PostConstruct标志的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    	System.out.println(<span class="hljs-string">&quot;book 的PreDestory标注的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过Spring的BeanPostProcessor的 bean的后置处理器会拦截所有bean初始化过程</strong></p>
<p>​    postProcessBeforeInitialization 在init方法之前调用</p>
<p>​    postProcessAfterInitialization 在init方法之后调用</p>
<h2 id="组件赋值"><a href="#组件赋值" class="headerlink" title="组件赋值"></a>组件赋值</h2><p><strong>通过@Value +@PropertySource来给组件赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-comment">//通过普通的方式@Value(&quot;司马&quot;)</span><br>    <span class="hljs-keyword">private</span> String firstName;<br><br>    <span class="hljs-comment">//spel方式来赋值@Value(&quot;#&#123;28-8&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    通过读取外部配置文件的值<br>    <span class="hljs-meta">@Value(&quot;$&#123;person.lastName&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String lastName;<br><br>    &#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span> <span class="hljs-comment">//指定外部文件的位置public class MainConfig &#123;</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();           <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a><strong>自动装配</strong></h2><h3 id="AutoWired的使用"><a href="#AutoWired的使用" class="headerlink" title="@AutoWired的使用"></a>@AutoWired的使用</h3><ul>
<li><p>自动装配首先时按照类型进行装配，若在IOC容器中发现了多个相同类型的组件，那么就按照 属性名称来进行装配</p>
<ul>
<li><p>比如，我容器中有二个TulingDao类型的组件 一个叫tulingDao 一个叫tulingDao2</p>
<p>那么我们通过@AutoWired 来修饰的属性名称时tulingDao，那么拿就加载容器的tulingDao组件，若属性名称为<br>tulignDao2 那么他就加载的时tulingDao2组件</p>
</li>
</ul>
</li>
<li><p>假设我们需要指定特定的组件来进行装配，我们可以通过使用@Qualifier(“tulingDao”)来指定装配的组件或者在配置类上的@Bean加上@Primary注解</p>
</li>
<li><p>假设我们容器中即没有tulingDao 和tulingDao2,那么在装配的时候就会抛出异常No qualifying bean of type ‘com.tuling.testautowired.TulingDao’ available 若我们想不抛异常 ，我们需要指定 required为false的时候可以了</p>
</li>
<li><p>使用autowired 、</p>
<ul>
<li>可以标注在方法上标注在set方法上</li>
<li>标注在构造方法上</li>
<li>标注在配置类上的入参中（可以不写）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTulingLog</span><span class="hljs-params">(TulingLog tulingLog)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.tulingLog = tulingLog;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TulingAspect</span><span class="hljs-params">(TulingLog tulingLog)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.tulingLog = tulingLog;<br>&#125;<br><br><span class="hljs-comment">//标注在配置类上的入参中（可以不写）</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TulingAspect <span class="hljs-title">tulingAspect</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> TulingLog tulingLog)</span> </span>&#123; <br>    TulingAspect tulingAspect = <span class="hljs-keyword">new</span> TulingAspect(tulingLog);<br>    <span class="hljs-keyword">return</span> tulingAspect;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Resource-JSR250规范"><a href="#Resource-JSR250规范" class="headerlink" title="@Resource(JSR250规范)"></a>@Resource(JSR250规范)</h3><p>功能和@AutoWired的功能差不多一样，但是不支持@Primary 和@Qualifier</p>
<h3 id="InJect（JSR330规范）"><a href="#InJect（JSR330规范）" class="headerlink" title="@InJect（JSR330规范）"></a>@InJect（JSR330规范）</h3><p>需要导入jar包依赖<br>功能和支持@Primary功能 ,但是没有Require=false的功能</p>
<p>使用autowired 可以标注在方法上标注在set方法上</p>
<p>标注在构造方法上</p>
<p>标注在配置类上的入参中（可以不写）</p>
<h2 id="XXXAware接口-内部组件赋值"><a href="#XXXAware接口-内部组件赋值" class="headerlink" title="XXXAware接口(内部组件赋值)"></a>XXXAware接口(内部组件赋值)</h2><p>​    我们自己的组件 需要使用spring ioc的底层组件的时候,比如 ApplicationContext等我们可以通过实现XXXAware接口来实现</p>
<h2 id="Profile环境激活"><a href="#Profile环境激活" class="headerlink" title="@Profile环境激活"></a>@Profile环境激活</h2><p>来根据环境来激活标识不同的Bean </p>
<ol>
<li>@Profile标识在类上，那么只有当前环境匹配，整个配置类才会生效</li>
<li>@Profile标识在Bean上 ，那么只有当前环境的Bean才会被激活</li>
<li>没有标志为@Profile的bean 不管在什么环境都可以被激活</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:ds.properties&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EmbeddedValueResolverAware</span> </span>&#123;<br><br>	<span class="hljs-meta">@Value(&quot;$&#123;ds.username&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;ds.password&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String jdbcUrl; <br>    <span class="hljs-keyword">private</span> String classDriver; <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>    	<span class="hljs-keyword">this</span>.jdbcUrl = resolver.resolveStringValue(<span class="hljs-string">&quot;$&#123;ds.jdbcUrl&#125;&quot;</span>); <br>        <span class="hljs-keyword">this</span>.classDriver = resolver.resolveStringValue(<span class="hljs-string">&quot;$&#123;ds.classDriver&#125;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//标识为测试环境才会被装配@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;test&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">testDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-comment">//标识开发环境才会被激活@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;dev&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">devDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-comment">//标识生产环境才会被激活@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;prod&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">prodDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DataSource <span class="hljs-title">buliderDataSource</span><span class="hljs-params">(DruidDataSource dataSource)</span> </span>&#123; <br>        dataSource.setUsername(userName); dataSource.setPassword(password); <br>        dataSource.setDriverClassName(classDriver); dataSource.setUrl(jdbcUrl);<br>    	<span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring03-容器创建bean的过程.</title>
    <url>/2021/06/20/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/images/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/springBean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.svg" alt="springBean创建过程"></p>
<p><img src="/images/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/springBean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-1624458985065.svg"></p>
<p>比如我们容器中 TulingLog tulingLog = tcx.getBean(TulingLog.class); 容器中的过程是什么？         </p>
<p><strong>容器中的过程是什么？</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i1:&gt;org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String) <br>i2&gt;org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean <br>i3&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean <br>    创建bean的方法 <br>i4&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean <br>    真正的创建bean的逻辑 <br>i5&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingleton <br>    把创建好的实例化好的bean加载缓存中 <br>i6&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance<br>    对创建的bean进行后续的加工 <br></code></pre></td></tr></table></figure>

<p>doGetBean创建主要过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i2.1&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#transformedBeanName <br>    转换beanName <br>i2.2&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton <br>    去缓存中获取bean <br>i2.3&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance <br>    对缓存中的获取的bean进行后续处理 <br>i2.4&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#isPrototypeCurrentlyInCreation <br>    判断原型bean的依赖注入 <br>i2.5&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactory <br>    检查父容器加载bean <br>i2.6&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getMergedLocalBeanDefinition<br>    将bean定义转为RootBeanDifination <br>i2<span class="hljs-number">.7</span>&gt;:检查bean的依赖（bean加载顺序的依赖） <br>i2.8&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton<br>    根据scope的添加来创建bean <br></code></pre></td></tr></table></figure>

<p>doCreateBean具体创建流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i4.1&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance <br>    调用构造函数创建对象 <br>i4<span class="hljs-number">.2</span>&gt;:判断是否需要提早暴露对象(mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp; <span class="hljs-function">i <span class="hljs-title">sSingletonCurrentlyInCreation</span><span class="hljs-params">(beanName)</span>)</span>; <br>i4.3&gt;org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory <br>    暴露对象解决循环依赖 <br>i4.4&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean <br>    给创建的bean进行赋值 i4.5&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean<br>        对bean进行初始化 <br></code></pre></td></tr></table></figure>

<p>initializeBean初始化bean过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i4.5.1&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeAwareMethods <br>    调用XXAware接口 <br>i4<span class="hljs-number">.5</span><span class="hljs-number">.2</span>&gt;applyBeanPostProcessorsBeforeInitialization 调用bean的后置处理器进行对处理i4<span class="hljs-number">.5</span><span class="hljs-number">.2</span>&gt;applyBeanPostProcessorsBeforeInitialization 调用bean的后置处理器进行对处理 <br>i4.5.3&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods <br>    对象的初始化方法 <br>i4.5.3.1&gt;:org.springframework.beans.factory.InitializingBean#afterPropertiesSet <br>    调用InitializingBean的方法<br>i4<span class="hljs-number">.5</span><span class="hljs-number">.3</span><span class="hljs-number">.2</span>&gt;:String initMethodName = mbd.getInitMethodName();<br>	自定义的初始化方法 <br></code></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>创建单例bean</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot01-基础</title>
    <url>/2021/08/05/SpringBoot01-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="SpringBoot-概述"><a href="#SpringBoot-概述" class="headerlink" title="SpringBoot 概述"></a>SpringBoot 概述</h1><p>​    SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻</p>
<p>辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度</p>
<p>上缩短了项目周期。2014 年 4 月，Spring Boot 1.0.0 发布。Spring的顶级项目之一(<a href="https://spring.io)./">https://spring.io)。</a></p>
<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20210806213835019.png" alt="image-20210806213835019"></p>
<h2 id="Spring-缺点"><a href="#Spring-缺点" class="headerlink" title="Spring 缺点"></a>Spring 缺点</h2><h3 id="配置繁琐"><a href="#配置繁琐" class="headerlink" title="配置繁琐"></a>配置繁琐</h3><p>​    虽然Spring的组件代码是轻量级的，但它的<strong>配置</strong>却是重量级的。</p>
<p>​    一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。</p>
<p>​    因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以<strong>编写配置挤占了编写应用程序逻辑的时间</strong>。和所有框架一样，Spring实用，但它要求的回报也不少。</p>
<h3 id="依赖繁琐-依赖传递"><a href="#依赖繁琐-依赖传递" class="headerlink" title="依赖繁琐:依赖传递"></a>依赖繁琐:依赖传递</h3><p>​    项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发<br>进度。</p>
<h2 id="SpringBoot-功能"><a href="#SpringBoot-功能" class="headerlink" title="SpringBoot 功能"></a>SpringBoot 功能</h2><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>​    Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定</p>
<p>Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>
<p>​    启动时springBoot扫描自动配置的各组件自动配置类会，他们会自动根据环境中注入了那些组件来判断自动配置哪些东西</p>
<h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>​    起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的**==传递依赖==**</p>
<p>，这些东西加在一起即支持某项功能。</p>
<p>​    简单来说，<strong>起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能</strong></p>
<h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>​    提供了一些大型项目中常见的非功能性特性，如<strong>嵌入式服务器、安全、指标，健康检测、外部配置</strong>等。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    SpringBoot提供了一种快速开发Spring项目的方式，而不是对Spring功能上的增强。</p>
<p>​    Spring的缺点：<br>​         配置繁琐<br>​        依赖繁琐<br>​    SpringBoot功能：<br>​        自动配置<br>​        起步依赖：依赖传递<br>​        辅助功能</p>
<h1 id="SpringBoot-快速入门"><a href="#SpringBoot-快速入门" class="headerlink" title="SpringBoot 快速入门"></a>SpringBoot 快速入门</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需求 </p>
<p>​    搭建SpringBoot工程，定义UserController.hello()方法，返回”Hello SpringBoot!”。<br>实现步骤<br>​    ① 创建Maven项目<br>​    ② 导入SpringBoot起步依赖<br>​    ③ 定义Controller<br>​    ④ 编写引导类<br>​    ⑤ 启动测试</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>SpringBoot在创建项目时，使用jar（默认方式）的打包方式。（父类工程可以使用pom方式打包）</li>
<li>SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。</li>
<li>使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样，只是springboot自动根据我们导入的组件自动约定地配置和整合了一些组件</li>
</ol>
<h1 id="SpringBoot-起步依赖原理分析"><a href="#SpringBoot-起步依赖原理分析" class="headerlink" title="SpringBoot 起步依赖原理分析"></a>SpringBoot 起步依赖原理分析</h1><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-01-simple<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="起步依赖原理分析"><a href="#起步依赖原理分析" class="headerlink" title="起步依赖原理分析"></a>起步依赖原理分析</h2><p><strong>1） spring-boot-starter-parent</strong></p>
<ul>
<li>​    父工程是spring-boot-dependencies，是版本仲裁中心，定义了各个技术组件的版本信息，组合了一套最优搭配的技术版本</li>
</ul>
<p><strong>2） spring-boot-starter-web</strong></p>
<ul>
<li>定义了完成该功能需要的依赖坐标合计，其中版本信息来源于父工程</li>
</ul>
<h1 id="SpringBoot-配置"><a href="#SpringBoot-配置" class="headerlink" title="SpringBoot 配置"></a>SpringBoot 配置</h1><h2 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h2><p>​    SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用<strong>application.properties</strong>或者<strong>application.yml</strong>（application.yaml）进行配置。</p>
<ol>
<li><strong>SpringBoot提供了2种配置文件类型：properteis和yml/yaml</strong></li>
<li><strong>默认配置文件名称：application</strong> </li>
<li><strong>在同一级目录下优先级为：properties &gt; yml &gt; yaml</strong></li>
</ol>
<h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>​    YAML全称是 YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p>
<p>​    YAML文件的扩展名可以使用.yml或者.yaml。</p>
<p>⚫ properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-meta">server.address</span>=<span class="hljs-string">127.0.0.1</span><br></code></pre></td></tr></table></figure>

<p>⚫ xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>⚫ yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <br><span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>

<p>简洁，以数据为核心</p>
<h3 id="YAML：基本语法"><a href="#YAML：基本语法" class="headerlink" title="YAML：基本语法"></a>YAML：基本语法</h3><p>⚫ 大小写敏感</p>
<p>⚫ 数据值前边必须有空格，作为分隔符</p>
<p>⚫ 使用缩进表示层级关系</p>
<p>⚫ 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）</p>
<p>⚫ 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
<p>⚫ # 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <br>	<span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>	<span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">abc</span><br></code></pre></td></tr></table></figure>

<h3 id="YAML：数据格式"><a href="#YAML：数据格式" class="headerlink" title="YAML：数据格式"></a>YAML：数据格式</h3><p>对象(map)：键值对的集合</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">person:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>&#125;<br></code></pre></td></tr></table></figure>

<p>数组：一组按次序排列的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">address:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">beijing</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">shanghai</span><br><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">address:</span> [<span class="hljs-string">beijing</span>,<span class="hljs-string">shanghai</span>]<br></code></pre></td></tr></table></figure>

<p>纯量：单个的、不可再分的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">msg1:</span> <span class="hljs-string">&#x27;hello \n world&#x27;</span> <span class="hljs-comment"># 单引忽略转义字符</span><br><span class="hljs-attr">msg2:</span> <span class="hljs-string">&quot;hello \n world&quot;</span> <span class="hljs-comment"># 双引识别转义字符</span><br></code></pre></td></tr></table></figure>

<h3 id="YAML：小结"><a href="#YAML：小结" class="headerlink" title="YAML：小结"></a>YAML：小结</h3><ol>
<li><strong>配置文件类型</strong><ol>
<li><strong>properties：和以前一样</strong></li>
<li><strong>yml/yaml：注意空格</strong></li>
</ol>
</li>
<li><strong>yaml：简洁，以数据为核心</strong><ol>
<li><strong>基本语法</strong><ol>
<li><strong>大小写敏感</strong></li>
<li><strong>数据值前边必须有空格，作为分隔符</strong></li>
<li><strong>使用空格缩进表示层级关系，相同缩进表示同一级</strong></li>
</ol>
</li>
<li> <strong>数据格式</strong></li>
<li><strong>对象</strong></li>
<li><strong>数组: 使用 “- ”表示数组每个元素</strong></li>
<li><strong>纯量</strong></li>
<li> <strong>参数引用</strong></li>
<li><strong>${key}</strong></li>
</ol>
</li>
</ol>
<h2 id="读取配置内容"><a href="#读取配置内容" class="headerlink" title="读取配置内容"></a>读取配置内容</h2><ul>
<li>@Value</li>
<li>Environment</li>
<li>@ConfigurationProperties (prefix=”配置文件前缀，如：swagger.spring”)</li>
</ul>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>​    我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。</p>
<p>​    profile功能就是来进行动态配置切换的。</p>
<p>1） profile配置方式</p>
<p>​        多profile文件方式</p>
<p>​        yml多文档方式</p>
<p>2） profile激活方式</p>
<p>​        配置文件</p>
<p>​        虚拟机参数</p>
<p>​        命令行参数</p>
<p>​        maven 选中</p>
<h3 id="Profile-小结"><a href="#Profile-小结" class="headerlink" title="Profile-小结"></a>Profile-小结</h3><p>1） profile是用来完成不同环境下，配置动态切换功能的。</p>
<p>2） profile配置方式</p>
<ul>
<li>多profile文件方式：提供多个配置文件，每个代表一种环境。<ul>
<li>application-dev.properties/yml 开发环境</li>
<li>application-test.properties/yml 测试环境</li>
<li>application-pro.properties/yml 生产环境</li>
</ul>
</li>
<li>yml多文档方式：<ul>
<li>在yml中使用 — 分隔不同配置</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure>

<p>3）profile激活方式</p>
<ul>
<li>配置文件： 再配置文件中配置：spring.profiles.active=dev</li>
<li>虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev</li>
<li>命令行参数：java –jar xxx.jar –spring.profiles.active=dev</li>
<li>maven 选中 </li>
</ul>
<h2 id="内部配置加载顺序"><a href="#内部配置加载顺序" class="headerlink" title="内部配置加载顺序"></a>内部配置加载顺序</h2><p>Springboot程序启动时，会从以下位置加载配置文件：</p>
<ul>
<li>file:./config/：当前项目下的/config目录下</li>
<li>file:./ ：当前项目的根目录</li>
<li>classpath:/config/：classpath的/config目录</li>
<li>classpath:/ ：classpath的根目录</li>
</ul>
<p><strong>加载顺序为上文的排列顺序，高优先级配置的属性会生效</strong></p>
<h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h2><p>通过官网查看外部属性加载顺序：</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html</a></p>
<h1 id="SpringBoot打包"><a href="#SpringBoot打包" class="headerlink" title="SpringBoot打包"></a>SpringBoot打包</h1><h2 id="打成指定的jar名称的"><a href="#打成指定的jar名称的" class="headerlink" title="打成指定的jar名称的"></a>打成指定的jar名称的</h2><h2 id="多个mainclass"><a href="#多个mainclass" class="headerlink" title="多个mainclass"></a>多个mainclass</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>		<span class="hljs-comment">&lt;!--		指定打包的文件名称		 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>mySpringboot<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>					<span class="hljs-comment">&lt;!-- 指定启动类 --&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.study.springboot01simple.Springboot01SimpleApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>				<span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20210811220220670.png" alt="image-20210811220220670"></p>
<h2 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>​    指定springboot pom中的打包方式 由jar改为war </p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>​    在spring-boot-starter-web模块打包比依赖与 tomcat第二步:在spring-boot-starter-web模块打包比依赖与 tomcat </p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>​    主启动类上 实现SpringBootServletInitializer 从写confiure方法</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>​    打成war包 放在tomcat上运行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01SimpleApplication2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        SpringApplication.run(Springboot01SimpleApplication2.class,args);<br>        System.out.println(Springboot01SimpleApplication2.class.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Springboot01SimpleApplication2.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="SpringBoot-整合篇"><a href="#SpringBoot-整合篇" class="headerlink" title="SpringBoot-整合篇"></a>SpringBoot-整合篇</h1><h2 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h2><p>① 搭建SpringBoot工程</p>
<p>② 引入starter-test起步依赖</p>
<p>③ 编写测试类</p>
<p>④ 添加测试相关注解</p>
<p>​    @RunWith(SpringRunner.class)</p>
<p>​    @SpringBootTest(classes = 启动类.class)</p>
<p>⑤ 编写测试方法</p>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><h1 id="自定义redis-spring-boot-starter"><a href="#自定义redis-spring-boot-starter" class="headerlink" title="自定义redis-spring-boot-starter"></a>自定义redis-spring-boot-starter</h1><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot02-webmvc</title>
    <url>/2021/08/11/SpringBoot02-webmvc/</url>
    <content><![CDATA[<h1 id="SpringBoot的web开发"><a href="#SpringBoot的web开发" class="headerlink" title="SpringBoot的web开发"></a>SpringBoot的web开发</h1><h2 id="webJar"><a href="#webJar" class="headerlink" title="webJar"></a>webJar</h2><p>​    以jar包的形式来引入前端资源,比如jquery 或者是BootStrap：<a href="https://www.webjars.org/">https://www.webjars.org</a></p>
<p>前端资源映射规则 核心源代码:WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>              logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>              <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>                  registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>                      ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, <span class="hljs-string">&quot;/&quot;</span>);<br>                      registration.addResourceLocations(<span class="hljs-keyword">new</span> Resource[]&#123;resource&#125;);<br>                  &#125;<br><br>              &#125;);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080//webjars/jquery/3.3.1-2/jquery.js">http://localhost:8080//webjars/jquery/3.3.1-2/jquery.js</a></p>
<p>控制台打印：</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210811233641951.png" alt="image-20210811233641951"></p>
<p>源码追踪：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest方法 &gt;org.springframework.web.servlet.resource.ResourceHttpRequestHandler#getResource &gt;org.springframework.web.servlet.resource.ResourceResolverChain#resolveResource &gt;org.springframework.web.servlet.resource.PathResourceResolver#resolveResourceInternal &gt;org.springframework.web.servlet.resource.PathResourceResolver#getResource(真正的资源映射 处理逻辑)<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String resourcePath, <span class="hljs-meta">@Nullable</span> HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">			List&lt;? extends Resource&gt; locations)</span> </span>&#123;<br><br>		<span class="hljs-keyword">for</span> (Resource location : locations) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				String pathToUse = encodeOrDecodeIfNecessary(resourcePath, request, location);<br>				Resource resource = getResource(pathToUse, location);<br>				<span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>					<span class="hljs-keyword">return</span> resource;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					String error = <span class="hljs-string">&quot;Skip location [&quot;</span> + location + <span class="hljs-string">&quot;] due to error&quot;</span>;<br>					<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>						logger.trace(error, ex);<br>					&#125;<br>					<span class="hljs-keyword">else</span> &#123;<br>						logger.debug(error + <span class="hljs-string">&quot;: &quot;</span> + ex.getMessage());<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="静态页面映射"><a href="#静态页面映射" class="headerlink" title="静态页面映射"></a>静态页面映射</h2><p>我们直接把静态页面放在static的目录下，直接可以在路径直接访问</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210814182837595.png" alt="image-20210814182837595"></p>
<h1 id="Springboot整合springmvc"><a href="#Springboot整合springmvc" class="headerlink" title="Springboot整合springmvc"></a>Springboot整合springmvc</h1><h2 id="自动装配的组件"><a href="#自动装配的组件" class="headerlink" title="自动装配的组件"></a>自动装配的组件</h2><p>①:ContentNegotiatingViewResolver 和 BeanNameViewResolver 视图解析器 视图解析器的作用:根据方法的值找到对应的视图</p>
<p>②:Support for serving static resources, including support for WebJars 支持静态资源和webJars </p>
<p>③:Converter ,日期格式化器 Formatter</p>
<p>④:消息装换器: HttpMessageConverters</p>
<p>⑤:首页设置index.html </p>
<p>⑥:图标支持 Favicon</p>
<h2 id="拓展SpringBoot的mvc配置"><a href="#拓展SpringBoot的mvc配置" class="headerlink" title="拓展SpringBoot的mvc配置"></a>拓展SpringBoot的mvc配置</h2><p>​    自己写一个配置类 继承 WebMvcConfigurerAdapter 需要什么组件 就注册什么组件 </p>
<p><strong>如何往容器中添加一个拦截器</strong> </p>
<p><strong>往容器中增加一个过滤器</strong> </p>
<p><strong>往容器中增加一个</strong>servlet </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">@Configuration<br>public class MvcConfig implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addInterceptors(InterceptorRegistry registry) &#123;<br>        HandlerInterceptor handlerInterceptor = new HandlerInterceptor() &#123;<br>            @Override<br>            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>                System.out.println(&quot;myHandlerInterceptor...前置拦截器:...&quot;);<br>                return true;<br>            &#125;<br>        &#125;;<br>        registry.addInterceptor(handlerInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/index.html&quot;);<br>    &#125;<br><br><br>    @Bean<br>    public FilterRegistrationBean filterRegistrationBean()&#123;<br>        Filter filter = new Filter() &#123;<br>            @Override<br>            public void init(FilterConfig filterConfig) throws ServletException &#123;<br><br>            &#125;<br><br>            @Override<br>            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;<br>                System.out.println(&quot;myFilter 的 doFilter方法&quot;);<br>                filterChain.doFilter(servletRequest,servletResponse);<br>            &#125;<br><br>            @Override<br>            public void destroy() &#123;<br><br>            &#125;<br>        &#125;;<br><br>        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();<br>        filterRegistrationBean.setFilter(filter);<br>        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean;<br>    &#125;<br><br>    @Bean<br>    public ServletRegistrationBean myHttpServlet()&#123;<br><br>        HttpServlet httpServlet =  new HttpServlet() &#123;<br><br>            @Override<br>            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;<br>                System.out.println(&quot;myHttpServlet&quot;);<br>                super.doPost(req,resp);<br>            &#125;<br>        &#125;;<br>        ServletRegistrationBean  servletRegistration = new ServletRegistrationBean(httpServlet);<br>        servletRegistration.addUrlMappings(&quot;/hello1&quot;);<br><br>        return servletRegistration;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="接管springboot的mvc配置"><a href="#接管springboot的mvc配置" class="headerlink" title="接管springboot的mvc配置"></a>接管springboot的mvc配置</h2><p><strong>方式</strong>：</p>
<p>​    使用一个@EnableWebMvc来标识到配置类上,就会导致配置失效</p>
<p><strong>原理：</strong></p>
<p>​    @EnableWebMvc 为容器中导入了DelegatingWebMvcConfiguration的组件,是WebMvcConfigurationSupport的实现类，而WebMvcAutoConfiguration在WebMvcConfigurationSupport不存在时才会自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">		ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span></span><br></code></pre></td></tr></table></figure>



<h2 id="SpringBoot错误处理机制"><a href="#SpringBoot错误处理机制" class="headerlink" title="SpringBoot错误处理机制"></a>SpringBoot错误处理机制</h2><p>postman 请求 <a href="http://localhost:8080/hello3">http://localhost:8080/hello3</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-number">1629035261980</span>,<br>    <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-number">404</span>,<br>    <span class="hljs-attr">&quot;error&quot;</span>: <span class="hljs-string">&quot;Not Found&quot;</span>,<br>    <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/hello3&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>浏览器</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210815215334258.png" alt="image-20210815215334258"></p>
<h3 id="如何跳转到-error"><a href="#如何跳转到-error" class="headerlink" title="如何跳转到/error"></a>如何跳转到/error</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DispatchServlet</span>.</span></span>doDispatch 找不到 返回<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardHostValve</span>.</span></span>custom<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationDispatcher</span>.</span></span>doForward 转发 到 /error<br></code></pre></td></tr></table></figure>

<h3 id="自动配置的异常处理的一些bean"><a href="#自动配置的异常处理的一些bean" class="headerlink" title="自动配置的异常处理的一些bean"></a>自动配置的异常处理的一些bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DefaultErrorAttributes<br> 	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> DefaultErrorAttributes <span class="hljs-title">errorAttributes</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultErrorAttributes();<br>	&#125;<br><br>BasicErrorController:/error请求处理控制器<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> BasicErrorController <span class="hljs-title">basicErrorController</span><span class="hljs-params">(ErrorAttributes errorAttributes,</span></span><br><span class="hljs-function"><span class="hljs-params">			ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicErrorController(errorAttributes, <span class="hljs-keyword">this</span>.serverProperties.getError(),<br>				errorViewResolvers.orderedStream().collect(Collectors.toList()));<br>	&#125;<br><br>ErrorPageCustomizer:错误页面定制器<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> ErrorPageCustomizer <span class="hljs-title">errorPageCustomizer</span><span class="hljs-params">(DispatcherServletPath dispatcherServletPath)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ErrorPageCustomizer(<span class="hljs-keyword">this</span>.serverProperties, dispatcherServletPath);<br>	&#125;<br><br><br>DefaultErrorViewResolver<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnBean(DispatcherServlet.class)</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span><br>    <span class="hljs-function">DefaultErrorViewResolver <span class="hljs-title">conventionErrorViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultErrorViewResolver(<span class="hljs-keyword">this</span>.applicationContext, <span class="hljs-keyword">this</span>.resources);<br>    &#125;<br>   <br>注入默认错误页面 defaultErrorView<br>	<span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>	<span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span><br>	<span class="hljs-meta">@Conditional(ErrorTemplateMissingCondition.class)</span><br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitelabelErrorViewConfiguration</span> </span>&#123;<br><br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StaticView defaultErrorView = <span class="hljs-keyword">new</span> StaticView();<br><br>		<span class="hljs-meta">@Bean(name = &quot;error&quot;)</span><br>		<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;error&quot;)</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">defaultErrorView</span><span class="hljs-params">()</span> </span>&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultErrorView;<br>		&#125;<br><br>		<span class="hljs-comment">// If the user adds @EnableWebMvc then the bean name view resolver from</span><br>		<span class="hljs-comment">// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.</span><br>		<span class="hljs-meta">@Bean</span><br>		<span class="hljs-meta">@ConditionalOnMissingBean</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameViewResolver <span class="hljs-title">beanNameViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>			BeanNameViewResolver resolver = <span class="hljs-keyword">new</span> BeanNameViewResolver();<br>			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">10</span>);<br>			<span class="hljs-keyword">return</span> resolver;<br>		&#125;<br><br>	&#125;<br></code></pre></td></tr></table></figure>

<p>处理/error请求的过程，以浏览器请求为例</p>
<ol>
<li><p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p>
<ol>
<li>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter<ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml <strong>（基础错误控制器）</strong> <ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.AbstractErrorController#resolveErrorView 遍历errorViewResolver 解析错误视图<ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver#resolveErrorView //查找error/“ + viewName视图是否存在，如果没有对应的解析精确匹配的状态码 使用模糊匹配比如4XX 5XX</li>
</ol>
</li>
<li>return (modelAndView != null) ? modelAndView : new ModelAndView(“error”, model);找不到对应解析器，则查找 error 对应的model</li>
</ol>
</li>
</ol>
</li>
<li>mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 解析error视图View </li>
</ol>
</li>
</ol>
<h2 id="定制错误异常信息"><a href="#定制错误异常信息" class="headerlink" title="定制错误异常信息"></a>定制错误异常信息</h2><p><img src="/images/SpringBoot02-webmvc/image-20210816095205231.png" alt="image-20210816095205231"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcepctionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BasicResponse <span class="hljs-title">handlerException</span><span class="hljs-params">(Exception e)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BasicResponse.failed();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicResponse</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> T info;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer SUCCESS_CODE = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SUCCESS_MSG = <span class="hljs-string">&quot;请求成功&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAIL_CODE = <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FAIL_MSG = <span class="hljs-string">&quot;服务器报错&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(SUCCESS_CODE,SUCCESS_MSG);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">success</span><span class="hljs-params">(String successMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(SUCCESS_CODE, successMsg);<br>    &#125;<br><br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, FAIL_MSG);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(String failedMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, failedMsg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(String failedMsg,T object)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, failedMsg,object);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(Integer code,String failedMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(code, failedMsg);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BasicResponse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BasicResponse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg, T info)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(code, msg);<br>        <span class="hljs-keyword">this</span>.info = info;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>web</tag>
        <tag>webmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot03-自动配置</title>
    <url>/2021/08/17/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h1><h2 id="Spring注解方式整合redis"><a href="#Spring注解方式整合redis" class="headerlink" title="Spring注解方式整合redis"></a>Spring注解方式整合redis</h2><p>redis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">redis.hostname</span>=<span class="hljs-string">127.0.0.1</span><br><br><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><br><br><span class="hljs-meta">redis.database</span>=<span class="hljs-string">0</span><br><br><span class="hljs-meta">redis.pool.maxActive</span>=<span class="hljs-string">600</span><br><br><span class="hljs-meta">redis.pool.maxIdle</span>=<span class="hljs-string">300</span><br><br><span class="hljs-meta">redis.pool.maxWait</span>=<span class="hljs-string">3000</span><br><br><span class="hljs-meta">redis.pool.testOnBorrow</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:redis.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.hostname&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String hostname;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.database&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> database;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxActive&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxActive;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxIdle&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxIdle;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxWait&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxWait;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.testOnBorrow&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> testOnBorrow;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPoolConfig <span class="hljs-title">jedisPoolConfig</span><span class="hljs-params">()</span></span>&#123;<br>        JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        poolConfig.setMaxTotal(maxActive);<br>        poolConfig.setMaxIdle(maxIdle);<br>        poolConfig.setMaxWaitMillis(maxWait);<br>        poolConfig.setTestOnBorrow(testOnBorrow);<br>        <span class="hljs-keyword">return</span> poolConfig;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisConnectionFactory <span class="hljs-title">jedisConnectionFactory</span><span class="hljs-params">()</span></span>&#123;<br>        JedisConnectionFactory factory = <span class="hljs-keyword">new</span> JedisConnectionFactory();<br>        factory.setHostName(hostname);<br>        factory.setPort(port);<br>        factory.setPoolConfig(jedisPoolConfig());<br>        factory.setDatabase(database);<br>        <span class="hljs-keyword">return</span> factory;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br>        Jackson2JsonRedisSerializer jacksonSeial = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br><br>        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate();<br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setValueSerializer(jacksonSeial);<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setHashValueSerializer(jacksonSeial);<br>        redisTemplate.setEnableTransactionSupport(<span class="hljs-keyword">true</span>);<br>        redisTemplate.setConnectionFactory(jedisConnectionFactory());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.10.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.data&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-data-redis&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="SpringBoot自动装配整合redis"><a href="#SpringBoot自动装配整合redis" class="headerlink" title="SpringBoot自动装配整合redis"></a>SpringBoot自动装配整合redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        template.setDefaultSerializer(<span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class));<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="传统整合和springboot自动装配对比"><a href="#传统整合和springboot自动装配对比" class="headerlink" title="传统整合和springboot自动装配对比"></a>传统整合和springboot自动装配对比</h2><p><img src="/images/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/image-20210816124943642.png" alt="image-20210816124943642"></p>
<p>传统整合：</p>
<p>​    自己引入依赖</p>
<p>​    版本冲突</p>
<p>​    配置复杂</p>
<p>自动装配</p>
<p>​    起步依赖</p>
<p>​    自动配置</p>
<p>​    约定 &gt; 配置 &gt; 编码</p>
<h2 id="SpringBoot自动配置原理-1"><a href="#SpringBoot自动配置原理-1" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><h3 id="Condition"><a href="#Condition" class="headerlink" title="@Condition"></a>@Condition</h3><p>​    Condition 是在Spring 4.0 增加的条件判断功能，通过这个可以功能可以<strong>根据系统中已有组件实现动态选择性的创建 Bean 操作</strong>，从而达到自动配置的目的。</p>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>​    SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如何知道要创建RedisTemplate的？</p>
<p>SpringBoot引入spring-data-redis坐标后，RedisAutoConfiguration配置类起作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="模仿使用"><a href="#模仿使用" class="headerlink" title="模仿使用"></a>模仿使用</h4><p>​    <strong>判断是否存在哪些类而注入当前类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、定义一个Condtion实现类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;<br>        Map&lt;String, Object&gt; map =<br>                annotatedTypeMetadata.getAnnotationAttributes(MyConditionOnClass.class.getName());<br>        String[] className = (String[]) map.get(<span class="hljs-string">&quot;value&quot;</span>);<br>        System.out.println(className);<br>        <span class="hljs-keyword">for</span> (String s : className) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; aClass = Class.forName(s);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-number">2</span>、声明一个注解，用来接收要判断是否存在的类<br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Conditional(value = MyCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyConditionOnClass &#123;<br>    String [] value();<br>&#125;<br><br><span class="hljs-number">3</span>、<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@MyConditionOnClass(&quot;com.study.springboot.Springboot02AutoconfigApplication&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小帅&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="自定义条件："><a href="#自定义条件：" class="headerlink" title="自定义条件："></a>自定义条件：</h5><p>​    第一步 定义条件类：</p>
<p>​        自定义类实现Condition接口，重写 matches 方法，在 matches 方法中进行逻辑判断，返回boolean值 。 matches 方法两个参数：</p>
<p>​            context：上下文对象，可以获取属性值，获取类加载器，获取BeanFactory等。</p>
<p>​            metadata：元数据对象，用于获取注解属性。</p>
<p>​    第二步伐 充当判断条件： 在初始化Bean时，使用 @Conditional(条件类.class)注解</p>
<h5 id="SpringBoot-提供的常用条件注解："><a href="#SpringBoot-提供的常用条件注解：" class="headerlink" title="SpringBoot 提供的常用条件注解："></a>SpringBoot 提供的常用条件注解：</h5><p>​        <strong>ConditionalOnProperty</strong>：判断配置文件中是否有对应属性和值才初始化Bean</p>
<p>​        <strong>ConditionalOnClass</strong>：判断环境中是否有对应字节码文件才初始化Bean</p>
<p>​        <strong>ConditionalOnMissingBean</strong>：判断环境中没有对应Bean才初始化Bean</p>
<h2 id="Enable"><a href="#Enable" class="headerlink" title="@Enable*"></a>@Enable*</h2><p>​    SpringBoot中提供了很多Enable开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载</p>
<h2 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h2><p>​    @Enable底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法：</p>
<ol>
<li>直接注入类</li>
<li>导入配置类（最先注入）</li>
<li>导入 ImportSelector 实现类。一般用于加载配置文件中的类（返回new String[] 可以返回配置文件的key）</li>
<li>导入 ImportBeanDefinitionRegistrar 实现类（最后注入）。</li>
</ol>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><ol>
<li>@EnableAutoConfiguration 注解内部使用 @Import(AutoConfigurationImportSelector.class)来加载配置类。</li>
<li>配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化Bean</li>
<li>并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean</li>
</ol>
<p>在本版本中（2.5.3）AutoConfigurationImportSelector实际起作用的是process()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;<br>       Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector,<br>                    () -&gt; String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>,<br>                                        AutoConfigurationImportSelector.class.getSimpleName(),<br>                                        deferredImportSelector.getClass().getName()));<br>       <span class="hljs-comment">//去mata-info/spring.factories文件中 查询org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的值</span><br>       AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)<br>           .getAutoConfigurationEntry(annotationMetadata);<br>       <span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>       <span class="hljs-comment">//去除重复的配置类，若我们自己写的starter 可能存主重复的</span><br>       <span class="hljs-keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;<br>           <span class="hljs-keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);<br>       &#125;<br>   &#125;<br><br><br><br></code></pre></td></tr></table></figure>

<p>SpringFactoriesLoader:去spring.factories 中去查询EnableAutoConfirution类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>	ClassLoader classLoaderToUse = classLoader;<br>	<span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-keyword">null</span>) &#123;<br>		classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>	&#125;<br>	String factoryTypeName = factoryType.getName();<br>	<span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终筛选出需要自动配置的类</p>
<p><img src="/images/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/image-20210817001324502.png" alt="image-20210817001324502"></p>
<h3 id="RedisAutoConfiguration"><a href="#RedisAutoConfiguration" class="headerlink" title="RedisAutoConfiguration"></a>RedisAutoConfiguration</h3><p>​    导入了三个组件 </p>
<p>​        RedisTemplate </p>
<p>​        StringRedisTemplate </p>
<p>​        JedisConnectionConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    SpringBoot自动配置原理：简单来说就是通过</p>
<p>​    @SpringBootApplication -&gt; </p>
<p>​        @EnableAutoConfiguration -&gt;</p>
<p>​            @Import(AutoConfigurationImportSelector.class)</p>
<p>​                    导入项目所有 META-INF/spring.factories 中所有org.springframework.boot.autoconfigure.EnableAutoConfiguration的值，再通过@condition、import，@ConfigurationProperties @EnableConfigurationProperties等系列注解达到根据环境自动注入配置的目的。</p>
<p>​    <strong>具体例子可见SpringBoot04篇章</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot04-自定义starter</title>
    <url>/2021/08/18/SpringBoot04-%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    <content><![CDATA[<h1 id="自定义SpringBoot-starter"><a href="#自定义SpringBoot-starter" class="headerlink" title="自定义SpringBoot-starter"></a>自定义SpringBoot-starter</h1><h2 id="套路（模板来源mybatis-spring-boot-starter）"><a href="#套路（模板来源mybatis-spring-boot-starter）" class="headerlink" title="套路（模板来源mybatis-spring-boot-starter）"></a>套路（模板来源mybatis-spring-boot-starter）</h2><p>​    1、创建一个xxx-spring-boot-autoconfigure项目:声明配置类xxxAutoConfiguration并且加入到Springboot的EnableAutoConfiguration的扫描范围中</p>
<p>​    2、创建一个xxx-spring-boot-starter项目:啥事也不干，只在pom中引入xxx-spring-boot-autoconfigure的坐标</p>
<p>​    3、在第三方项目中，直接引入starter，即可自动配置，即xxxAutoConfiguration起作用</p>
<h2 id="自定义redis-spring-boot-starter"><a href="#自定义redis-spring-boot-starter" class="headerlink" title="自定义redis-spring-boot-starter"></a>自定义redis-spring-boot-starter</h2><h3 id="redis-spring-boot-autoconfigure"><a href="#redis-spring-boot-autoconfigure" class="headerlink" title="redis-spring-boot-autoconfigure"></a>redis-spring-boot-autoconfigure</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 依赖不想上传递 可以利用此配置 来根据引入的组件选择性注入（如springboot内置tomcat） --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 只在编译阶段起作用 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 是自定义配置在 application.properties 编辑时有提示 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>定义自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String localHost = <span class="hljs-string">&quot;localhost&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> Integer port = <span class="hljs-number">6379</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLocalHost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> localHost;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalHost</span><span class="hljs-params">(String localHost)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.localHost = localHost;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(Integer port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(Jedis.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(value = RedisProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(Jedis.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">jedis</span><span class="hljs-params">(RedisProperties redisProperties)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jedis(redisProperties.getLocalHost(),redisProperties.getPort());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="redis-spring-boot-starter"><a href="#redis-spring-boot-starter" class="headerlink" title="redis-spring-boot-starter"></a>redis-spring-boot-starter</h3><p>只做坐标和依赖引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="springboot-03-use-my-starter"><a href="#springboot-03-use-my-starter" class="headerlink" title="springboot-03-use-my-starter"></a>springboot-03-use-my-starter</h3><p>引入redis-spring-boot-starter 即自动配置注入了jedis组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot03UseMyStarterApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext ioc = SpringApplication.run(Springboot03UseMyStarterApplication.class, args);<br>        Jedis redis = ioc.getBean(Jedis.class);<br>        redis.set(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>        System.out.println(redis.get(<span class="hljs-string">&quot;abc&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>starter配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot05-监听与监控</title>
    <url>/2021/08/21/SpringBoot05-%E7%9B%91%E5%90%AC%E4%B8%8E%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="SpringBoot-监听机制"><a href="#SpringBoot-监听机制" class="headerlink" title="SpringBoot-监听机制"></a>SpringBoot-监听机制</h1><h2 id="Java-监听机制"><a href="#Java-监听机制" class="headerlink" title="Java 监听机制"></a>Java 监听机制</h2><p>SpringBoot 的监听机制，其实是对Java提供的事件监听机制的封装。</p>
<p>​    Java中的事件监听机制定义了以下几个角色：</p>
<p>​        ① 事件：Event，继承 java.util.EventObject 类的对象</p>
<p>​        ② 事件源：Source ，任意对象Object</p>
<p>​        ③ 监听器：Listener，实现 java.util.EventListener 接口 的对象</p>
<p>​    SpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>​    ApplicationContextInitializer：SpringBoot 初始化时触发</p>
<p>​    SpringApplicationRunListener：SpringBoot整个生命周期</p>
<p>​    CommandLineRunner（无需注册）：SpringBoot启动后触发</p>
<p>​    ApplicationRunner（无需注册）：SpringBoot启动后触发</p>
<p>定义各种监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner .. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyCommandLineRunner ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyApplicationContextInitializer ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringApplicationRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SpringApplicationRunListener</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">starting</span><span class="hljs-params">(ConfigurableBootstrapContext bootstrapContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...starting&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentPrepared</span><span class="hljs-params">(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...environmentPrepared&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...contextPrepared&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoaded</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...contextLoaded&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">started</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...started&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">running</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...running&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySpringApplicationRunListener</span><span class="hljs-params">(SpringApplication application, String[] args)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>META-INF/spring.factories：注册SpringApplicationRunListener和ApplicationContextInitializer</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="hljs-string">\</span><br><span class="hljs-attr">com.study.springboot01simple.listenerr.MySpringApplicationRunListener</span><br><span class="hljs-meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">\</span><br><span class="hljs-attr">com.study.springboot01simple.listenerr.MyApplicationContextInitializer</span><br></code></pre></td></tr></table></figure>

<p>启动过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">MySpringApplicationRunListener ...starting<br>MySpringApplicationRunListener ...environmentPrepared<br><br>  .   ____          _            __ _ _<br> /\\ / ___<span class="hljs-string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="hljs-string">( ( )\___ | &#x27;</span>_ | <span class="hljs-string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \<br> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  <span class="hljs-string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="hljs-string"> =========|_|==============|___/=/_/_/_/</span><br><span class="hljs-string"> :: Spring Boot ::                (v2.5.3)</span><br><span class="hljs-string"></span><br><span class="hljs-string">MyApplicationContextInitializer ...</span><br><span class="hljs-string">MySpringApplicationRunListener ...contextPrepared</span><br><span class="hljs-string">2021-08-20 22:49:22.105  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : Starting Springboot01SimpleApplication using Java 1.8.0_171 on LAPTOP-87U6TGC3 with PID 18552 (D:\git\code\study\springboot-itheima-2021\springboot-01-simple\target\classes started by 81566 in D:\git\code\study\springboot-itheima-2021)</span><br><span class="hljs-string">2021-08-20 22:49:22.117  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : No active profile set, falling back to default profiles: default</span><br><span class="hljs-string">MySpringApplicationRunListener ...contextLoaded</span><br><span class="hljs-string">2021-08-20 22:49:25.313  INFO 18552 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="hljs-string">2021-08-20 22:49:25.336  INFO 18552 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="hljs-string">2021-08-20 22:49:25.336  INFO 18552 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50]</span><br><span class="hljs-string">2021-08-20 22:49:25.578  INFO 18552 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="hljs-string">2021-08-20 22:49:25.578  INFO 18552 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3255 ms</span><br><span class="hljs-string">2021-08-20 22:49:26.463  INFO 18552 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">2021-08-20 22:49:26.494  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : Started Springboot01SimpleApplication in 5.848 seconds (JVM running for 8.709)</span><br><span class="hljs-string">MySpringApplicationRunListener ...started</span><br><span class="hljs-string">MyApplicationRunner .. </span><br><span class="hljs-string">MyCommandLineRunner ...</span><br><span class="hljs-string">MySpringApplicationRunListener ...running</span><br><span class="hljs-string">com.study.springboot01simple.Springboot01SimpleApplication</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<h1 id="SpringBoot监控-actuator"><a href="#SpringBoot监控-actuator" class="headerlink" title="SpringBoot监控-actuator"></a>SpringBoot监控-actuator</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="①-导入依赖坐标"><a href="#①-导入依赖坐标" class="headerlink" title="① 导入依赖坐标"></a>① 导入依赖坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="②application-properties"><a href="#②application-properties" class="headerlink" title="②application.properties"></a>②application.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#开放健康信息检测</span><br><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><br><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br><span class="hljs-comment">#配置Spring Boot Admin 服务端</span><br><span class="hljs-meta">spring.boot.admin.client.url</span>=<span class="hljs-string">http://localhost:9000</span><br><span class="hljs-meta">spring.boot.admin.client.instance.name</span>=<span class="hljs-string">client-01</span><br><span class="hljs-meta">server.address</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">info.username</span>=<span class="hljs-string">小帅哥</span><br><span class="hljs-meta">info.age</span> = <span class="hljs-string">24</span><br><span class="hljs-meta">server.port</span>=<span class="hljs-string">9001</span><br></code></pre></td></tr></table></figure>

<h3 id="③-访问http-localhost-8080-acruator"><a href="#③-访问http-localhost-8080-acruator" class="headerlink" title="③ 访问http://localhost:8080/acruator"></a>③ 访问<a href="http://localhost:8080/acruator">http://localhost:8080/acruator</a></h3><p>/beans     描述应用程序上下文里全部的Bean，以及它们的关系</p>
<p>/env     获取全部环境属性</p>
<p>/env/{name}     根据名称获取特定的环境属性值</p>
<p>/health     报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</p>
<p>/info     获取应用程序的定制信息，这些信息由info打头的属性提供</p>
<p>/mappings     描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</p>
<p>/metrics     报告各种应用程序度量信息，比如内存用量和HTTP请求计数</p>
<p>/metrics/{name}     报告指定名称的应用程序度量值</p>
<p>/trace     提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</p>
<h3 id="④利用spring-boot-admin展示客户端监控信息"><a href="#④利用spring-boot-admin展示客户端监控信息" class="headerlink" title="④利用spring boot admin展示客户端监控信息"></a>④利用spring boot admin展示客户端监控信息</h3><p>​    Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>​    Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。 </p>
<p>​    应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>​    Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息。</p>
<p>admin-server： </p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<p>③ 在引导类上启用监控功能**@EnableAdminServer**</p>
<p>admin-client： </p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<p>③ 配置相关信息：server地址等</p>
<h3 id="⑤-启动server和client服务，访问server"><a href="#⑤-启动server和client服务，访问server" class="headerlink" title="⑤ 启动server和client服务，访问server"></a>⑤ 启动server和client服务，访问server</h3><p><a href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<p><img src="/images/SpringBoot05-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/image-20210822172511981.png" alt="image-20210822172511981"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>监听与监控</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot06-启动原理</title>
    <url>/2021/08/22/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="SpringBoot-启动原理"><a href="#SpringBoot-启动原理" class="headerlink" title="SpringBoot-启动原理"></a>SpringBoot-启动原理</h1><p>Spring启动时做了哪些事</p>
<img src="/images/SpringBoot06-启动原理/SpringBoot启动流程.png" alt="SpringBoot启动流程" style="zoom:200%;">

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> SpringApplication(primarySources)).run(args);<br></code></pre></td></tr></table></figure>

<p>可以看出SpringBoot启动的过程可以分成2步</p>
<p>1、new SpringApplication()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>   <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>   Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>   <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<br>   <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>   <span class="hljs-keyword">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();<br>   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>   <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>记录springboot启动类</li>
<li>判断SpringBoot启动环境是否web</li>
<li>从META-INF/spring.factories 获取应用BootstrapRegistryInitializer初始化器</li>
<li>从META-INF/spring.factories 获取应用上下文ApplicationContextInitializer初始化器</li>
<li>从META-INF/spring.factories 获取应用监听器</li>
<li>获取springboot启动类main方法所在类</li>
</ol>
<p>2、SpringApplication.run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    <span class="hljs-comment">//计时器</span><br>   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>   stopWatch.start();<br>   DefaultBootstrapContext bootstrapContext = createBootstrapContext();<br>   <span class="hljs-comment">//声明容器</span><br>   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>   configureHeadlessProperty();<br>   <span class="hljs-comment">//获取所有SpringApplicationRunListener，用于监听spiringboot生命周期 </span><br>   SpringApplicationRunListeners listeners = getRunListeners(args);<br>    <span class="hljs-comment">//启动-发布启动事件</span><br>   listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br>   <span class="hljs-keyword">try</span> &#123;<br>      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>      <span class="hljs-comment">//准备容器环境-发布环境准备事件</span><br>      ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>      configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//打印springboot的图标</span><br>      Banner printedBanner = printBanner(environment);<br>      <span class="hljs-comment">//创建容器 根据webApplicationType 来创建容器 通过反射创建</span><br>      context = createApplicationContext();<br>      context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br>      <span class="hljs-comment">//准备环境</span><br>      <span class="hljs-comment">//1：把环境设置到容器中 </span><br>      <span class="hljs-comment">//2: 循环调用AppplicationInitnazlier 进行容器初始化工作 </span><br>      <span class="hljs-comment">//3:发布容器上下文准备完成事件 </span><br>      <span class="hljs-comment">//4:注册关于springboot特性的相关单例Bean </span><br>      <span class="hljs-comment">//5:发布容器上下文加载完毕事件</span><br>      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      refreshContext(context);<br>      afterRefresh(context, applicationArguments);<br>      stopWatch.stop();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>      &#125;<br>      listeners.started(context);<br>      <span class="hljs-comment">//运行 ApplicationRunner 和CommandLineRunner</span><br>      callRunners(context, applicationArguments);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, listeners);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>   &#125;<br><br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//发布容器启动事件</span><br>      listeners.running(context);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, <span class="hljs-keyword">null</span>);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>   &#125;<br>   <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="SpringBoot启动的2种方式"><a href="#SpringBoot启动的2种方式" class="headerlink" title="SpringBoot启动的2种方式"></a>SpringBoot启动的2种方式</h1><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>​    本质：SpringBoot启动带动内置tomcat启动</p>
<p>​    简述：SpringApplication.run </p>
<p>​                -&gt;新建ioc</p>
<p>​                     -&gt; 容器刷新</p>
<p>​                         -&gt; onrefresh方法</p>
<p>​                            -&gt;ServletWebServerApplicationContext</p>
<p>​                                ServletWebServerFactory factory = getWebServerFactory();</p>
<p>​                                factory.getWebServer(getSelfInitializer());</p>
<h2 id="jar启动流程"><a href="#jar启动流程" class="headerlink" title="jar启动流程"></a>jar启动流程</h2><p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE-1629645466779.svg" alt="springboot启动流程图"></p>
<h2 id="war包"><a href="#war包" class="headerlink" title="war包"></a>war包</h2><p>​    本质：tomcat启动带动SpringBoot启动（Servlet3.0特性 tomcat启动会创建）</p>
<blockquote>
<p>8.2.4 Shared libraries / runtimes pluggability<br>    The ServletContainerInitializer class is looked up via the jar services API. For each application, an instance of the ServletContainerInitializer is created by the container at application startup time. The framework providing an implementation of the ServletContainerInitializer MUST bundle in the META-INF/services directory of the jar file a file called javax.servlet.ServletContainerInitializer, as per the jar services API,that points to the implementation class of the ServletContainerInitializer. In addition to the ServletContainerInitializer we also have an annotation -HandlesTypes. The HandlesTypes annotation on the implementation of the ServletContainerInitializer is used to express interest in classes that may have annotations (type, method or field level annotations) specified in the value of the HandlesTypes or if it extends / implements one those classes anywhere in the class’ super types. The HandlesTypes annotation is applied irrespective of the setting of metadata-complete. </p>
<p><strong>1.1)web应用启动，会创建当前Web应用导入jar包中 的 ServletContainerInitializer类的实例</strong> </p>
<p><strong>1.2)ServletContainerInitializer 类必须放在jar包的 META-INF/services目录 下,文件名称为 javax.servlet.ServletContainerInitializer</strong> </p>
<p><strong>1.3)文件的内容指向ServletContainerInitializer实现类的全路径</strong></p>
<p><strong>1.4)使用@HandlesTypes 在我们应用启动的时候，加载我们感兴趣的类</strong></p>
<p><strong>1.5)spring-web 配置了tomcat启动时要创建的实例类</strong></p>
</blockquote>
<p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/image-20210822230438231.png"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br></code></pre></td></tr></table></figure>


</blockquote>
<p>​    简述：Tomcat启动-&gt;</p>
<p>​                    SpringServletContainerInitializer.onStartup </p>
<p>​                        -&gt;SpringBootServletInitializer.onStartup</p>
<p>​                            -&gt;WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext)</p>
<p>​                                 -&gt;run(application) 触发SpringBoot启动</p>
<h2 id="war启动流程"><a href="#war启动流程" class="headerlink" title="war启动流程"></a>war启动流程</h2><p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/springboot%E5%90%AF%E5%8A%A8War%E5%8C%85.svg" alt="springboot启动War包"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>启动原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>随心记</category>
      </categories>
      <tags>
        <tag>随心记</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试-junit5</title>
    <url>/2021/03/14/junit5/</url>
    <content><![CDATA[<h1 id="07、单元测试"><a href="#07、单元测试" class="headerlink" title="07、单元测试"></a>07、单元测试</h1><h1 id="1、JUnit5-的变化"><a href="#1、JUnit5-的变化" class="headerlink" title="1、JUnit5 的变化"></a>1、JUnit5 的变化</h1><p><strong>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</strong></p>
<p>作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<blockquote>
<p><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p>
</blockquote>
<p><strong>JUnit Platform</strong>: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p>
<p><strong>JUnit Jupiter</strong>: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。</p>
<p><strong>JUnit Vintage</strong>: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。</p>
<p><img src="images/junit5/afeae670-6be9-11e9-8b0d-d3a853e66b8e-1617453264093" alt="img"></p>
<p>注意：</p>
<p><strong>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test）</strong></p>
<p><strong>JUnit 5’s Vintage Engine Removed from</strong> <strong><code>spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><img src="images/junit5/image-1617453444332.png" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>现在版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boot05WebAdminApplicationTests</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以前：</p>
<p><strong>@SpringBootTest + @RunWith(SpringTest.class)</strong></p>
<p>SpringBoot整合Junit以后。</p>
<ul>
<li>编写测试方法：@Test标注（注意需要使用junit5版本的注解）</li>
<li>Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
<h1 id="2、JUnit5常用注解"><a href="#2、JUnit5常用注解" class="headerlink" title="2、JUnit5常用注解"></a>2、JUnit5常用注解</h1><p>JUnit5的注解与JUnit4的注解有所变化</p>
<p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></p>
<ul>
<li>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</li>
<li>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</li>
<li>**==@DisplayName== :**为测试类或者测试方法设置展示名称</li>
<li>**@BeforeEach :**表示在每个单元测试之前执行</li>
<li>**@==AfterEach== :**表示在每个单元测试之后执行</li>
<li>**@==BeforeAll== :**表示在所有单元测试之前执行</li>
<li>**@AfterAll :**表示在所有单元测试之后执行</li>
<li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li>
<li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>
<li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li>
<li>**@ExtendWith :**为测试类或测试方法提供扩展类引用</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Test</span>; <span class="hljs-comment">//注意这里使用的是jupiter的Test注解！！</span><br><br><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">TestDemo</span> &#123;<br><br>  <span class="hljs-variable">@Test</span><br>  <span class="hljs-variable">@DisplayName</span>(<span class="hljs-string">&quot;第一次测试&quot;</span>)<br>  public void firstTest() &#123;<br>      <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>



<h1 id="3、断言（assertions）"><a href="#3、断言（assertions）" class="headerlink" title="3、断言（assertions）"></a>3、断言（assertions）</h1><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。<strong>这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</strong>。JUnit 5 内置的断言可以分成如下几个类别：</p>
<p><strong>检查业务逻辑返回的数据是否合理。</strong></p>
<p><strong>所有的测试运行结束以后，会有一个详细的测试报告；</strong></p>
<h2 id="1、简单断言"><a href="#1、简单断言" class="headerlink" title="1、简单断言"></a>1、简单断言</h2><p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;simple assertion&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span> </span>&#123;<br>     assertEquals(<span class="hljs-number">3</span>, <span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;simple math&quot;</span>);<br>     assertNotEquals(<span class="hljs-number">3</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);<br><br>     assertNotSame(<span class="hljs-keyword">new</span> Object(), <span class="hljs-keyword">new</span> Object());<br>     Object obj = <span class="hljs-keyword">new</span> Object();<br>     assertSame(obj, obj);<br><br>     assertFalse(<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>);<br>     assertTrue(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>);<br><br>     assertNull(<span class="hljs-keyword">null</span>);<br>     assertNotNull(<span class="hljs-keyword">new</span> Object());<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2、数组断言"><a href="#2、数组断言" class="headerlink" title="2、数组断言"></a>2、数组断言</h2><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;array assertion&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">array</span><span class="hljs-params">()</span> </span>&#123;<br> assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3、组合断言"><a href="#3、组合断言" class="headerlink" title="3、组合断言"></a>3、组合断言</h2><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;assert all&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br> assertAll(<span class="hljs-string">&quot;Math&quot;</span>,<br>    () -&gt; assertEquals(<span class="hljs-number">2</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>),<br>    () -&gt; assertTrue(<span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br> );<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4、异常断言"><a href="#4、异常断言" class="headerlink" title="4、异常断言"></a>4、异常断言</h2><p>在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule<strong>注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式</strong>Assertions.assertThrows()** ,配合函数式编程就可以进行使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;异常测试&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionTest</span><span class="hljs-params">()</span> </span>&#123;<br>    ArithmeticException exception = Assertions.assertThrows(<br>           <span class="hljs-comment">//扔出断言异常</span><br>            ArithmeticException.class, () -&gt; System.out.println(<span class="hljs-number">1</span> % <span class="hljs-number">0</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5、超时断言"><a href="#5、超时断言" class="headerlink" title="5、超时断言"></a>5、超时断言</h2><p>Junit5还提供了<strong>Assertions.assertTimeout()</strong> 为测试方法设置了超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;超时测试&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timeoutTest</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//如果测试方法时间超过1s将会异常</span><br>    Assertions.assertTimeout(Duration.ofMillis(<span class="hljs-number">1000</span>), () -&gt; Thread.sleep(<span class="hljs-number">500</span>));<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6、快速失败"><a href="#6、快速失败" class="headerlink" title="6、快速失败"></a>6、快速失败</h2><p>通过 fail 方法直接使得测试失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;fail&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shouldFail</span><span class="hljs-params">()</span> </span>&#123;<br> fail(<span class="hljs-string">&quot;This should fail&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="4、前置条件（assumptions）"><a href="#4、前置条件（assumptions）" class="headerlink" title="4、前置条件（assumptions）"></a>4、前置条件（assumptions）</h1><p>JUnit 5 中的前置条件（<strong>assumptions【假设】</strong>）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DisplayName(&quot;前置条件&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssumptionsTest</span> </span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String environment = <span class="hljs-string">&quot;DEV&quot;</span>;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-meta">@DisplayName(&quot;simple&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleAssume</span><span class="hljs-params">()</span> </span>&#123;<br>    assumeTrue(Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;DEV&quot;</span>));<br>    assumeFalse(() -&gt; Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;PROD&quot;</span>));<br> &#125;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-meta">@DisplayName(&quot;assume then do&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assumeThenDo</span><span class="hljs-params">()</span> </span>&#123;<br>    assumingThat(<br>       Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;DEV&quot;</span>),<br>       () -&gt; System.out.println(<span class="hljs-string">&quot;In DEV&quot;</span>)<br>    );<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h1 id="5、嵌套测试"><a href="#5、嵌套测试" class="headerlink" title="5、嵌套测试"></a>5、嵌套测试</h1><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DisplayName(&quot;A stack&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestingAStackDemo</span> </span>&#123;<br><br>    Stack&lt;Object&gt; stack;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isInstantiatedWithNew</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Nested</span><br>    <span class="hljs-meta">@DisplayName(&quot;when new&quot;)</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhenNew</span> </span>&#123;<br><br>        <span class="hljs-meta">@BeforeEach</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createNewStack</span><span class="hljs-params">()</span> </span>&#123;<br>            stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;is empty&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>            assertTrue(stack.isEmpty());<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwsExceptionWhenPopped</span><span class="hljs-params">()</span> </span>&#123;<br>            assertThrows(EmptyStackException.class, stack::pop);<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwsExceptionWhenPeeked</span><span class="hljs-params">()</span> </span>&#123;<br>            assertThrows(EmptyStackException.class, stack::peek);<br>        &#125;<br><br>        <span class="hljs-meta">@Nested</span><br>        <span class="hljs-meta">@DisplayName(&quot;after pushing an element&quot;)</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterPushing</span> </span>&#123;<br><br>            String anElement = <span class="hljs-string">&quot;an element&quot;</span>;<br><br>            <span class="hljs-meta">@BeforeEach</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushAnElement</span><span class="hljs-params">()</span> </span>&#123;<br>                stack.push(anElement);<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;it is no longer empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>                assertFalse(stack.isEmpty());<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnElementWhenPopped</span><span class="hljs-params">()</span> </span>&#123;<br>                assertEquals(anElement, stack.pop());<br>                assertTrue(stack.isEmpty());<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnElementWhenPeeked</span><span class="hljs-params">()</span> </span>&#123;<br>                assertEquals(anElement, stack.peek());<br>                assertFalse(stack.isEmpty());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="6、参数化测试"><a href="#6、参数化测试" class="headerlink" title="6、参数化测试"></a>6、参数化测试</h1><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p>**<br>**</p>
<p><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</p>
<p><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</p>
<p><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</p>
<p><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</p>
<p><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<blockquote>
<p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现<strong>ArgumentsProvider</strong>接口，任何外部文件都可以作为它的入参。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class="hljs-meta">@DisplayName(&quot;参数化测试1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parameterizedTest1</span><span class="hljs-params">(String string)</span> </span>&#123;<br>    System.out.println(string);<br>    Assertions.assertTrue(StringUtils.isNotBlank(string));<br>&#125;<br><br><br><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@MethodSource(&quot;method&quot;)</span>    <span class="hljs-comment">//指定方法名</span><br><span class="hljs-meta">@DisplayName(&quot;方法来源参数&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithExplicitLocalMethodSource</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    System.out.println(name);<br>    Assertions.assertNotNull(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Stream.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="7、迁移指南"><a href="#7、迁移指南" class="headerlink" title="7、迁移指南"></a>7、迁移指南</h1><p>在进行迁移的时候需要注意如下的变化：</p>
<ul>
<li>注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。</li>
<li>把@Before 和@After 替换成@BeforeEach 和@AfterEach。</li>
<li>把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。</li>
<li>把@Ignore 替换成@Disabled。</li>
<li>把@Category 替换成@Tag。</li>
<li>把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。</li>
</ul>
<h1 id="8、参考来源："><a href="#8、参考来源：" class="headerlink" title="8、参考来源："></a>8、参考来源：</h1><p><a href="https://www.yuque.com/atguigu/springboot/ksndgx">https://www.yuque.com/atguigu/springboot/ksndgx</a></p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis整合Spring</title>
    <url>/2021/05/15/myBatis%20%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<ol>
<li>spring 集成myBatis</li>
<li>动态化SQL与脚本解析器</li>
</ol>
<h2 id="一、spring-集成myBatis"><a href="#一、spring-集成myBatis" class="headerlink" title="一、spring 集成myBatis"></a><strong>一、spring 集成myBatis</strong></h2><hr>
<h3 id="核心使用："><a href="#核心使用：" class="headerlink" title="核心使用："></a><strong>核心使用：</strong></h3><p>基础集成使用：</p>
<p>1、配置 SqlSessionFactoryBean</p>
<p>2、配置 MapperFactoryBean</p>
<p>3、获取mapper 对像执行业务方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dateSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dateSource&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.study.mapper.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>对像说明：</p>
<h3 id="FactoryBean："><a href="#FactoryBean：" class="headerlink" title="FactoryBean："></a>FactoryBean：</h3><p>工厂Bean 用于 自定义生成Bean对像，当在ioc 中配置FactoryBean 的实例时，最终通过bean id 对应的是FactoryBean.getObject()实例，而非FactoryBean 实例本身</p>
<h3 id="SqlSessionFactoryBean："><a href="#SqlSessionFactoryBean：" class="headerlink" title="SqlSessionFactoryBean："></a>SqlSessionFactoryBean：</h3><p>生成SqlSessionFactory 实例，该为单例对像，作用于整个应用生命周期。常用属性如下：</p>
<ul>
<li>dataSource：数据源(必填)</li>
<li>configLocation：指定mybatis-config.xml 的内容，但其设置的<dataSource> <properties> <environments> 将会失效(选填)</environments></properties></dataSource></li>
<li>mapperLocations：指定mapper.xml 的路径，相当于mybatis-config.xml 中<mappers> 元素配置，(选填)</mappers></li>
</ul>
<h3 id="MapperFactoryBean："><a href="#MapperFactoryBean：" class="headerlink" title="MapperFactoryBean："></a>MapperFactoryBean：</h3><p>生成对应的Mapper对像，通常为单例，作用于整个应用生命周期。常用属性如下：</p>
<ul>
<li>mapperInterface：mapper 接口      (必填)</li>
<li>sqlSessionFactory：会话工厂实例 引用 (必填)</li>
</ul>
<h3 id="关于Mapper-单例情况下是否存在线程安全的问题"><a href="#关于Mapper-单例情况下是否存在线程安全的问题" class="headerlink" title="关于Mapper 单例情况下是否存在线程安全的问题?"></a>关于Mapper 单例情况下是否存在线程安全的问题?</h3><p>在原生的myBatis 使用中mapper 对像的生命期是与SqlSession同步的，不会存在线程安全问题，现在单例的mapper 是如何解决线程安全的问题的呢？</p>
<h3 id="核心流程解析："><a href="#核心流程解析：" class="headerlink" title="核心流程解析："></a><strong>核心流程解析：</strong></h3><p>SQL session 集成结构：</p>
<p>![image1](/images/myBatis 第三方框架集成/image1.png)</p>
<h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><h5 id="创建会话模板-SqlSessionTemplate"><a href="#创建会话模板-SqlSessionTemplate" class="headerlink" title="创建会话模板 SqlSessionTemplate"></a>创建会话模板 SqlSessionTemplate</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.mybatis.spring.mapper.MapperFactoryBean#MapperFactoryBean()<br>&gt; org.mybatis.spring.support.SqlSessionDaoSupport#setSqlSessionFactory<br>&gt; org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate()<br>&gt;org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor <br>    <span class="hljs-comment">//sqlSessionProxy被SqlSessionInterceptor代理拦截</span><br></code></pre></td></tr></table></figure>

<h5 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.mybatis.spring.mapper.MapperFactoryBean#getObject<br>org.mybatis.spring.SqlSessionTemplate#getMapper<br>org.apache.ibatis.session.Configuration#getMapper<br>org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.binding.MapperProxy&lt;T&gt;) //最终获取到的userMapper是已经代理过的<br></code></pre></td></tr></table></figure>



<h5 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">com.tuling.mybatis.dao.UserMapper#selectByid<br>org.apache.ibatis.binding.MapperProxy#invoke<br>org.mybatis.spring.SqlSessionTemplate#selectOne(java.lang.String)<br>org.mybatis.spring.SqlSessionTemplate#sqlSessionProxy#selectOne(java.lang.String)<br>org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor#invoke<br>   <span class="hljs-comment">//重新获取sqlsession</span><br>     SqlSession sqlSession = getSqlSession(<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory,<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.executorType,<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator);<br>org.mybatis.spring.SqlSessionUtils#getSqlSession()<br>org.apache.ibatis.session.SqlSessionFactory#openSession()<br>org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne()<br></code></pre></td></tr></table></figure>

<p>每次查询都会创建一个新的 SqlSession 会话，一级缓存还会生效吗？</p>
<p>通过前几次课我们了解到 一级缓存的条件是必须相同的会话.</p>
<p><strong>所以缓存通过和spring 集成之后就不会生效了。除非使用spring 事物 这时就不会在重新创建会话。</strong></p>
<h3 id="事务使用"><a href="#事务使用" class="headerlink" title="事务使用 :"></a><strong>事务使用 :</strong></h3><p>spring 事物没有针对myBatis的配置，都是一些常规事物配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加事物配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--事物注解配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>添加事物注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        User user = userMapper.selectById(id);<br>        User user1 = userMapper.selectById(id);<br><br>        System.out.println(user);<br>        System.out.println(user1);<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<p>执行测试发现 当调用selectById方法时两次查询不在重复创建 sqlSession。而是共用一个直到selectById方法结束。</p>
<h5 id="事物与SqlSession-集成原理："><a href="#事物与SqlSession-集成原理：" class="headerlink" title="事物与SqlSession 集成原理："></a>事物与SqlSession 集成原理：</h5><p>其原理前面讲查询流程时有所涉及。每次执行SQL操作前都会通过 getSqlSession 来获取会话。其主要逻辑是</p>
<p>​     如果当前线程存在事物，并且存在相关会话，就从ThreadLocal中取出 。如果没就从创建一个 SqlSession 并存储到ThreadLocal 当中，共下次查询使用。</p>
<p>相关源码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.mybatis.spring.SqlSessionUtils#getSqlSession()<br>org.springframework.transaction.support.TransactionSynchronizationManager#getResource<br>org.mybatis.spring.SqlSessionUtils#sessionHolder<br>org.apache.ibatis.session.SqlSessionFactory#openSession()<br>org.mybatis.spring.SqlSessionUtils#registerSessionHolder<br>org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive<br>org.springframework.transaction.support.TransactionSynchronizationManager#bindResource<br></code></pre></td></tr></table></figure>

<h3 id="简化Mapper-配置"><a href="#简化Mapper-配置" class="headerlink" title="简化Mapper 配置"></a><strong>简化Mapper 配置</strong></h3><p>如果每个mapper 接口都配置<em>MapperFactoryBean</em>相当麻烦 可以通过 如下配置进行自动扫描</p>
<p>&lt;mybatis:scan base-package=”com.tuling.mybatis.dao”/&gt;</p>
<p>其与 spring bean 注解扫描机制类似，所以得加上注解扫描开关的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程02Synchronized</title>
    <url>/2021/10/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&amp;AQS/</url>
    <content><![CDATA[<h1 id="并发编程之synchronized-amp-Lock-amp-AQS详解"><a href="#并发编程之synchronized-amp-Lock-amp-AQS详解" class="headerlink" title="并发编程之synchronized&amp;Lock&amp;AQS详解"></a>并发编程之synchronized&amp;Lock&amp;AQS详解</h1><h2 id="为什么加锁"><a href="#为什么加锁" class="headerlink" title="为什么加锁"></a>为什么加锁</h2><p><strong>加锁目的：</strong>序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(同步互斥访问)</p>
<p><strong>显示锁与隐示锁</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024180413679.png" alt="image-20211024180413679"></p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/%E6%8C%A8%E8%B8%A2%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84java%E9%94%81.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Unsafe工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeInstance</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="synchronized使用与原理"><a href="#synchronized使用与原理" class="headerlink" title="synchronized使用与原理"></a>synchronized使用与原理</h2><p><strong>使用方式</strong></p>
<p>1、类的静态方法，锁当前类对象</p>
<p>2、实例方法，锁当前实例对象</p>
<p>3、同步代码块，锁代码里的对象</p>
<p><strong>底层原理</strong>：</p>
<p>​    JVM内置锁通过synchronized使用，通过内部对象Monitor(监视器锁)实现，<strong>基于进入与退出Monitor对象实现方法与代码块同步</strong>，监视器锁的实现依赖底层操作系统的<strong>Mutex lock</strong>（互斥锁）实现，它是一个重量级锁性能较低。简单的说时基于JMM8大操作里的lock和unlock，MonitorEnter和MonitorExit</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><strong>每个对象都有一个自己的Monitor(监视器锁)</strong></p>
<p><strong>锁的定义</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024220009143.png" alt="image-20211024220009143"></p>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024215853709.png" alt="image-20211024215853709"></p>
<h3 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024222345420.png" alt="image-20211024222345420"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024231911266.png" alt="image-20211024231911266"></p>
<ol>
<li>对象头（哈希code、锁状态、当前持有线程、jvm年龄、偏向变量、MetaDate元数据指针）</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<h3 id="实例对象内存存储在哪？线程逃逸分析"><a href="#实例对象内存存储在哪？线程逃逸分析" class="headerlink" title="实例对象内存存储在哪？线程逃逸分析"></a>实例对象内存存储在哪？线程逃逸分析</h3><p>如果实例对象存储在堆时：实例对象内存存在堆区，实例引用存在栈上，实例的元数据class存在元空间中<br>如果存在逃逸分析，对象实例内存可能开辟在线程栈上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocTest</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进行两种测试</span><br><span class="hljs-comment">     * 关闭逃逸分析，同时调大堆空间，避免堆内GC的发生，如果有GC信息将会被打印出来</span><br><span class="hljs-comment">     * VM运行参数：-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 开启逃逸分析</span><br><span class="hljs-comment">     * VM运行参数：-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 执行main方法后</span><br><span class="hljs-comment">     * jps 查看进程</span><br><span class="hljs-comment">     * jmap -histo 进程ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-comment">//查看执行时间</span><br>        System.out.println(<span class="hljs-string">&quot;cost-time &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>            e1.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TulingStudent <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//Jit对编译时会对代码进行 逃逸分析</span><br>        <span class="hljs-comment">//并不是所有对象存放在堆区，有的一部分存在线程栈空间</span><br>        TulingStudent student = <span class="hljs-keyword">new</span> TulingStudent();<br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TulingStudent</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过jmap -histo pid 查看jvm内存实例情况</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024232528178.png" alt="image-20211024232528178"></p>
<h3 id="锁的优化与升级"><a href="#锁的优化与升级" class="headerlink" title="锁的优化与升级"></a>锁的优化与升级</h3><p>优化：粗化与消除</p>
<p>升级：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    StringBuffer stb = <span class="hljs-keyword">new</span> StringBuffer();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//jvm的优化，锁的粗化</span><br>        stb.append(<span class="hljs-string">&quot;1&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;2&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;3&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;4&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的消除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//jvm的优化，JVM不会对同步块进行加锁</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">new</span> Object()) &#123;<br>            <span class="hljs-comment">//伪代码：很多逻辑</span><br>            <span class="hljs-comment">//jvm是否会加锁？</span><br>            <span class="hljs-comment">//jvm会进行逃逸分析</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="JVM内置锁的优化升级过程"><a href="#JVM内置锁的优化升级过程" class="headerlink" title="JVM内置锁的优化升级过程"></a>JVM内置锁的优化升级过程</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024234942906.png" alt="image-20211024234942906"></p>
<p>自旋锁：<strong>线程间交替执行，本身竞争不激烈</strong>（自旋不会丢失CPU使用权，不同于阻塞）（JDK1.7后，有自适应自旋）</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B-1635176427187.png"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/JVM%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E5%8D%87%E7%BA%A7.jpg"></p>
<p>CHL同步队列与条件队列</p>
<p>公平锁与非公平锁</p>
<p>reentrantLock是独占锁</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210907225841711.png" alt="image-20210907225841711"></p>
<p>AQS节点的唤醒，唤醒的是同步队列的head指向的next节点。</p>
<p>Reentrantlock.lock 分析</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span> &amp;&amp;<br>        acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>        self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Semaphore的使用 acquire方法分析</p>
<p>park、unpark方法阻塞线程 </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 1.7 = 数组 + 单向链表<br>扩容时可能会产生死锁，多线程扩容时链表倒插可能产生闭环</p>
<p>ConcurrentHashMap 1.7 = Segment数组（继承ReentrantLock） + hashEntry数组 + 链表,从而实现分段锁，支持并发</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210927235446858.png" alt="image-20210927235446858"></p>
<p>HashMap 1.8 = 数组 + 单向链表。扩容时不会倒插，而是采用高低位插入，Node的hash 值&amp;（扩容后-1）最高位=1则扩容后下标=扩容前大小+原下标，否则=原下标</p>
<p>ConcurrentHashMap 1.8 = Node数组 +  链表，区别在于每次插入，都synchronize第一个节点，相同于锁一条链表，并且通过CAS的算法插入每个链表的第一个阶段，从而达到并发，锁的粒度较小，灵活</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210928000406955.png" alt="image-20210928000406955"></p>
<h1 id="线程池原理与解读"><a href="#线程池原理与解读" class="headerlink" title="线程池原理与解读"></a>线程池原理与解读</h1><p>线程池的优势：</p>
<p>1、重用存在的线程，减少线程创建，消亡的开销（开辟的空间处理，操作内核空间时间的消耗），提高性能</p>
<p>2、提高响应速度（直接取，无需等待)</p>
<p>3、提高对线程的管理，方便进行统一分配、调优和监控</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><h2 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h2><p>核心线程</p>
<p>阻塞队列</p>
<p>非核心线程</p>
<p>拒绝策略</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210928233525697.png" alt="image-20210928233525697"></p>
<h3 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h3><h3 id="线程池状态流转"><a href="#线程池状态流转" class="headerlink" title="线程池状态流转"></a>线程池状态流转</h3><h3 id="fork-join-分发线程池"><a href="#fork-join-分发线程池" class="headerlink" title="fork/join 分发线程池"></a>fork/join 分发线程池</h3><h3 id="定时任务-定时任务线程池"><a href="#定时任务-定时任务线程池" class="headerlink" title="定时任务/定时任务线程池"></a>定时任务/定时任务线程池</h3>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程03AQS&amp;ReentrantLock</title>
    <url>/2021/10/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&amp;ReentrantLock/</url>
    <content><![CDATA[<h1 id="同步框架AQS"><a href="#同步框架AQS" class="headerlink" title="同步框架AQS"></a>同步框架AQS</h1><h2 id="并发之父"><a href="#并发之父" class="headerlink" title="并发之父"></a>并发之父</h2><p><em>Doug Lea</em>：生平不识<em>Doug Lea</em>，学懂并发也枉然</p>
<h2 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h2><p>​    Java并发编程核心在于java.concurrent.util包而juc当中的大多数同步器 实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获 取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，AQS定 义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步 器。</p>
<p>AQS具备特性</p>
<ol>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>可中断</li>
</ol>
<p>  例如Java.concurrent.util当中同步器的实现如Lock,Latch,Barrier等，都是基 于AQS框架实现，一般通过定义内部类Sync继承AQS将同步器所有调用都映射到Sync对应的方法 AQS内部维护属性volatile int state (32位) state表示资源的可用状态 </p>
<p><strong>State三种访问方式</strong> </p>
<p>​    getState()、setState()、compareAndSetState() </p>
<p><strong>AQS定义两种资源共享方式</strong> </p>
<p>​    Exclusive-独占，只有一个线程能执行，如ReentrantLock </p>
<p>​    Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch </p>
<p><strong>AQS定义两种队列</strong> </p>
<p>​    同步等待队列 </p>
<p>​    条件等待队列 </p>
<p>​    不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器 实现时主要实现以下几种方法： </p>
<p>​    isHeldExclusively()：该线程是否正在独占资源。只有用到 condition才需要去实现它。 </p>
<p>​    tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 </p>
<p>​    tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 </p>
<p>​    tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败； 0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </p>
<p>​    tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<p><strong>同步等待队列</strong> </p>
<p>​    AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列，是FIFO先入先出线程等待队列，<strong>Java中的CLH队列是原CLH队列的一个变种,线程由原自旋机制改为阻塞机制。</strong> </p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231223938.png" alt="image-20211026231223938"></p>
<p><strong>条件等待队列</strong> </p>
<p>​    Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一 起等待某个条件（Condition）,只有当该条件具备时，这些等待线程才会被唤 醒，从而重新争夺锁</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231300145.png" alt="image-20211026231300145"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>​    <strong>如果Node在条件队列当中，Node必须是独占模式</strong></p>
<h3 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h3><p>详细结构解析查看：<a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/AbstractQueuedSynchronizer.png" alt="AbstractQueuedSynchronizer"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231827654.png" alt="image-20211026231827654"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指向同步等待队列的头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指向同步等待队列的尾节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同步资源状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给各自子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *默认实现，且不允许子类修改</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 已经在队列当中的Thread节点，准备阻塞等待获取锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环</span><br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//找到当前结点的前驱结点</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="hljs-comment">//如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。</span><br>                    setHead(node);<span class="hljs-comment">//获取同步状态成功，将当前结点设置为头结点。</span><br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 如果前驱节点不是Head，通过shouldParkAfterFailedAcquire判断是否应该阻塞</span><br><span class="hljs-comment">                 * 前驱节点信号量为-1，当前线程可以安全被parkAndCheckInterrupt用来阻塞线程</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                        parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 若前驱结点的状态是SIGNAL，意味着当前结点可以被安全地park</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 前驱节点状态如果被取消状态，将被移除出队列</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 当前驱节点waitStatus为 0 or PROPAGATE状态时</span><br><span class="hljs-comment">             * 将其设置为SIGNAL状态，然后当前结点才可以可以被安全地park</span><br><span class="hljs-comment">             */</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 将当前线程构建成Node类型</span><br>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        Node pred = tail;<br>        <span class="hljs-comment">// 2. 1当前尾节点是否为null？</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 2.2 将当前节点尾插入的方式</span><br>            node.prev = pred;<br>            <span class="hljs-comment">// 2.3 CAS将节点插入同步队列的尾部</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">AQS的静态内部类<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 标记节点未共享模式</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  标记节点为独占模式</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  后继节点的线程处于等待状态，而当前的节点如果释放了同步状态或者被取消，</span><br><span class="hljs-comment">         *  将会通知后继节点，使后继节点的线程得以运行。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  节点在等待队列中，节点的线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span><br><span class="hljs-comment">         *  该节点会从等待队列中转移到同步队列中，加入到同步状态的获取中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 表示下一次共享式同步状态获取将会被无条件地传播下去</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 标记当前节点的信号量状态 (1,0,-1,-2,-3)5种状态</span><br><span class="hljs-comment">         * 使用CAS更改状态，volatile保证线程可见性，高并发场景下，</span><br><span class="hljs-comment">         * 即被一个线程修改后，状态会立马让其他线程可见。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 前驱节点，当前节点加入到同步队列中被设置</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Node prev;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 后继节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Node next;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 节点同步状态的线程</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Thread thread;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 等待队列中的后继节点，如果当前节点是共享的，那么这个字段是一个SHARED常量，</span><br><span class="hljs-comment">         * 也就是说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段。</span><br><span class="hljs-comment">         */</span><br>        Node nextWaiter;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if node is waiting in shared mode.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回前驱节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>            Node p = prev;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> p;<br>        &#125;<br><br>        Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>        &#125;<br><br>        Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>            <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>            <span class="hljs-keyword">this</span>.thread = thread;<br>        &#125;<br><br>        Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>            <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>            <span class="hljs-keyword">this</span>.thread = thread;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="acquire的过程"><a href="#acquire的过程" class="headerlink" title="acquire的过程"></a>acquire的过程</h3><ol>
<li>tryAcquire尝试获取锁<ol>
<li>尝试失败，入队等待队列</li>
<li>入队后循环尝试获取锁<ol>
<li>判断该节前驱结点为头结点，tryacquire</li>
<li>判断是否要阻塞该线程<ol>
<li>判断是否要阻塞<ol>
<li>前驱结点是就绪状态，说明前置结点也只等待拿锁，则本节点可以阻塞 返回true</li>
<li>前驱结点状态&gt;0是取消，则递归移除前驱结点 返回false</li>
<li>否则设置该节点的前置结点为signal就绪状态 返回false</li>
</ol>
</li>
<li>根据第一点结果是否阻塞阻塞<ol>
<li>阻塞</li>
<li>不阻塞，从新回到循环  2.判断是否要阻塞该线程</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="release的过程"><a href="#release的过程" class="headerlink" title="release的过程"></a>release的过程</h3><ol>
<li>tryRelease<ol>
<li>释放成功 返回true<ol>
<li>如果头节点不为空且状态不=0<ol>
<li>将等待状态waitStatus设置为初始值0</li>
<li>后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到最前的一个处于正常阻塞状态的结点进行唤醒</li>
<li>唤醒查到的节点</li>
</ol>
</li>
</ol>
</li>
<li>失败，返回false</li>
</ol>
</li>
</ol>
<p>ReentrantLock的特点</p>
<p>1、是独占锁</p>
<p>2、同步等待队列的Node是通过魔术类UnSafe.park()/unPark（） 方法来实现阻塞和唤醒</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS&amp;ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程04-juc-Tools</title>
    <url>/2021/10/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04-juc-Tools/</url>
    <content><![CDATA[<h1 id="Juc-Tools"><a href="#Juc-Tools" class="headerlink" title="Juc-Tools"></a>Juc-Tools</h1><p>以下都是共享模式</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>​    public Semaphore(int permits) </p>
<p>​    public Semaphore(int permits, boolean fair) </p>
<p>permits 表示许可线程的数量 fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线 程 </p>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><pre><code> public void acquire() throws InterruptedException 
</code></pre>
<p>​    public void release() tryAcquire（long timeout, TimeUnit unit） </p>
<p>acquire() 表示阻塞并获取许可 release() 表示释放许可 </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>​    <strong>需求场景</strong>:资源访问，服务限流。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreSample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Task(semaphore,<span class="hljs-string">&quot;handsome+&quot;</span>+i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        Semaphore semaphore;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(Semaphore semaphore,String tname)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>            <span class="hljs-keyword">this</span>.setName(tname);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:aquire() at time:&quot;</span>+System.currentTimeMillis());<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:release() at time:&quot;</span>+System.currentTimeMillis());<br>                semaphore.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>有主次之分，注重对分支线程的结果在主线程汇总处理</p>
<p>例如多excel处理多个sheet，最后对每个sheet的处理结果汇总处理</p>
<h4 id="CountDownLatch是什么？"><a href="#CountDownLatch是什么？" class="headerlink" title="CountDownLatch是什么？"></a>CountDownLatch是什么？</h4><p>​    CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>​    CountDownLatch.countDown() </p>
<p>​    CountDownLatch.await();</p>
<h4 id="CountDownLatch应用场景例子"><a href="#CountDownLatch应用场景例子" class="headerlink" title="CountDownLatch应用场景例子"></a>CountDownLatch应用场景例子</h4><p>​    比如陪媳妇去看病。 医院里边排队的人很多，如果一个人的话，要先看大夫，看完大夫再去排队交钱取药。 现在我们是双核，可以同时做这两个事（多线程）。 </p>
<p>​    假设看大夫花3秒钟，排队交费取药花5秒钟。我们同时搞的话，5秒钟我们就能完成，然后 一起回家（回到主线程）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLaunchSample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SeeDoctorTask(countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> QueueTask(countDownLatch)).start();<br>        <span class="hljs-comment">//等待线程池中的2个任务执行完毕，否则一直</span><br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;over，回家 cost:&quot;</span>+(System.currentTimeMillis()-now));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QueueTask</span><span class="hljs-params">(CountDownLatch countDownLatch)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始在医院药房排队买药....&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;排队成功，可以开始缴费买药&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (countDownLatch != <span class="hljs-keyword">null</span>)<br>                countDownLatch.countDown();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeeDoctorTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeeDoctorTask</span><span class="hljs-params">(CountDownLatch countDownLatch)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始看医生&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            System.out.println(<span class="hljs-string">&quot;看医生结束，准备离开病房&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (countDownLatch != <span class="hljs-keyword">null</span>)<br>                countDownLatch.countDown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>​    栅栏屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程 到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线 程数量，每个线程调用await方法告CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrierTest</span><span class="hljs-params">(CyclicBarrier cyclicBarrier, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;<br>        <span class="hljs-keyword">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;index: &quot;</span> + index +  <span class="hljs-string">&quot;准备就绪&quot;</span>);<br>            cyclicBarrier.await();<br>            System.out.println(<span class="hljs-string">&quot;index: &quot;</span> + index +  <span class="hljs-string">&quot;开始干活&quot;</span>);<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;所有特工到达屏障，准备开始执行秘密任务&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CyclicBarrierTest(cyclicBarrier, i)).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br>index: <span class="hljs-number">1</span>准备就绪<br>index: <span class="hljs-number">2</span>准备就绪<br>index: <span class="hljs-number">0</span>准备就绪<br>index: <span class="hljs-number">5</span>准备就绪<br>index: <span class="hljs-number">6</span>准备就绪<br>index: <span class="hljs-number">4</span>准备就绪<br>index: <span class="hljs-number">3</span>准备就绪<br>index: <span class="hljs-number">7</span>准备就绪<br>index: <span class="hljs-number">8</span>准备就绪<br>index: <span class="hljs-number">9</span>准备就绪<br>所有特工到达屏障，准备开始执行秘密任务<br>index: <span class="hljs-number">9</span>开始干活<br>index: <span class="hljs-number">0</span>开始干活<br>index: <span class="hljs-number">4</span>开始干活<br>index: <span class="hljs-number">2</span>开始干活<br>index: <span class="hljs-number">1</span>开始干活<br>index: <span class="hljs-number">8</span>开始干活<br>index: <span class="hljs-number">7</span>开始干活<br>index: <span class="hljs-number">3</span>开始干活<br>index: <span class="hljs-number">6</span>开始干活<br>index: <span class="hljs-number">5</span>开始干活<br></code></pre></td></tr></table></figure>

<h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><p>​    <strong>CountDownLatch</strong>：有主次之分，注重对分支线程的结果在主线程汇总处理</p>
<p>​    <strong>CyclicBarrier</strong>：基本具备CountDownLatch的能力，且可重复触发的。比如3个线程想斗地主，得凑齐3个人才能进行，一轮结束后，继续凑够三人又可以进行下一轮，无需重复触发，像CountDownLatch需要从新await才能起作用。</p>
<h2 id="Atomic-原子操作类"><a href="#Atomic-原子操作类" class="headerlink" title="Atomic 原子操作类"></a>Atomic 原子操作类</h2><p>AtomicInteger 存在ABA问题</p>
<p>AtomicStampReference 利用版本号记录变更编号</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程06-Collection&amp;Queue体系分析</title>
    <url>/2021/11/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&amp;Queue/</url>
    <content><![CDATA[<h1 id="并发编程之Collections-amp-Queue"><a href="#并发编程之Collections-amp-Queue" class="headerlink" title="并发编程之Collections&amp;Queue"></a>并发编程之Collections&amp;Queue</h1><h2 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h2><p>实质就是一种存储数据的结构</p>
<p>通常用链表或者数组实现</p>
<p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p>
<p>主要操作：入队（EnQueue）与出队（Dequeue）</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107225144445.png" alt="image-20211107225144445"></p>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>1、ArrayBlockingQueue 由数组支持的有界队列</p>
<p>2、LinkedBlockingQueue 由链接节点支持的可选有界队列</p>
<p>3、PriorityBlockingQueue 由优先级堆支持的无界优先级队列</p>
<p>4、DelayQueue 由优先级堆支持的、基于时间的调度队列</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107225819914.png" alt="image-20211107225819914"></p>
<h3 id="ArrayBlockingQueue数据结构"><a href="#ArrayBlockingQueue数据结构" class="headerlink" title="ArrayBlockingQueue数据结构"></a>ArrayBlockingQueue数据结构</h3><p>队列基于数组实现,容量大小在创建ArrayBlockingQueue对象时已定义好<br><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107230224968.png" alt="image-20211107230224968"></p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String number ;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 颜色</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String color ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ArrayBlockingQueueTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建容量大小为1的有界队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Ball&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Ball&gt;(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">queueSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> blockingQueue.size();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将球放入队列当中,生产者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ball</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(Ball ball)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        blockingQueue.put(ball);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将球从队列当中拿出去，消费者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Ball <span class="hljs-title">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       <span class="hljs-keyword">return</span> blockingQueue.take();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">final</span> ArrayBlockingQueueTest box = <span class="hljs-keyword">new</span> ArrayBlockingQueueTest();<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 往箱子里面放入乒乓球</span><br><span class="hljs-comment">         */</span><br>        executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                    Ball ball = <span class="hljs-keyword">new</span> Ball();<br>                    ball.setNumber(<span class="hljs-string">&quot;乒乓球编号:&quot;</span>+i);<br>                    ball.setColor(<span class="hljs-string">&quot;yellow&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;:准备往箱子里放入乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        box.produce(ball);<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;:往箱子里放入乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        System.out.println(<span class="hljs-string">&quot;put操作后，当前箱子中共有乒乓球:---&gt;&quot;</span><br>                                + box.queueSize() + <span class="hljs-string">&quot;个&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * consumer，负责从箱子里面拿球出来</span><br><span class="hljs-comment">         */</span><br>        executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;准备到箱子中拿乒乓球:---&gt;&quot;</span>);<br>                        Ball ball = box.consume();<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;拿到箱子中的乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        System.out.println(<span class="hljs-string">&quot;take操作后，当前箱子中共有乒乓球:---&gt;&quot;</span><br>                                + box.queueSize() + <span class="hljs-string">&quot;个&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a>条件等待队列</h3><p>put方法中，使用了AQS的条件等待队列</p>
<p><strong>条件队列中的结点是不会被唤醒去争夺锁的，只能通过转移至CLH同步等待队列才能参与争夺锁</strong></p>
<p>在AQS中，维护了 2个条件等待队列，具体实现是AQS的ConditionObject</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211108000253258.png" alt="image-20211108000253258"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-comment">//获取独占锁</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            <span class="hljs-comment">//如果容量不足，则进度条件等待队列</span><br>            notFull.await();<br>        <span class="hljs-comment">//占用对象数组容量</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加入条件队列等待，条件队列入口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">//如果当前线程被中断则直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">//把当前节点加入条件队列</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">//释放掉已经获取的独占锁资源</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果不在同步队列中则不断挂起</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//自选把结点从条件队列移动到同步等待队列（在等待队列中才可能获取独占锁从而获取独占锁）</span><br>        <span class="hljs-comment">//这里被唤醒可能是正常的signal操作也可能是中断</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 走到这里说明节点已经条件满足被加入到了同步队列中或者中断了</span><br><span class="hljs-comment">             * 这个方法很熟悉吧？就跟独占锁调用同样的获取锁方法，从这里可以看出条件队列只能用于独占锁</span><br><span class="hljs-comment">             * 在处理中断之前首先要做的是从同步队列中成功获取锁资源</span><br><span class="hljs-comment">             */</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-comment">//走到这里说明已经成功获取到了独占锁，接下来就做些收尾工作</span><br>    <span class="hljs-comment">//删除条件队列中被取消的节点</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-comment">//根据不同模式处理中断</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.与同步队列不同，条件队列头尾指针是firstWaiter跟lastWaiter</span><br><span class="hljs-comment"> * 2.条件队列是在获取锁之后，也就是临界区进行操作，因此很多地方不用考虑并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">//如果最后一个节点被取消，则删除队列中被取消的节点</span><br>    <span class="hljs-comment">//至于为啥是最后一个节点后面会分析</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        <span class="hljs-comment">//删除所有被取消的节点</span><br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-comment">//创建一个类型为CONDITION的节点并加入队列，由于在临界区，所以这里不用并发控制</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>​    由优先级堆支持的、基于时间的调度队列，内部基于无界队列PriorityQueue实现，而无界队列基于数组的扩容实现。<br>​    应用场景:电影票<br>​    要求入队的对象必须要实现Delayed接口,而Delayed集成自Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieTiket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Delayed</span> </span>&#123;<br>    <span class="hljs-comment">//延迟时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> delay;<br>    <span class="hljs-comment">//到期时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> expire;<br>    <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br>    <span class="hljs-comment">//创建时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> delay;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> expire;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getNow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delay 延期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">(String msg , <span class="hljs-keyword">long</span> delay)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delay = delay;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>        expire = System.currentTimeMillis() + delay;    <span class="hljs-comment">//到期时间 = 当前时间+延迟时间</span><br>        now = System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(msg,<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>,<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得延迟时间   用过期时间-当前时间,时间单位毫秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unit.convert(<span class="hljs-keyword">this</span>.expire<br>                - System.currentTimeMillis() , TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于延迟队列内部比较排序  当前时间的延迟时间 - 比较对象的延迟时间</span><br><span class="hljs-comment">     * 越早过期的时间在队列中越靠前</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delayed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Delayed delayed)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (<span class="hljs-keyword">this</span>.getDelay(TimeUnit.MILLISECONDS)<br>                - delayed.getDelay(TimeUnit.MILLISECONDS));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MovieTiket&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;delay=&quot;</span> + delay +<br>                <span class="hljs-string">&quot;, expire=&quot;</span> + expire +<br>                <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, now=&quot;</span> + now +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedQueueTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DelayQueue&lt;MovieTiket&gt; delayQueue = <span class="hljs-keyword">new</span> DelayQueue&lt;MovieTiket&gt;();<br>        MovieTiket tiket = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票0&quot;</span>,<span class="hljs-number">10000</span>);<br>        delayQueue.put(tiket);<br>        MovieTiket tiket1 = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票1&quot;</span>,<span class="hljs-number">5000</span>);<br>        delayQueue.put(tiket1);<br>        MovieTiket tiket2 = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票2&quot;</span>,<span class="hljs-number">8000</span>);<br>        delayQueue.put(tiket2);<br>        System.out.println(<span class="hljs-string">&quot;message:---&gt;入队完毕&quot;</span>);<br><br>        <span class="hljs-keyword">while</span>( delayQueue.size() &gt; <span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tiket = delayQueue.take();<br>                System.out.println(<span class="hljs-string">&quot;电影票出队:&quot;</span>+tiket.getMsg());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="Java7HashMap死锁"><a href="#Java7HashMap死锁" class="headerlink" title="Java7HashMap死锁"></a>Java7HashMap死锁</h3><p>Hash表 = 数组 + 链表</p>
<p>扩容时可能会产生死锁，多线程扩容时链表<strong>倒插</strong>可能会产生闭环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapResizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(atomicInteger.get() &lt; <span class="hljs-number">100000</span>)&#123;<br>            map.put(atomicInteger.get(),atomicInteger.get());<br>            atomicInteger.incrementAndGet();<br>        &#125;<br>        System.out.println( Thread.currentThread().getName() + <span class="hljs-string">&quot;线程结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)&#123;<br>         <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MapResizer()).start();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Java8HashMap数据丢失"><a href="#Java8HashMap数据丢失" class="headerlink" title="Java8HashMap数据丢失"></a>Java8HashMap数据丢失</h3><p><strong>Hash表 = 数组 + 链表 + 红黑树</strong></p>
<p><strong>数组扩容时，高低位搭配，不可能形成闭环</strong></p>
<p>扩容时不会倒插，而是采用高低位插入，Node的hash 值&amp;（扩容后大小-1）最高位=1则扩容后下标=扩容前大小+原下标，否则=原下标:扩容后原链表大概会被拆成2段，一段在原下标，一段在（扩容前长度+原下标）的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>    loTail.next = <span class="hljs-keyword">null</span>;<br>    newTab[j] = loHead;<br>&#125;<br><span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>    hiTail.next = <span class="hljs-keyword">null</span>;<br>    newTab[j + oldCap] = hiHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>链表长度大于8并且数组的长度大于64，会把链表转换成红黑树，当链表长度小于等于6时恢复为链表</strong></p>
<p>​    1、TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点且数组长度足够大时才会转成TreeNodes以追求查询速度log2N。</p>
<p>​    2、且正常来说如果hashcode的离散性好的话，value会均匀分布在数组中而很难达到长度为8的地步。</p>
<p>​    3、所以当出现了碰撞度比较高的离散算法时，才会使用到红黑树</p>
<p>理想情况下我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件，</p>
<p>​    0:    0.60653066<br>​    1:    0.30326533<br>​    2:    0.07581633<br>​    3:    0.01263606<br>​    4:    0.00157952<br>​    5:    0.00015795<br>​    6:    0.00001316<br>​    7:    0.00000094<br>​    8:    0.00000006</p>
<p><strong>扩容过程</strong><br><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211110000041790.png" alt="image-20211110000041790"></p>
<h2 id="ConcurrentHashMap线程安全"><a href="#ConcurrentHashMap线程安全" class="headerlink" title="ConcurrentHashMap线程安全"></a>ConcurrentHashMap线程安全</h2><h3 id="1-7分段锁"><a href="#1-7分段锁" class="headerlink" title="1.7分段锁"></a>1.7分段锁</h3><p>ConcurrentHashMap 1.7 = Segment数组（继承ReentrantLock） + hashEntry数组 + 链表,从而实现分段锁，支持并发</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211109233748646.png" alt="image-20211109233748646"></p>
<h3 id="1-8桶锁"><a href="#1-8桶锁" class="headerlink" title="1.8桶锁"></a>1.8桶锁</h3><p>ConcurrentHashMap 1.8 = Node数组 +  链表，区别在于每次插入，都synchronize第一个节点，相同于锁一条链表，锁的粒度变小，并且通过CAS的算法插入每个链表的第一个阶段，从而达到并发，锁的粒度较小，灵活</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS等待队列</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程09-定时任务&amp;定时线程池(非重点)</title>
    <url>/2021/11/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h1><h2 id="定时线程池类的类结构图"><a href="#定时线程池类的类结构图" class="headerlink" title="定时线程池类的类结构图"></a>定时线程池类的类结构图</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128162622219.png" alt="image-20211128162622219"></p>
<h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p>​    它用来处理延时任务或定时任务。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128162931788.png" alt="image-20211128162931788"></p>
<p>它接收<strong>SchduledFutureTask</strong>类型的任务，是线程池调度任务的最小单位，有三 种提交任务的方式：</p>
<ol>
<li>schedule </li>
<li> scheduledAtFixedRate (固定频率，无论任务有没完成，都生成新的任务待执行)</li>
<li>scheduledWithFixedDelay(固定延迟时间，任务完成后才都生成新的延迟任务)</li>
</ol>
<p>它采用DelayQueue存储等待的任务 </p>
<pre><code>1. DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序； 
 2. DelayQueue也是一个无界队列；
</code></pre>
<h2 id="SchduledFutureTask"><a href="#SchduledFutureTask" class="headerlink" title="SchduledFutureTask"></a>SchduledFutureTask</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128163755450.png" alt="image-20211128163755450"></p>
<p>工作线程的执行过程： </p>
<p>​    工作线程会从DelayQueue取已经到期的任务去执行； 执行结束后重新设置任务的到期时间，再次放回DelayQueue<br>​    ScheduledThreadPoolExecutor会把待执行的任务放到工作队列 DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对 队列中的ScheduledFutureTask进行排序</p>
<h3 id="SchduledFutureTask之run方法实现"><a href="#SchduledFutureTask之run方法实现" class="headerlink" title="SchduledFutureTask之run方法实现"></a>SchduledFutureTask之run方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> periodic = isPeriodic();<br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>        cancel(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        ScheduledFutureTask.<span class="hljs-keyword">super</span>.run();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-keyword">super</span>.runAndReset()) &#123;<br>        setNextRunTime();<br>        reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行 步骤2； </li>
<li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后 直接返回，否则执行步骤3； </li>
<li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行 结果，然后直接返回，否则执行步骤4和步骤5； </li>
<li>计算下次执行该任务的具体时间； </li>
<li>重复执行任务。    </li>
</ol>
<h2 id="线程池任务的提交"><a href="#线程池任务的提交" class="headerlink" title="线程池任务的提交"></a>线程池任务的提交</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService scheduler =<br>                Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br>        scheduler.schedule(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;schedule只执行一次的任务&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, TimeUnit.SECONDS );<br><br>        scheduler.scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;scheduleAtFixedRate固定频率执行&quot;</span>);<br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br>        scheduler.scheduleWithFixedDelay(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;scheduleAtFixedRate固定延迟执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br>schedule只执行一次的任务<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行 - 固定频率<br>scheduleAtFixedRate固定频率执行 - 固定频率<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>......<br></code></pre></td></tr></table></figure>

<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>​    ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为 ScheduledThreadPoolExecutor要求的工作队列有些特殊。 DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和 PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以 DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近 的任务在队列的前面（注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次 执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的，下文中会说明）。</p>
<p>堆结构如下图：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128172423526.png" alt="image-20211128172423526"></p>
<p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数 组表示，可以转换成如下的数组：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128172520637.png" alt="image-20211128172520637"></p>
<p>在这种结构中，可以发现有如下特性： 假设，索引值从0开始，子节点的索引值为k，父节点的索引值为p，则： 1     一个节点的左子节点的索引为：k = p * 2 + 1；</p>
<p>​    一个节点的右子节点的索引为：k = (p + 1) * 2； </p>
<p>​     一个节点的父节点的索引为：p = (k - 1) / 2。</p>
<h2 id="如何保证每次取出的任务是优先级最大的"><a href="#如何保证每次取出的任务是优先级最大的" class="headerlink" title="如何保证每次取出的任务是优先级最大的"></a>如何保证每次取出的任务是优先级最大的</h2><p>​    答：在任务提交进入队列时，保持DelayedWorkQueue的第一个总是最小的,通过递归对比即将插入下标结点的父节点，将最小结点层层上移，最终保证队列的第一个元素始终是最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//即将插入下标结点的父节点下标</span><br>        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        setIndex(e, k);<br>        k = parent;<br>    &#125;<br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优01Mysql索引底层原理</title>
    <url>/2021/11/29/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="深入理解Mysql索引底层数据结构与算法"><a href="#深入理解Mysql索引底层数据结构与算法" class="headerlink" title="深入理解Mysql索引底层数据结构与算法"></a>深入理解Mysql索引底层数据结构与算法</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>​    <strong>索引</strong>是帮助MySQL高效获取数据的<strong>排好序的数据结构</strong></p>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206223233336.png" alt="image-20211206223233336"></p>
<p>缺点：</p>
<ul>
<li>索引树的高度 &gt;= log2N + 1 高度可能较高，不可控</li>
<li>索引步骤同样不可控，效率较低</li>
<li>可能形成单向链表、索引效果底下</li>
</ul>
<h3 id="红黑树-效率比二叉树高"><a href="#红黑树-效率比二叉树高" class="headerlink" title="红黑树 (效率比二叉树高)"></a>红黑树 (效率比二叉树高)</h3><p>缺点：</p>
<ul>
<li>可能存在自旋，维护复杂</li>
<li>高度不可控（千万级别数据，层数高）</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206231403113.png" alt="image-20211206231403113"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>特点：</p>
<ul>
<li>叶节点具有相同的深度</li>
<li>索引元素不重复</li>
<li>节点从左到右递增</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引树的高度依旧不可控（因为mysql一般规定一个节点16kb，如果使用InnoDB存储引擎且是主建索引，则value存储的可能就是整个表数据，这会导致每个节点存储的接口个数较少，导致层数增大）</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206231426218.png" alt="image-20211206231426218"></p>
<h3 id="Mysql的B-Tree-原B-Tree叶子结点是单向指针"><a href="#Mysql的B-Tree-原B-Tree叶子结点是单向指针" class="headerlink" title="Mysql的B+Tree(原B+Tree叶子结点是单向指针)"></a>Mysql的B+Tree(原B+Tree叶子结点是单向指针)</h3><p>特点</p>
<ul>
<li>非叶子节点不存储data，只存储索引（叶子结点会冗余），因此可以放更多的索引</li>
<li>叶子结点包含所有的索引字段</li>
<li>叶子结点之间通过指针双向连接，提高区间访问的性能</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206233052712.png" alt="image-20211206233052712"></p>
<h3 id="Mysql的Hash索引"><a href="#Mysql的Hash索引" class="headerlink" title="Mysql的Hash索引"></a>Mysql的Hash索引</h3><p>维护索引列值的hash值和所在行的磁盘空间地址的关系表，可以快速查询出某个值所在行。</p>
<h4 id="存在什么问题："><a href="#存在什么问题：" class="headerlink" title="存在什么问题："></a>存在什么问题：</h4><p>​    不支持范围查询、模糊查询，排序，</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>单等值查询非常快</p>
<h2 id="索引是怎么支撑千万级表的快速查找"><a href="#索引是怎么支撑千万级表的快速查找" class="headerlink" title="索引是怎么支撑千万级表的快速查找"></a>索引是怎么支撑千万级表的快速查找</h2><p>使用B+树缩影，假设树的高度 h = 3，一个节点大小限制16k，主建索引，bigint = 8B,指针连接</p>
<p>=6B。总叶子结点 = （16<em>1024/14） *  （16</em>1024/14） * 16 = 21902400 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206233732916.png" alt="image-20211206233732916"></p>
<h2 id="InnoDB存储引擎索引实现"><a href="#InnoDB存储引擎索引实现" class="headerlink" title="InnoDB存储引擎索引实现"></a>InnoDB存储引擎索引实现</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207232002050.png" alt="image-20211207232002050"></p>
<h3 id="MYSQL5-7"><a href="#MYSQL5-7" class="headerlink" title="MYSQL5.7"></a>MYSQL5.7</h3><h4 id="MYISAM存储引擎"><a href="#MYISAM存储引擎" class="headerlink" title="MYISAM存储引擎"></a>MYISAM存储引擎</h4><p>​        .frm 表结构</p>
<p>​        .MYD 表数据</p>
<p>​        .MYI 表索引</p>
<h4 id="MyISAM索引文件和数据文件是分离的-非聚集"><a href="#MyISAM索引文件和数据文件是分离的-非聚集" class="headerlink" title="MyISAM索引文件和数据文件是分离的(非聚集)"></a>MyISAM索引文件和数据文件是分离的(非聚集)</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235410948.png" alt="image-20211207235410948"></p>
<h3 id="INNODB存储引擎"><a href="#INNODB存储引擎" class="headerlink" title="INNODB存储引擎"></a>INNODB存储引擎</h3><p>​        .frm 表结构</p>
<p>​        .ibd 表数据</p>
<h4 id="InnoDB的主建索引（聚簇索引）"><a href="#InnoDB的主建索引（聚簇索引）" class="headerlink" title="InnoDB的主建索引（聚簇索引）"></a>InnoDB的主建索引（聚簇索引）</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235514358.png" alt="image-20211207235514358"></p>
<h4 id="InnoDB的非主键索引（非聚簇索引）"><a href="#InnoDB的非主键索引（非聚簇索引）" class="headerlink" title="InnoDB的非主键索引（非聚簇索引）"></a>InnoDB的非主键索引（非聚簇索引）</h4><p>​    通过检索二级索引树查到对应主建，在检索主建索引树</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235521058.png" alt="image-20211207235521058"></p>
<h3 id="什么是聚簇索引和非聚簇索引"><a href="#什么是聚簇索引和非聚簇索引" class="headerlink" title="什么是聚簇索引和非聚簇索引"></a>什么是聚簇索引和非聚簇索引</h3><p>​    聚簇索引：索引结构和表数据存储在一起的索引</p>
<p>​    非聚簇索引：索引结构和表数据存储分开存储的索引</p>
<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h3><p>1、为什么推荐声明主建</p>
<p>答：B+树索引数据结构就是根据某个唯一索引组装而成的，就算不声明主建，Mysql也会自动生成一个唯一序列号作为key去构建整棵树</p>
<p>2、为什么推荐整形</p>
<p>答：如果用字符串，还得统一装换成ASCALL码进行比较大小，如果是整形则比较更加便捷<br>3、为什么推荐自增</p>
<p>答：B+树在逐步构建时都是某个节点满了才向右扩充，如果这个时候插入某一个值且这个值要放在已经满了的节点，则容易造成B+树频繁调整，维护麻烦。（自增插入的话，只会影响右下角区域的数据调整）</p>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值？-一致性和节省存储空间"><a href="#为什么非主键索引结构叶子节点存储的是主键值？-一致性和节省存储空间" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)"></a>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</h3><p>1、节省存储空间，存在多个索引时，只有主键索引才包含所有数据，其他索引只冗余主建id，这样可以大大节约空间</p>
<p>2、如果多个索引都维护所有数据，那势必会有维护复杂，数据一致性问题，事倍功半。</p>
<h3 id="联合索引的底层存储结构长什么样"><a href="#联合索引的底层存储结构长什么样" class="headerlink" title="联合索引的底层存储结构长什么样"></a>联合索引的底层存储结构长什么样</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207234827138.png" alt="image-20211207234827138"></p>
<p>索引最左前缀原理</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优07-Tomcat网络通信模型与应用解析</title>
    <url>/2021/12/29/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、Tomcat组件介绍"><a href="#一、Tomcat组件介绍" class="headerlink" title="一、Tomcat组件介绍"></a>一、Tomcat组件介绍</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>​    Tomcat是一个基于JAVA的WEB容器，其实现了JAVA EE中的 Servlet 与 jsp 规范，与Nginx（一般用于反向代理、负载均衡，屏蔽内部细节）、apache 服务器不同在于一般用于<strong>动态请求处理</strong>。在架构设计上采用面向组件的方式设计。即整体功能是通过组件的方式拼装完成。另外每个组件都可以被替换以保证灵活性。</p>
<p>​    那么是哪些组件组成了Tomcat呢？</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/tomcat-startup.gif" alt="图片"></p>
<h2 id="2、Tomcat-各组件及关系"><a href="#2、Tomcat-各组件及关系" class="headerlink" title="2、Tomcat 各组件及关系"></a>2、Tomcat 各组件及关系</h2><ul>
<li>Server<ul>
<li>Service<ul>
<li>Connector   连接器<ul>
<li>HTTP 1.1</li>
<li>SSL  https</li>
<li>AJP（ Apache JServ Protocol） apache 私有协议，用于apache 反向代理Tomcat</li>
</ul>
</li>
</ul>
</li>
<li>Container <ul>
<li>Engine  引擎 catalina<ul>
<li>Host   虚拟机 基于域名 分发请求<ul>
<li>Context 隔离各个WEB应用 每个Context的  ClassLoader独立</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Component <ul>
<li>Manager （管理器）</li>
<li>logger （日志管理）</li>
<li>loader （载入器）</li>
<li>pipeline (管道)</li>
<li>valve （管道中的阀）</li>
</ul>
</li>
</ul>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20211229224310865.png" alt="image-20211229224310865"></p>
<h2 id="3、Tomcat-server-xml-配置"><a href="#3、Tomcat-server-xml-配置" class="headerlink" title="3、Tomcat server.xml 配置"></a>3、Tomcat server.xml 配置</h2><h3 id="server"><a href="#server" class="headerlink" title="**server  **"></a>**server  **</h3><p>​    root元素——server 的顶级配置<br>主要属性:</p>
<ul>
<li>port：执行关闭命令的端口号</li>
<li>shutdown：关闭命令</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">#基于telent执行SHUTDOWN 命令即可关闭(必须大写)<br>telent 127.0.0.1 8005<br>SHUTDOWN<br></code></pre></td></tr></table></figure>

<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>#基于telent 执行SHUTDOWN 命令即可关闭(必须大写)<br>telent 127.0.0.1 8005<br>SHUTDOWN</p>
<p>​    服务：将多个connector 与一个Engine组合成一个服务，可以配置多个服务。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>​    连接器：用于接收 指定协议下的连接 并指定给唯一的Engine 进行处理。</p>
<p>主要属性：</p>
<ul>
<li>protocol 监听的协议，默认是http/1.1(可以指定特性的)</li>
<li>port 指定服务器端要创建的端口号</li>
<li>minThread    服务器启动时创建的处理请求的线程数</li>
<li>maxThread    最大可以创建的处理请求的线程数</li>
<li>enableLookups    如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</li>
<li>redirectPort    指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</li>
<li>acceptCount    指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理</li>
<li>connectionTimeout    指定超时的时间数(以毫秒为单位)</li>
<li>SSLEnabled 是否开启 sll 验证，在Https 访问时需要开启。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 演示配置Connector --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8860&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8862&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">useBodyEncodingForURI</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">compression</span>=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">&quot;2048&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">compressableMimeType</span>=<span class="hljs-string">&quot;text/html,text/xml,text/plain,text/javascript,text/css,application/x-json,application/json,application/x-javascript&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;1024&quot;</span> <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">&quot;200&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">&quot;800&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">enableLookups</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a><strong>Engine</strong></h3><p>​    引擎：用于处理连接的执行器，默认的引擎是catalina。一个service 中只能配置一个Engine。<br>主要属性：</p>
<ul>
<li>name 引擎名称 </li>
<li>defaultHost 默认host</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a><strong>Host</strong></h3><p>​    虚拟机：基于域名匹配至指定虚拟机。类似于nginx 当中的server,默认的虚拟机是localhost<br>主要属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;www.luban.com&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;/usr/www/luban&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;logs&quot;</span>               <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;www.luban.com.access_log&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;.txt&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a><strong>Context</strong></h3><p>应用上下文：一个host 下可以配置多个Context ，每个Context 都有其独立的classPath。相互隔离，以免造成ClassPath 冲突。<br>主要属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/h&quot;</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>Valve</strong><br>阀门：可以理解成的过滤器，具体配置要基于具体的Valve 接口的子类。以下即为一个访问日志的Valve.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;logs&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;www.luban.com.access_log&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;.txt&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>







<h1 id="二、Tomcat通信模型原理与源码"><a href="#二、Tomcat通信模型原理与源码" class="headerlink" title="二、Tomcat通信模型原理与源码"></a>二、Tomcat通信模型原理与源码</h1>]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优10JVM01类加载机制深度解析</title>
    <url>/2021/10/04/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>​    1、避免同名类被重复加载，<strong>保证加载类的唯一性</strong>。</p>
<p>​    2、<strong>沙箱安全机制</strong>（避免恶意代码的影响，一些关键包不允许重写 比如 java.lang java开头的）</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211006160302834.png" alt="image-20211006160302834"></p>
<h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><p>如何打破：</p>
<p>​    继承ClassLoader 重写loadClass(即重写原双亲委派机制逻辑)方法</p>
<p>应用场景：</p>
<p>​    Tomcat：不同项目不同版本类</p>
<p>​    SPI机制：</p>
<p>​    模块化启动检查</p>
<h2 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211007201017900.png" alt="image-20211007201017900"></p>
<h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h3><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>JVM运行模式</p>
<p>​    解释模式</p>
<p>​    编译模式</p>
<p>​    混合模式</p>
<p><strong>逃逸分析是在JIT(Just In Time Compiler)即时编译技术时产生的</strong></p>
<h2 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h2><ol>
<li>大对象直接进入老年代</li>
<li>长期存活对象进入老年代</li>
<li>动态年龄判断</li>
<li>老年代空间分配担保机制</li>
</ol>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211007215454113.png" alt="image-20211007215454113"></p>
<h3 id="Eden与Survivor区默认8-1-1"><a href="#Eden与Survivor区默认8-1-1" class="headerlink" title="Eden与Survivor区默认8:1:1"></a><strong>Eden与Survivor区默认8:1:1</strong></h3><h3 id="判断对象可回收"><a href="#判断对象可回收" class="headerlink" title="判断对象可回收"></a>判断对象可回收</h3><ol>
<li>引用计数器法（存在缺陷，相互引用的场景不可回收，存在内存泄漏）</li>
<li>可达性分析算法 （GC Root链) + finalize方法标记</li>
<li>引用 类型判断</li>
</ol>
<h3 id="判断方法区中的类可回收"><a href="#判断方法区中的类可回收" class="headerlink" title="判断方法区中的类可回收"></a>判断方法区中的类可回收</h3><p>1、类不存在实例</p>
<p>2、类对应 java.lang.Class 对象没有被引用，也没有被反射</p>
<p>3、类对应的ClassLoader 已经被回收</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><strong>复制算法</strong></p>
<p><strong>标记清除算法</strong></p>
<p><strong>标记整理算法</strong></p>
<p><strong>分代收集算法</strong></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><strong>单线程</strong></p>
<p>STW(Stop The World)</p>
<p>CMS收集器的备用方案</p>
<p>新生代采用复制算法，老年代采用标记-整理算法。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211008235346636.png" alt="image-20211008235346636"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>Serial收集器的多线程版本</strong></p>
<p>STW</p>
<p>新生代采用复制算法，老年代采用标记-整理算法</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211008235405910.png" alt="image-20211008235405910"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>与ParNew类似</p>
<p>更注重吞吐量，提供相关参数控制，GC结束，不一定全部清理完成</p>
<p>新生代采用复制算法，老年代采用标记-整理算法</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>以获取最<strong>短回收停顿时间</strong>为目标，提高用户体验度</p>
<p><strong>只应用于老年代</strong></p>
<p>STW时间短</p>
<p>存在<strong>浮动垃圾</strong>，下次GC回收</p>
<p><strong>标记-清除算法</strong>（可设置参数使之清除后-整理）</p>
<p>主要分为4个阶段</p>
<p>初始标记：STW 只标记GCRoot的直接应用，速度较快</p>
<p>并发标记：继续向下进行可达性分析标记</p>
<p>重新标记：STW 时间稍长，对并发标记期间产生的影响进行修正 </p>
<p>并发清理：GC线程开始对未标记的区域做清扫</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211008235420459.png" alt="image-20211008235420459"></p>
<p><strong>CMS的相关参数</strong> </p>
<p>-XX:+UseConcMarkSweepGC：启用cms </p>
<p>-XX:ConcGCThreads：并发的GC线程数 </p>
<p>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片） </p>
<p>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次 </p>
<p>FullGC后都会压缩一次 </p>
<p>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认 </p>
<p>是92，这是百分比） </p>
<p>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(- </p>
<p>XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定 </p>
<p>值，后续则会自动调整 </p>
<p>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少 </p>
<p>老年代对年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在 </p>
<p>remark阶段 </p>
<h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>​    G1 (Garbage-First)是一款面向服务器的垃圾收集器主要针对配备多颗处理器及<strong>大容量内存</strong>的机器. 以极高概率<strong>满足GC停顿时间</strong>要求的同时,还具备高吞吐量性能特征.</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211011233109041.png" alt="image-20211011233109041"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211011233121454.png" alt="image-20211011233121454"></p>
<p>​    <strong>G1将Java堆划分为多个大小相等的独立区域（Region）</strong>，JVM最多可以有2048个Region。</p>
<p>​    <strong>Region的区域功能可能会动态变化</strong></p>
<p>​    <strong>回收算法主要用的是复制算法</strong></p>
<p>​    <strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong></p>
<p>​    <strong>有专门分配大对象的Region叫Humongous区</strong>，而不是让大对象直接进入老年代的 </p>
<p>Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，可横跨多个</p>
<h3 id="G1收集器一次GC的运作过程大致分为以下几个步骤："><a href="#G1收集器一次GC的运作过程大致分为以下几个步骤：" class="headerlink" title="G1收集器一次GC的运作过程大致分为以下几个步骤："></a>G1收集器一次GC的运作过程大致分为以下几个步骤：</h3><p><strong>初始标记</strong>（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用 的对象，速度很快 ； </p>
<p><strong>并发标记</strong>（Concurrent Marking）：同CMS的并发标记 </p>
<p><strong>最终标记</strong>（Remark，STW）：同CMS的重新标记 </p>
<p><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的<strong>回收价值和成本进行</strong> </p>
<p><strong>排序</strong>，<strong>根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制</strong> </p>
<p><strong>定回收计划</strong></p>
<h3 id="G1具备以下特点"><a href="#G1具备以下特点" class="headerlink" title="G1具备以下特点"></a>G1具备以下特点</h3><p>​    并行与并发</p>
<p>​    分代收集</p>
<p>​    空间整合</p>
<p>​    <strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势</p>
<h4 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h4><p><strong>YoungGC</strong> </p>
<blockquote>
<p>YoungGC并不是说现有的Eden区放满了就会马上触发，而且G1会计算下现在Eden区回收大 </p>
<p>概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代 </p>
<p>的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时 </p>
<p>间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC </p>
</blockquote>
<p><strong>MixedGC</strong> </p>
<blockquote>
<p>不是FullGC，老年代的堆占有率达到参数(<strong>-XX:InitiatingHeapOccupancyPercen</strong>)设定的值 </p>
<p>则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以 </p>
<p>及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中 </p>
<p>存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象 </p>
<p>就会触发一次Full GC </p>
</blockquote>
<p><strong>Full GC</strong> </p>
<blockquote>
<p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下 </p>
<p>一次MixedGC使用，这个过程是非常耗时的。 </p>
</blockquote>
<h2 id="JDK自带工具"><a href="#JDK自带工具" class="headerlink" title="JDK自带工具"></a>JDK自带工具</h2><blockquote>
<p>jvisualvm 查看可视化dump文件</p>
<p>jinfo pid  Jinfo查看正在运行的Java应用程序的扩展参数</p>
<p><strong>jmap 此命令可以用来查看内存信息</strong>，可以dump出堆内存</p>
<p><strong>jstat -gc pid</strong> 命令可以查看堆内存各部分的使用量，以及加载类的数量。</p>
<p><strong>jstck pid</strong> 用jstack查找死锁</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot下枚举治理方案</title>
    <url>/2021/11/14/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="枚举治理"><a href="#枚举治理" class="headerlink" title="枚举治理"></a>枚举治理</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1、多版本运行开发枚举容易导致冲突，服务无感知</p>
<p>2、业务中使用枚举实例处理逻辑，API入参/返参的枚举类型，需要手动转换</p>
<p>3、API文档(Swagger)枚举描述需要手动列举枚举值，枚举添加/修改描述无法及时更新</p>
<p>4、数据库中的枚举字段，查询出来后需要根据枚举处理，得先转化实例判断，冗余复杂</p>
<p>5、API返回枚举展示值需要手动设置，重复代码较多</p>
<p>6、API接受枚举类型参数的校验场景，冗余复杂</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>1、系统启动检查枚举是否存在冲突</strong></p>
<p><strong>2、API入参/返参支持序列化枚举类型</strong></p>
<p><strong>3、Dao持久层框架（mybatis），出入参支持枚举类型</strong></p>
<p><strong>4、swagger文档定制枚举动态渲染</strong></p>
<p><strong>5、API返回枚举展示值需要手动设置，重复代码较多</strong></p>
<p><strong>6、基于Validation支持枚举类型校验</strong></p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p><strong>系统启动检查枚举是否存在冲突</strong></p>
<ol>
<li>定义枚举注解，标识组件管理的枚举</li>
<li>实现BeanDefinitionRegistryPostProcessor，启动扫描所有枚举类</li>
<li>遍历枚举值，检测是否存在冲突</li>
</ol>
<p><img src="/images/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20211105141116817.png" alt="image-20211105141116817"> </p>
<p><strong>API入参/返参支持序列化枚举类型（系统统一使用fastjson）</strong></p>
<ol>
<li><p>Fastjson调研：<br>默认枚举序列化器:com.alibaba.fastjson.serializer.EnumSerializer<br>默认枚举反序列化器:com.alibaba.fastjson.parser.deserializer.EnumDeserializer</p>
</li>
<li><p>自定义重写EnumSerializer、EnumDeserializer 序列化、反序列化器</p>
</li>
<li><p>覆盖fastjson FastJsonHttpMessageConverter默认配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastJsonPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean,String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>&#123;<br>        <span class="hljs-keyword">if</span>(bean <span class="hljs-keyword">instanceof</span> FastJsonHttpMessageConverter)&#123;<br>            FastJsonHttpMessageConverter messageConverter = (FastJsonHttpMessageConverter)bean;<br>            FastJsonConfig fastJsonConfig = messageConverter.getFastJsonConfig();<br>            fastJsonConfig.setParserConfig(<span class="hljs-keyword">new</span> EnumParserConfig());<br>            fastJsonConfig.setSerializeConfig(<span class="hljs-keyword">new</span> EnumSerializeConfig());<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>Dao持久层框架（mybatis）出入参支持枚举类型</strong></p>
<ol>
<li>自定义枚举类型转换器TypeHandler</li>
<li>注入所有枚举类型转换器到mybatis的SqlSessionFactory</li>
</ol>
<p><strong>Swagger文档定制枚举动态渲染</strong></p>
<ol>
<li>重写ModelPropertyBuilderPlugin自定义枚举，动态列举枚举实例描述</li>
</ol>
<p><strong>API返回枚举展示值自动渲染输出</strong></p>
<ol>
<li><p>举类型字段abc序列化时，在同级目录自动输出abcStr展示字段 如：</p>
<p><img src="/images/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20211105110343791.png" alt="image-20211105110343791"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnumAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ServerType</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1 - ISC</span><br><span class="hljs-comment">     */</span><br>    ISC(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ISC&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2 - 萤石</span><br><span class="hljs-comment">     */</span><br>    YS(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;萤石&quot;</span>),<br>    ;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@EnumValue</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer code;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@EnumName</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    ServerType(Integer code, String name) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultEnumMatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EnumMatcher</span>&lt;<span class="hljs-title">VideoType</span>&gt;</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(VideoType targetEnum)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> Arrays.asList(VideoType.values()).contains(targetEnum);<br>        &#125;<br>    &#125;<br>&#125;<br>在序列化出参时，转化为<br>&#123;<br>    <span class="hljs-string">&quot;serverType&quot;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;serverTypeStr&quot;</span>:<span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>基于Validation支持枚举类型校验</strong></p>
<ol>
<li>自定义@EnumValid注解，用于标注需要校验的枚举字段</li>
<li>自定义ConstraintValidator，校验@EnumValid</li>
<li>定义枚举时，定义默认枚举校验器如上文：ServerType.DefaultEnumMatcher</li>
</ol>
<h2 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h2><ol>
<li>API入参支持使用枚举类型接受</li>
<li>API入参枚举类型支持校验</li>
<li>API出参自动渲染枚举展示名称</li>
<li>持久层出入参支持枚举类型</li>
<li>API枚举入参支持swagger动态渲染</li>
<li>启动自动监测枚举冲突</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、修改了实体的序列化反序列化方式，不支持序列化后反序列化或者反序列化后序列化操作</p>
<p>2、依赖FastJson、Swagger3.0、Mybatis，版本兼容性较低、普适性较低</p>
<p>3、API出参序列化输出枚举展示字段，但是暂不支持在Swagger上输出该字段</p>
<h2 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h2><p>1、API出参序列化输出枚举展示字段，支持在Swagger上输出该字段</p>
]]></content>
      <categories>
        <category>枚举治理</category>
      </categories>
      <tags>
        <tag>枚举治理</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti整合Spring</title>
    <url>/2021/04/17/Activiti%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="Activiti整合Spring"><a href="#Activiti整合Spring" class="headerlink" title="Activiti整合Spring"></a>Activiti整合Spring</h1><h1 id="一、Activiti与Spring整合开发"><a href="#一、Activiti与Spring整合开发" class="headerlink" title="一、Activiti与Spring整合开发"></a>一、Activiti与Spring整合开发</h1><h2 id="1-1-Activiti与Spring整合的配置"><a href="#1-1-Activiti与Spring整合的配置" class="headerlink" title="1.1 Activiti与Spring整合的配置"></a>1.1 Activiti与Spring整合的配置</h2><h3 id="1-、在pom-xml文件引入坐标"><a href="#1-、在pom-xml文件引入坐标" class="headerlink" title="1)、在pom.xml文件引入坐标"></a>1)、在pom.xml文件引入坐标</h3><p>如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-nop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log end --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alfresco<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Activiti Releases<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://artifacts.alfresco.com/nexus/content/repositories/activiti-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在Activiti中核心类的是ProcessEngine流程引擎，与Spring整合就是让Spring来管理ProcessEngine</p>
<p>通过<strong>org.activiti.spring.SpringProcessEngineConfiguration</strong> 与Spring整合方式来创建ProcessEngine对象。 </p>
<p> 创建spring与activiti的整合配置文件：activiti-spring.xml（名称不固定）</p>
<h3 id="2-、创建activiti-spring-xml"><a href="#2-、创建activiti-spring-xml" class="headerlink" title="2)、创建activiti-spring.xml"></a>2)、创建activiti-spring.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 工作流引擎配置bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用spring事务管理器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;drop-create&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 资源服务service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;repositoryService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRepositoryService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程运行service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;runtimeService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRuntimeService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 任务管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getTaskService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 历史管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;historyService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getHistoryService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通知 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 传播行为 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;save*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 切面，根据具体项目修改切点配置</span><br><span class="hljs-comment">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="hljs-comment">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;</span><br><span class="hljs-comment">                     pointcut=&quot;execution(*com.itheima.service.impl..(..))&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/aop:config&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3-、aseSchemaUpdate的取值内容："><a href="#3-、aseSchemaUpdate的取值内容：" class="headerlink" title="3)、aseSchemaUpdate的取值内容："></a>3)、aseSchemaUpdate的取值内容：</h3><p><strong>flase：</strong>       默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常。（生产环境常用）<br><strong>true：</strong>        activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建。（开发时常用）<br><strong>create_drop</strong>： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）。（单元测试常用）<br><strong>drop-create</strong>： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）。</p>
<h2 id="1-2-测试Activiti与Spring整合"><a href="#1-2-测试Activiti与Spring整合" class="headerlink" title="1.2 测试Activiti与Spring整合"></a>1.2 测试Activiti与Spring整合</h2><h3 id="1）、测试代码"><a href="#1）、测试代码" class="headerlink" title="1）、测试代码"></a>1）、测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   测试activiti与spring整合是否成功</span><br><span class="hljs-comment">**/</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:activiti-spring.xml&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiTest</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> RepositoryService repositoryService;<br>     <br>     <span class="hljs-meta">@Test</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;部署对象:&quot;</span>+repositoryService);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="2）、执行流程分析"><a href="#2）、执行流程分析" class="headerlink" title="2）、执行流程分析"></a>2）、执行流程分析</h3><p>下面我们一起来分析Activiti与Spring整合加载的过程。</p>
<p>1、加载activiti-spring.xml配置文件</p>
<p>2、加载SpringProcessEngineConfiguration对象，这个对象它需要依赖注入dataSource对象和transactionManager对象。</p>
<p>3、加载ProcessEngineFactoryBean工厂来创建ProcessEngine对象，而ProcessEngineFactoryBean工厂又需要依赖注入processEngineConfiguration对象。</p>
<p>4、processEngine对象来负责创建我们的Service对象，从而简化Activiti的开发过程。</p>
<h1 id="二、Activiti7与SpringBoot整合开发"><a href="#二、Activiti7与SpringBoot整合开发" class="headerlink" title="二、Activiti7与SpringBoot整合开发"></a>二、Activiti7与SpringBoot整合开发</h1><p>Activiti7发布正式版之后，它与SpringBoot2.x已经完全支持整合开发。</p>
<h2 id="2-1-SpringBoot整合Activiti7的配置"><a href="#2-1-SpringBoot整合Activiti7的配置" class="headerlink" title="2.1     SpringBoot整合Activiti7的配置"></a>2.1     SpringBoot整合Activiti7的配置</h2><p>为了能够实现SpringBoot与Activiti7整合开发，首先我们要引入相关的依赖支持。</p>
<p>在工程的pom.xml文件中引入相关的依赖，其中activiti的依赖是：activiti-spring-boot-starter。</p>
<p>具体依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过该pom.xml文件所导入的坐标，我们就可以实现activiti7与Springboot整合。</p>
<h2 id="2-2-SpringBoot的application-yml文件配置"><a href="#2-2-SpringBoot的application-yml文件配置" class="headerlink" title="2.2    SpringBoot的application.yml文件配置"></a>2.2    SpringBoot的application.yml文件配置</h2><p>为了能够实现Activiti7生成的表放到Mysql数据库中，需要在配置文件application.yml中添加相关的配置</p>
<p>注意：activiti7默认没有开启数据库历史记录，需要手动配置开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///activiti?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">activiti:</span><br>    <span class="hljs-comment">#1.flase：默认值。activiti在启动时，对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常</span><br>    <span class="hljs-comment">#2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建</span><br>    <span class="hljs-comment">#3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span><br>    <span class="hljs-comment">#4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）</span><br>    <span class="hljs-attr">database-schema-update:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#检测历史表是否存在 activiti7默认没有开启数据库历史记录 启动数据库历史记录</span><br>    <span class="hljs-attr">db-history-used:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#记录历史等级 可配置的历史级别有none, activity, audit, full</span><br>    <span class="hljs-comment">#none：不保存任何的历史数据，因此，在流程执行过程中，这是最高效的。</span><br>    <span class="hljs-comment">#activity：级别高于none，保存流程实例与流程行为，其他数据不保存。</span><br>    <span class="hljs-comment">#audit：除activity级别会保存的数据外，还会保存全部的流程任务及其属性。audit为history的默认值。</span><br>    <span class="hljs-comment">#full：保存历史数据的最高级别，除了会保存audit级别的数据外，还会保存其他全部流程相关的细节数据，包括一些流程参数等。</span><br>    <span class="hljs-attr">history-level:</span> <span class="hljs-string">full</span><br>    <span class="hljs-comment">#校验流程文件，默认校验resources下的processes文件夹里的流程文件</span><br>    <span class="hljs-attr">check-process-definitions:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h2 id="2-3-编写启动类"><a href="#2-3-编写启动类" class="headerlink" title="2.3 编写启动类"></a>2.3 编写启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ActApplication.class,args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="2-4-添加SpringSecurity安全框架整合配置"><a href="#2-4-添加SpringSecurity安全框架整合配置" class="headerlink" title="2.4    添加SpringSecurity安全框架整合配置"></a>2.4    添加SpringSecurity安全框架整合配置</h2><p>因为Activiti7与SpringBoot整合后，默认情况下，集成了SpringSecurity安全框架，这样我们就要去准备SpringSecurity整合进来的相关用户权限配置信息。</p>
<p>SpringBoot的依赖包已经将SpringSecurity的依赖包也添加进项目中。</p>
<h3 id="2-4-1-添加SecurityUtil类"><a href="#2-4-1-添加SecurityUtil类" class="headerlink" title="2.4.1  添加SecurityUtil类"></a>2.4.1  添加SecurityUtil类</h3><p>为了能够快速实现SpringSecurity安全框架的配置，所添加的一个组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.utils;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<br><span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextImpl;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(SecurityUtil.class);<br><br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-meta">@Qualifier(&quot;myUserDetailsService&quot;)</span><br>     <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logInAs</span><span class="hljs-params">(String username)</span> </span>&#123;<br>     UserDetails user = userDetailsService.loadUserByUsername(username);<br><br>     <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;User &quot;</span> + username + <span class="hljs-string">&quot; doesn&#x27;t exist, please provide a valid user&quot;</span>);<br>     &#125;<br>     logger.info(<span class="hljs-string">&quot;&gt; Logged in as: &quot;</span> + username);<br><br>     SecurityContextHolder.setContext(<br>             <span class="hljs-keyword">new</span> SecurityContextImpl(<br>                     <span class="hljs-keyword">new</span> Authentication() &#123;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;<br>                             <span class="hljs-keyword">return</span> user.getAuthorities();<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user.getPassword();<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123; &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user.getUsername();<br>                         &#125;<br>     &#125;));<br>     org.activiti.engine.impl.identity.Authentication.setAuthenticatedUserId(username);<br> &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>这个类可以从我们下载的Activiti7官方提供的Example中找到。</p>
<h3 id="2-4-2-添加DemoApplicationConfig类"><a href="#2-4-2-添加DemoApplicationConfig类" class="headerlink" title="2.4.2  添加DemoApplicationConfig类"></a>2.4.2  添加DemoApplicationConfig类</h3><p>在Activiti7官方下载的Example中找到DemoApplicationConfig类，它的作用是为了实现SpringSecurity框架的用户权限的配置，这样我们就可以在系统中使用用户权限信息。</p>
<p>本次项目中基本是在文件中定义出来的用户信息，当然也可以是数据库中查询的用户权限信息。</p>
<p>后面处理流程时用到的任务负责人，需要添加在这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.config;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;<br><span class="hljs-keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplicationConfiguration</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(DemoApplicationConfiguration.class);<br>     <span class="hljs-meta">@Bean</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">myUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;<br>         InMemoryUserDetailsManager inMemoryUserDetailsManager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();<br>         <span class="hljs-comment">//这里添加用户，后面处理流程时用到的任务负责人，需要添加在这里</span><br>         String[][] usersGroupsAndRoles = &#123;<br>                 &#123;<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;other&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_otherTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_ADMIN&quot;</span>&#125;,<br>         &#125;;<br><br>         <span class="hljs-keyword">for</span> (String[] user : usersGroupsAndRoles) &#123;<br>             List&lt;String&gt; authoritiesStrings = Arrays.asList(Arrays.copyOfRange(user, <span class="hljs-number">2</span>, user.length));<br>             logger.info(<span class="hljs-string">&quot;&gt; Registering new user: &quot;</span> + user[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; with the following Authorities[&quot;</span> + authoritiesStrings + <span class="hljs-string">&quot;]&quot;</span>);<br>             inMemoryUserDetailsManager.createUser(<span class="hljs-keyword">new</span> User(user[<span class="hljs-number">0</span>], passwordEncoder().encode(user[<span class="hljs-number">1</span>]),<br>                     authoritiesStrings.stream().map(s -&gt; <span class="hljs-keyword">new</span> SimpleGrantedAuthority(s)).collect(Collectors.toList())));<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> inMemoryUserDetailsManager;<br>     &#125;<br>     <span class="hljs-meta">@Bean</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-创建Bpmn文件"><a href="#2-5-创建Bpmn文件" class="headerlink" title="2.5 创建Bpmn文件"></a>2.5 创建Bpmn文件</h2><p>Activiti7可以自动部署流程，前提是在resources目录下，创建一个新的目录processes，用来放置bpmn文件。</p>
<p>创建一个简单的Bpmn流程文件，并设置任务的用户组Candidate Groups。</p>
<p>Candidate Groups中的内容与上面DemoApplicationConfiguration类中出现的用户组名称要保持一致，可以填写：activitiTeam 或者 otherTeam。</p>
<p>这样填写的好处：当不确定到底由谁来负责当前任务的时候，只要是Groups内的用户都可以拾取这个任务</p>
<p><img src="images/Activiti%E6%95%B4%E5%90%88/1578369213.png"></p>
<h2 id="2-6-使用Junit方式测试"><a href="#2-6-使用Junit方式测试" class="headerlink" title="2.6    使用Junit方式测试"></a>2.6    使用Junit方式测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> com.itheima.utils.SecurityUtil;<br><span class="hljs-keyword">import</span> org.activiti.api.process.model.ProcessInstance;<br><span class="hljs-keyword">import</span> org.activiti.api.process.model.builders.ProcessPayloadBuilder;<br><span class="hljs-keyword">import</span> org.activiti.api.process.runtime.ProcessRuntime;<br><span class="hljs-keyword">import</span> org.activiti.api.runtime.shared.query.Page;<br><span class="hljs-keyword">import</span> org.activiti.api.runtime.shared.query.Pageable;<br><span class="hljs-keyword">import</span> org.activiti.api.task.model.Task;<br><span class="hljs-keyword">import</span> org.activiti.api.task.model.builders.TaskPayloadBuilder;<br><span class="hljs-keyword">import</span> org.activiti.api.task.runtime.TaskRuntime;<br><span class="hljs-keyword">import</span> org.activiti.engine.repository.ProcessDefinition;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actviti7DemoApplicationTests</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> ProcessRuntime processRuntime;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> TaskRuntime taskRuntime;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> SecurityUtil securityUtil;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testActBoot</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(taskRuntime);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查看流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;system&quot;</span>);<br>        Page&lt;org.activiti.api.process.model.ProcessDefinition&gt; processDefinitionPage =<br>                processRuntime.processDefinitions(Pageable.of(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br>        System.out.println(<span class="hljs-string">&quot;可用的流程定义数量：&quot;</span> + processDefinitionPage.getTotalItems());<br>        <span class="hljs-keyword">for</span> (org.activiti.api.process.model.ProcessDefinition pd : processDefinitionPage.getContent()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span> + pd);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStartProcess</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;system&quot;</span>);<br>        ProcessInstance pi = processRuntime.start(ProcessPayloadBuilder.<br>                start().<br>                withProcessDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>).<br>                build());<br>        System.out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span> + pi.getId());<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     **查询任务，并完成自己的任务</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTask</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;jack&quot;</span>);<br>        Page&lt;Task&gt; taskPage=taskRuntime.tasks(Pageable.of(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">if</span> (taskPage.getTotalItems()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (Task task:taskPage.getContent())&#123;<br>                taskRuntime.claim(TaskPayloadBuilder.<br>                        claim().<br>                        withTaskId(task.getId()).build());<br>                System.out.println(<span class="hljs-string">&quot;任务：&quot;</span>+task);<br>                taskRuntime.complete(TaskPayloadBuilder.<br>                        complete().<br>                        withTaskId(task.getId()).build());<br>            &#125;<br>        &#125;<br>        Page&lt;Task&gt; taskPage2=taskRuntime.tasks(Pageable.of*(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">if</span> (taskPage2.getTotalItems()&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;任务：&quot;</span>+taskPage2.getContent());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="三、activiti6整合springboot2"><a href="#三、activiti6整合springboot2" class="headerlink" title="三、activiti6整合springboot2"></a><strong>三、activiti6整合springboot2</strong></h1><p>参考我的github：<a href="https://github.com/Callme24kHandsome/springboot-parent">https://github.com/Callme24kHandsome/springboot-parent</a></p>
<p>的actSpringBoot moudle</p>
<p>​    整合原则，采用spring整合activiti的方式，个人认为整合springboot需要排除spring-security的相关配置，比较麻烦。顾此整合spring，更显得灵活</p>
<h2 id="1、ativitiConfig-java-注入组件"><a href="#1、ativitiConfig-java-注入组件" class="headerlink" title="1、ativitiConfig.java 注入组件"></a>1、ativitiConfig.java 注入组件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiConfig</span></span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ProcessEngineConfiguration <span class="hljs-title">processEngineConfiguration</span><span class="hljs-params">(DataSourceTransactionManager transactionManager,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                 <span class="hljs-meta">@Qualifier(&quot;dataSource&quot;)</span> DataSource dataSource,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                 Environment environment)</span> </span>&#123;<br>        SpringProcessEngineConfiguration configuration = <span class="hljs-keyword">new</span> SpringProcessEngineConfiguration();<br>        configuration.setTransactionManager(transactionManager);<br>        configuration.setDataSource(dataSource);<br>        configuration.setDatabaseSchemaUpdate(<span class="hljs-string">&quot;true&quot;</span>);<br>        configuration.setDbIdentityUsed(<span class="hljs-keyword">false</span>);<br>        configuration.setDatabaseType(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">return</span> configuration;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ProcessEngine <span class="hljs-title">processEngine</span><span class="hljs-params">(ProcessEngineConfiguration processEngineConfiguration)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngineConfiguration.buildProcessEngine();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RepositoryService <span class="hljs-title">repositoryService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getRepositoryService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RuntimeService <span class="hljs-title">runtimeService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getRuntimeService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskService <span class="hljs-title">taskService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getTaskService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HistoryService <span class="hljs-title">historyService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getHistoryService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ManagementService <span class="hljs-title">managementService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getManagementService();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FormService <span class="hljs-title">formService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getFormService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IdentityService <span class="hljs-title">identityService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getIdentityService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、aplication-yml文件"><a href="#2、aplication-yml文件" class="headerlink" title="2、aplication.yml文件"></a>2、aplication.yml文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///actdemo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">activiti:</span><br>    <span class="hljs-comment">#1.flase： 默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常</span><br>    <span class="hljs-comment">#2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建</span><br>    <span class="hljs-comment">#3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span><br>    <span class="hljs-comment">#4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）</span><br>    <span class="hljs-attr">database-schema-update:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#检测历史表是否存在 activiti7默认没有开启数据库历史记录 启动数据库历史记录</span><br>    <span class="hljs-attr">db-history-used:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#记录历史等级 可配置的历史级别有none, activity, audit, full</span><br>    <span class="hljs-attr">history-level:</span> <span class="hljs-string">full</span><br>    <span class="hljs-comment">#校验流程文件，默认校验resources下的processes文件夹里的流程文件</span><br>    <span class="hljs-attr">check-process-definitions:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h2 id="3、pom-xml"><a href="#3、pom-xml" class="headerlink" title="3、pom.xml"></a><strong>3、pom.xml</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- bpmn 模型处理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- bpmn 转换 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 链接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>transmittable-thread-local<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti整合Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 简介与使用</title>
    <url>/2022/01/15/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Elasticsearch-简介与使用"><a href="#Elasticsearch-简介与使用" class="headerlink" title="Elasticsearch 简介与使用"></a>Elasticsearch 简介与使用</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch: 权威指南</a></p>
<p><a href="https://blog.csdn.net/qq_37883866/article/details/106200618">ES入门</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.4/query-filter-context.html">ES6.4官方文档</a></p>
<h2 id="什么是Elastic-Search"><a href="#什么是Elastic-Search" class="headerlink" title="什么是Elastic Search"></a>什么是Elastic Search</h2><p>​    ElasticSearch 简称 ES ，是基于Apache Lucene构建的<strong>开源搜索引擎</strong>，是当前流行的企业级搜索引擎。Lucene本身就可以被认为迄今为止性能最好的一款开源搜索引擎工具包，但是lucene的API相对复杂，需要深厚的搜索理论。很难集成到实际的应用中去。但是ES是采用java语言编写，提供了简单易用的<strong>RestFul API</strong>，开发者可以使用其简单的RestFul API，开发相关的搜索功能，从而避免lucene的复杂性。</p>
<p>​    </p>
<h2 id="ES的应用场景"><a href="#ES的应用场景" class="headerlink" title="ES的应用场景"></a>ES的应用场景</h2><p>​        ES主要以轻量级JSON作为数据存储格式，它被用作<strong>全文检索</strong>、<strong>结构化搜索</strong>、<strong>分析</strong>以及这三个功能的组合（ELK）</p>
<p>​    <strong>我们本次使用主要是使用ES的结构化搜索功能来替代Mysql搜索</strong></p>
<h2 id="ES相关概念介绍"><a href="#ES相关概念介绍" class="headerlink" title="ES相关概念介绍"></a>ES相关概念介绍</h2><table>
<thead>
<tr>
<th>ES</th>
<th>Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>Index</td>
<td>数据库</td>
</tr>
<tr>
<td>Type</td>
<td>数据表</td>
</tr>
<tr>
<td>Document</td>
<td>行</td>
</tr>
<tr>
<td>Mapping</td>
<td>Schema</td>
</tr>
</tbody></table>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106005052880.png" alt="image-20220106005052880"></p>
<h3 id="1、索引（-index）"><a href="#1、索引（-index）" class="headerlink" title="1、索引（_index）"></a>1、索引（_index）</h3><p>​    类似MYSQL的数据库</p>
<h3 id="2、类型（-type）"><a href="#2、类型（-type）" class="headerlink" title="2、类型（_type）"></a>2、类型（_type）</h3><p>​    类似MYSQL的表</p>
<h3 id="3、字段（field）"><a href="#3、字段（field）" class="headerlink" title="3、字段（field）"></a>3、字段（field）</h3><p>​    类型里的字段，类似MYSQL的表字段</p>
<h3 id="4、文档（document）"><a href="#4、文档（document）" class="headerlink" title="4、文档（document）"></a>4、文档（document）</h3><p>​    类似MYSQL的行数据</p>
<h3 id="5、映射-mapping"><a href="#5、映射-mapping" class="headerlink" title="5、映射(mapping)"></a>5、映射(mapping)</h3><p>​    类似MYSQL的DDL，声明索引与类型的关系、类型与字段的关系，是json格式</p>
<h3 id="6、正向索引"><a href="#6、正向索引" class="headerlink" title="6、正向索引"></a>6、正向索引</h3><p>​    以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档，比如Mysql的B+聚餐索引<br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20211206233052712.png" alt="image-20211206233052712"></p>
<h3 id="7、倒排索引"><a href="#7、倒排索引" class="headerlink" title="7、倒排索引"></a>7、倒排索引</h3><p>​    倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况，比如ES索引结构</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /dangdang             <br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;product&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>        	<span class="hljs-attr">&quot;title&quot;</span>:    &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>  &#125;,<br>        	<span class="hljs-attr">&quot;name&quot;</span>:     &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>  &#125;,<br>       		<span class="hljs-attr">&quot;age&quot;</span>:      &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span> &#125;,<br>        	<span class="hljs-attr">&quot;created&quot;</span>:  &#123;<br>         		 <span class="hljs-attr">&quot;type&quot;</span>:   <span class="hljs-string">&quot;date&quot;</span><br>        		&#125;<br>      		&#125;<br>    	&#125;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106005312913.png" alt="image-20220106005312913"></p>
<h3 id="8、面向文档"><a href="#8、面向文档" class="headerlink" title="8、面向文档"></a>8、面向文档</h3><p>​        应用中的对象很少只是简单的键值列表，更多时候它拥有复杂的数据结构，比如包含日期、地理位置、另一个对象或者数组。<br>​        总有一天你会想到把这些对象存储到数据库中。将这些数据保存到由行和列组成的关系数据库中，就好像是把一个丰富，信息表现力强的对象拆散了放入一个非常大的表格中：你不得不拆散对象以适应表模式（通常一列表示一个字段），然后又不得不在查询的时候重建它们。<br>​        Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。</p>
<h3 id="9、节点-node-和集群-node"><a href="#9、节点-node-和集群-node" class="headerlink" title="9、节点(node)和集群(node)"></a>9、节点(node)和集群(node)</h3><p>Elasticsearch可以作为一个独立的单个搜索服务器。不过，为了能够处理大型数据集，实现容错和高可用性，Elasticsearch可以运行在许多互相合作的服务器上。这些服务器称为集群（cluster），形成集群的每个服务器称为节点（node）。</p>
<h3 id="10、分片-shards"><a href="#10、分片-shards" class="headerlink" title="10、分片(shards )"></a>10、分片(shards )</h3><p>当有大量的文档时，由于内存的限制、硬盘能力、处理能力不足、无法足够快地响应客户端请求等，一个节点可能不够。在这种情况下，数据可以分为较小的称为分片（shard）的部分（其中每个分片都是一个独立的Apache Lucene索引）。每个分片可以放在不同的服务器上，因此，数据可以在集群的节点中传播。当你查询的索引分布在多个分片上时，Elasticsearch会把查询发送给每个相关的分片，并将结果合并在一起，而应用程序并不知道分片的存在。此外，多个分片可以加快索引。</p>
<h3 id="11、副本-replicas"><a href="#11、副本-replicas" class="headerlink" title="11、副本(replicas)"></a>11、副本(replicas)</h3><p>为了提高查询吞吐量或实现高可用性，可以使用分片副本。副本（replica）只是一个分片的精确复制，每个分片可以有零个或多个副本。换句话说，Elasticsearch可以有许多相同的分片，其中之一被自动选择去更改索引操作。这种特殊的分片称为主分片（primary shard），其余称为副本分片（replica shard）。在主分片丢失时，例如该分片数据所在服务器不可用，集群将副本提升为新的主分片。</p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106010538406.png" alt="image-20220106010538406"></p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106011158094.png" alt="image-20220106011158094"></p>
<h2 id="ES查询"><a href="#ES查询" class="headerlink" title="ES查询"></a>ES查询</h2><p>​    ES官方提供了两中检索方式:一种是通过 URL 参数进行搜索,另一种是通过 DSL(Domain Specified Language) 进行搜索。官方更推荐使用第二种方式第二种方式是基于传递JSON作为请求体(request body)格式与ES进行交互，这种方式更强大，更简洁。</p>
<h1 id="ES数据同步方案"><a href="#ES数据同步方案" class="headerlink" title="ES数据同步方案"></a>ES数据同步方案</h1><h2 id="1、业务层同步"><a href="#1、业务层同步" class="headerlink" title="1、业务层同步"></a>1、业务层同步</h2><p>​    在业务层完成数据操作提交事务后，同步数据至ES，常见的做法是在ORM的hooks钩子里编写监听相关表的增删改操作落表记录，发起延时调度触发ES同步</p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/ES%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88.png"></p>
<p>优点：系统自身形成闭环，不依赖新的组件</p>
<p>缺点：ES不支持事务</p>
<p>风险点：从0到1开发，许多技术点待落实</p>
<h2 id="2、基于binlog的日志订阅"><a href="#2、基于binlog的日志订阅" class="headerlink" title="2、基于binlog的日志订阅"></a>2、基于binlog的日志订阅</h2><p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/Snipaste_2021-12-28_15-59-27.png"></p>
<p>介绍：模拟mysql原生主从模式，server端dump binlog并持久化到本地，即使源库down机，client端依然可以从server端正常接收已被持久化的binlog<br>优点：通过解析mysql的binlog同步数据的变更，适合实时性要求较高的场景<br>风险点：运维DB交互耗时<br>Binlogcenter(公司自研组件)：原理类似阿里的Canal<br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20211228164415510.png" alt="image-20211228164415510"></p>
<p><strong>MQ消费方案</strong><br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image2022-1-6_15-54-57.png" alt="image-20220106124238205"></p>
<h2 id="3、定时任务根据last-update-time字段同步"><a href="#3、定时任务根据last-update-time字段同步" class="headerlink" title="3、定时任务根据last_update_time字段同步"></a>3、定时任务根据last_update_time字段同步</h2><p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image2021-9-2_10-55-18.png"></p>
<p>缺点：数据的更新存在一定的延迟，数据的删除无法同步更新，数据最终达成一致</p>
<p>优点：实现简单粗暴</p>
<h1 id="使用ES（6-4-0）"><a href="#使用ES（6-4-0）" class="headerlink" title="使用ES（6.4.0）"></a>使用ES（6.4.0）</h1><h2 id="Spring-Data接入方式使用demo"><a href="#Spring-Data接入方式使用demo" class="headerlink" title="Spring-Data接入方式使用demo"></a>Spring-Data接入方式使用demo</h2><p>1、创建demo实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document(indexName = &quot;user-item&quot;,createIndex = false)</span><br><span class="hljs-meta">@Setting(settingPath = &quot;elasticsearch/settings.json&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsUserItem</span></span>&#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户管理事项关系(获取详情的id)id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@Field(type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String itemUserId;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;姓名&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;管理事项&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String content;<br><br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;执行状态&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Integer)</span><br>    <span class="hljs-keyword">private</span> Integer performState;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;执行开始日期&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS&quot;)</span><br>    <span class="hljs-keyword">private</span> Date performStartDate;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;执行结束日期)</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">    @Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;</span>yyyy-MM-dd HH:mm:ss<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    private Date performEndDate;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>2、创建索引+设置映射+查询语句（DSL）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /mss_user_item<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;UserItem&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;itemUserId&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;content&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performState&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performStartDate&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>,<br>          <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS||epoch_millis&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performEndDate&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>,<br>          <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS||epoch_millis&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>GET mss-user-item/UserItem/_search?<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;must&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;terms&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;performState&quot;</span>: [<br>              <span class="hljs-number">2</span>,<br>              <span class="hljs-number">3</span>,<br>              <span class="hljs-number">4</span>,<br>              <span class="hljs-number">5</span>,<br>              <span class="hljs-number">6</span>,<br>              <span class="hljs-number">1</span><br>            ],<br>            <span class="hljs-attr">&quot;boost&quot;</span>: <span class="hljs-number">1</span><br>          &#125;<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;terms&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;userName&quot;</span>: [<br>              <span class="hljs-string">&quot;李1&quot;</span>,<br>              <span class="hljs-string">&quot;李2&quot;</span>,<br>              <span class="hljs-string">&quot;李3&quot;</span>,<br>              <span class="hljs-string">&quot;李4&quot;</span>,<br>              <span class="hljs-string">&quot;李5&quot;</span>,<br>              <span class="hljs-string">&quot;李6&quot;</span><br>            ],<br>            <span class="hljs-attr">&quot;boost&quot;</span>: <span class="hljs-number">1</span><br>          &#125;<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;prefix&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;李&quot;</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        &#123;<br>         <span class="hljs-attr">&quot;wildcard&quot;</span>: &#123;<br>           <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>             <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;李*&quot;</span><br>           &#125;<br>         &#125;<br>        &#125;<br>      ],<br>      <span class="hljs-attr">&quot;filter&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;performStartDate&quot;</span>: &#123;<br>          <br>            <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-string">&quot;2022-01-06 19:26:18&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;itemUserId&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>索引文档的简单地增删改查–使用spring-data面向对象编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ItemRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">UserItem</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsertById</span><span class="hljs-params">(String indexName)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        UserItem userItem = <span class="hljs-keyword">new</span> UserItem().setItemUserId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;李&quot;</span>).setContent(<span class="hljs-string">&quot;lallala&quot;</span>)<br>                .setPerformEndDate(<span class="hljs-keyword">new</span> Date())<br>                .setPerformStartDate(<span class="hljs-keyword">new</span> Date()).setPerformState(<span class="hljs-number">1</span>);<br>        UserItem save = itemRepository.save(userItem);<br>        UserItem UserItem = itemRepository.findById(<span class="hljs-string">&quot;1&quot;</span>).orElse(<span class="hljs-keyword">null</span>);<br>        log.info(UserItem.toString());<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="XXX列表页查询接入使用"><a href="#XXX列表页查询接入使用" class="headerlink" title="XXX列表页查询接入使用"></a>XXX列表页查询接入使用</h3><p><strong>查询入参</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;deptId&quot;</span>: [<br>        <span class="hljs-number">4102</span>,<br>        <span class="hljs-number">4107</span><br>    ],<br>    <span class="hljs-attr">&quot;gradeOrRoleId&quot;</span>: [<br>        <span class="hljs-number">498</span>,<br>        <span class="hljs-number">488</span><br>    ],<br>    <span class="hljs-attr">&quot;leaderUserId&quot;</span>: [<br>        <span class="hljs-number">28</span>,<br>        <span class="hljs-number">32</span><br>    ],<br>    <span class="hljs-attr">&quot;pageIndex&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;pageSize&quot;</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">&quot;performState&quot;</span>: [<br>        <span class="hljs-number">10</span>,<br>        <span class="hljs-number">5</span>,<br>        <span class="hljs-number">15</span>,<br>        <span class="hljs-number">20</span>,<br>        <span class="hljs-number">30</span>,<br>        <span class="hljs-number">35</span><br>    ],<br>    <span class="hljs-attr">&quot;performTimeEnd&quot;</span>: <span class="hljs-string">&quot;2022-01-01&quot;</span>,<br>    <span class="hljs-attr">&quot;performTimeStart&quot;</span>: <span class="hljs-string">&quot;2021-12-01&quot;</span>,<br>    <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">28</span>,<br>    <span class="hljs-attr">&quot;employeeId&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">&quot;isPersonMark&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;isWorkMark&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;ehrEmployeeId&quot;</span>: <span class="hljs-string">&quot;111111&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>查询SQL</strong>：略</p>
<p>根据前端查询检索入参和原SQL查询条件得到索引类型结构</p>
<p>1、梳理用户点检项列表的索引字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">itemUserId <span class="hljs-comment">--用户点检id</span><br>ogDeptId <span class="hljs-comment">--部门id</span><br>leaderUserId <span class="hljs-comment">--上级id </span><br>manage_grade_id <span class="hljs-comment">--管理职级id</span><br>is_exist_personal_remark <span class="hljs-comment">--是否存在个人备注</span><br>is_exist_work_remark  <span class="hljs-comment">--是否存在工作备注</span><br>execute_role_id <span class="hljs-comment">--执行角色id</span><br>perform_start_time <span class="hljs-comment">--执行开始时间</span><br>perform_end_time <span class="hljs-comment">--执行结束时间</span><br>perform_state <span class="hljs-comment">--点检项状态</span><br></code></pre></td></tr></table></figure>

<h2 id="RestHighLevelClient接入-amp-封装"><a href="#RestHighLevelClient接入-amp-封装" class="headerlink" title="RestHighLevelClient接入&amp;封装"></a>RestHighLevelClient接入&amp;封装</h2><p>​    Java 高级 REST 客户端现在是 Elasticsearch 的默认客户端，它提供了对 TransportClient 的直接替代，因为它接受并返回完全相同的请求/响应对象，因此依赖于 Elasticsearch 核心项目。异步调用在客户端管理的线程池上进行操作，并且需要在请求完成时通知回调，总之SpringBoot项目使用它不会有那么多垃圾兼容问题</p>
<h3 id="1、说在前面"><a href="#1、说在前面" class="headerlink" title="1、说在前面"></a>1、说在前面</h3><p>1、因为博主公司对日志输出有限制，只有info级别以上的日志才会上传Kibana，所以需要对ES的日志打印进行调整</p>
<p>2、RestHighLevelClient没有提供链式调用的封装方法和字段名设置解耦（像spring-data-es封装），所以为了后续字段修改扩展和方便调用，需要对API进行一定的封装</p>
<h3 id="2、开始引入"><a href="#2、开始引入" class="headerlink" title="2、开始引入"></a>2、开始引入</h3><h4 id="1、maven依赖引入"><a href="#1、maven依赖引入" class="headerlink" title="1、maven依赖引入"></a>1、maven依赖引入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2、封装ES-Service操作接口"><a href="#2、封装ES-Service操作接口" class="headerlink" title="2、封装ES Service操作接口"></a>2、封装ES Service操作接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EsIService</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(SearchRequest searchRequest)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-function">MssRestHighLevelClient <span class="hljs-title">getRestHighLevelClient</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">lambdaQuery</span><span class="hljs-params">()</span></span>&#123;<br>        BaseEsQueryChainWrapper&lt;T&gt; wrapper = <span class="hljs-keyword">new</span> BaseEsQueryChainWrapper&lt;&gt;();<br>        wrapper.setIndex(getIndex());<br>        wrapper.setType(getType());<br>        wrapper.setClazz(getClazz());<br>        wrapper.setRestHighLevelClient(getRestHighLevelClient());<br>        <span class="hljs-keyword">return</span> wrapper;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getClazz</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsIServiceImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">EsIService</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<span class="hljs-comment">//记录T的Class</span><br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; clazz;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MssRestHighLevelClient mssRestHighLevelClient;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EsIServiceImpl</span><span class="hljs-params">()</span> </span>&#123;<br>      clazz = (Class)((ParameterizedType) <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">doSearch</span><span class="hljs-params">(SearchRequest searchRequest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        SearchResponse search = mssRestHighLevelClient.search(searchRequest);<br>        List&lt;T&gt; list = Stream.of(search.getHits().getHits()).map(e -&gt; <span class="hljs-keyword">new</span> JSONObject(e.getSourceAsMap()).toJavaObject(clazz)).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MssRestHighLevelClient <span class="hljs-title">getRestHighLevelClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mssRestHighLevelClient;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mss-user-item&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mssesuseritem&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-title">getClazz</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、封装Lambda调用-举例封装must、should、filter"><a href="#3、封装Lambda调用-举例封装must、should、filter" class="headerlink" title="3、封装Lambda调用(举例封装must、should、filter)"></a>3、封装Lambda调用(举例封装must、should、filter)</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ColumnFunction</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt;, <span class="hljs-title">Serializable</span></span>&#123;<br><br>&#125;<br><span class="hljs-comment">//根据传进来的get方法获取字段属性名</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColumnUtil</span></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GET = <span class="hljs-string">&quot;get&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;?,?&gt; fn)</span></span>&#123;<br>        Method writeReplaceMethod;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeReplaceMethod = fn.getClass().getDeclaredMethod(<span class="hljs-string">&quot;writeReplace&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;es入参序列化失败,e&quot;</span>,e);<br>        &#125;<br><br>        ReflectionUtils.makeAccessible(writeReplaceMethod);<br>        SerializedLambda serializedLambda;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serializedLambda = (SerializedLambda) writeReplaceMethod.invoke(fn);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;es入参序列化失败,e&quot;</span>,e);<br>        &#125;<br><br>        <span class="hljs-comment">// 从lambda信息取出methodName</span><br>        String implMethodName = serializedLambda.getImplMethodName();<br>        <span class="hljs-comment">// 确保方法是符合规范的get方法</span><br>        <span class="hljs-keyword">if</span> (!implMethodName.startsWith(GET)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;只允许传入get方法: &quot;</span> + implMethodName);<br>        &#125;<br><br>        String fieldName = implMethodName.substring(GET.length());<br>        String firstChar = fieldName.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        fieldName = fieldName.replaceFirst(firstChar, firstChar.toLowerCase());<br>        <span class="hljs-keyword">return</span> fieldName;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//链式调用构造SearchRequest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEsQueryChainWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">protected</span> SearchSourceBuilder builder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>    <span class="hljs-keyword">protected</span> MssRestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-keyword">protected</span> String index;<br>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br><br>    <span class="hljs-keyword">protected</span> String type;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClazz</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;T,?&gt; fn)</span></span>&#123;<br>        String column = ColumnUtil.getColumn(fn);<br>        <span class="hljs-keyword">return</span> column;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRestHighLevelClient</span><span class="hljs-params">(MssRestHighLevelClient restHighLevelClient)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = restHighLevelClient;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIndex</span><span class="hljs-params">(String index)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseEsQueryChainWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.query(QueryBuilders.boolQuery());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">mustEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.must(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">filterEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.filter(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">shouldEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.should(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">nestedMustEq</span><span class="hljs-params">(BoolQueryBuilder nestedQueryBuilder)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.must(nestedQueryBuilder);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SearchRequest <span class="hljs-title">getSearchRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(index);<br>        request.types(type);<br>        request.source(builder);<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//嵌套链式调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseNestedEsQueryChainWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); ;<br><br>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClazz</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;T,?&gt; fn)</span></span>&#123;<br>        String column = ColumnUtil.getColumn(fn);<br>        <span class="hljs-keyword">return</span> column;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">mustEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.must(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">filterEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.filter(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">shouldEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.should(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BoolQueryBuilder <span class="hljs-title">getBoolQueryBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boolQueryBuilder;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="4、日志切面"><a href="#4、日志切面" class="headerlink" title="4、日志切面"></a>4、日志切面</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order</span><br><span class="hljs-meta">@Profile(&#123;&quot;local&quot;, &quot;dev&quot;, &quot;test&quot;, &quot;ys&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsLogAspect</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Integer PRINT_LIMIT = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//切EsIServiceImpl的do开头的方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * *.EsIServiceImpl.do*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取切入点的方法参数</span><br>        Object[] args = point.getArgs();<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> SearchRequest) &#123;<br>                SearchRequest searchRequest = (SearchRequest) arg;<br>                log.info(<span class="hljs-string">&quot;ES查询参数：&#123;&#125;&quot;</span>, searchRequest);<br>            &#125;<br>        &#125;<br><br>        Object ret = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>            ret = point.proceed();<br>            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>            <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> SearchResponse) &#123;<br>                SearchResponse searchResponse = (SearchResponse) ret;<br>                Aggregations aggs = searchResponse.getAggregations();<br>                SearchHit[] hits = searchResponse.getHits().getHits();<br>                <span class="hljs-comment">// 防止查询出来的记录数太多打印不了，最多打印10条</span><br>                <span class="hljs-keyword">int</span> toIndex = hits.length &gt; PRINT_LIMIT? PRINT_LIMIT:  hits.length;<br>                List&lt;SearchHit&gt; hitList = Arrays.stream(hits).limit(toIndex).collect(Collectors.toList());<br>                String data = hitList.stream().map(SearchHit::getSourceAsString).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>                log.info(<span class="hljs-string">&quot;ES查询耗时：&#123;&#125;ms, ES查询结果：contents=&#123;&#125;, 聚合结果：aggregations=&#123;&#125;&quot;</span>,<br>                        end - start, data, aggs == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : JSON.toJSON(aggs.asList()));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                log.info(<span class="hljs-string">&quot;ES查询耗时：&#123;&#125;ms, ES查询结果：contents=&#123;&#125;&quot;</span>,end - start,ret);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            log.error(<span class="hljs-string">&quot;ES请求错误：&#123;&#125;&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;ES请求错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5、测试类"><a href="#5、测试类" class="headerlink" title="5、测试类"></a>5、测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemEsMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EsIServiceImpl</span>&lt;<span class="hljs-title">MssEsUserItem</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String index,String type)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//原生构造</span><br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(index);<br>        request.types(type);<br>        SearchSourceBuilder builder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>        BoolQueryBuilder query = QueryBuilders.boolQuery();<br>        query.filter(QueryBuilders.termsQuery(<span class="hljs-string">&quot;itemUserId&quot;</span>, Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)));<br>        query.must(QueryBuilders.prefixQuery(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;李&quot;</span>));<br>        query.must(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;itemUserId&quot;</span>).lte(<span class="hljs-number">9</span>).gte(<span class="hljs-number">1</span>));<br>        builder.query(query);<br>        builder.from(<span class="hljs-number">0</span>).size(<span class="hljs-number">10</span>);<br>        builder.sort(<span class="hljs-string">&quot;itemUserId&quot;</span>);<br>        builder.aggregation(AggregationBuilders.count(<span class="hljs-string">&quot;userName&quot;</span>).field(<span class="hljs-string">&quot;userName&quot;</span>));<br>        request.source(builder);<br>        List&lt;MssEsUserItem&gt; search = itemEsMapper.doSearch(request);<br>        <span class="hljs-comment">//链式构造</span><br>        BoolQueryBuilder nested = itemEsMapper.lambdaNestedQuery().shouldEq(MssEsUserItem::getUserName, <span class="hljs-string">&quot;李1&quot;</span>).shouldEq(MssEsUserItem::getUserName, <span class="hljs-string">&quot;李2&quot;</span>).getBoolQueryBuilder();<br>        SearchRequest searchRequest = itemEsMapper.lambdaQuery()<br>                .mustEq(MssEsUserItem::getItemUserId, <span class="hljs-number">1L</span>).nestedMustEq(nested).getSearchRequest();<br>        List&lt;MssEsUserItem&gt; list = itemEsMapper.doSearch(searchRequest);<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试接口</span><br><span class="hljs-meta">@PostMapping(value = &quot;/testQuery&quot;)</span><br><span class="hljs-meta">@Menu(MenuConfig.DATA_REPAIR)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;测试查询&quot;, notes = &quot; 测试查询&quot;)</span><br><span class="hljs-keyword">public</span> Response&lt;PageResult&lt;MssEsUserItem&gt;&gt; testQuery(<span class="hljs-meta">@RequestBody</span> VisitTagDTO visitTagDTO) <span class="hljs-keyword">throws</span> IOException &#123;<br>    esTestService.test(<span class="hljs-string">&quot;mss-user-item&quot;</span>,<span class="hljs-string">&quot;mssesuseritem&quot;</span>);<br>    <span class="hljs-keyword">return</span> RestResponse.buildSuccessInfo(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、单次查询数量 form+size不大于5k</p>
<blockquote>
<p>假如每页是 10 条数据，现在要查询第 100 页的10条数据，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上。如果有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<p>ES作为分布式程序，要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据，必须得从每个 shard 都查 1000 条数据过来，然后根据的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，所以用 es 做分页的时候，会发现越翻到后面，就越是慢。</p>
<p>解决方案：</p>
<ol>
<li><p>不允许深度分页。（目前使用的是这种方法）</p>
</li>
<li><p>scroll api</p>
<p>scroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。但是这一种不能随意跳到任何一页。</p>
</li>
<li><p>search_after</p>
<p>search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>
</li>
</ol>
</blockquote>
<p>2、禁用 wildcard（keyword前后模糊必须使用）</p>
<p>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword</p>
<p>4、尽可能使用filter而不是query，但是要避免filter cache过大导致jvm飙升</p>
<p>5、做好索引重建的准备（起别名）</p>
<p>6、 java使用es的客户端时，不要使用TransportClient sdk啦。直接使用high level rest client以及low level rest client就好了。（如果不看文档，很多人直接选择 TransportClient ，里面好多query dsl的java类，刚刚接触可能选择这个了，但，这个7.0时就被废弃了；8.0之后直接就删除了） </p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus</title>
    <url>/2021/05/25/Mybatis-plus/</url>
    <content><![CDATA[<h1 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h1><p>1、Mybatis-plus的介绍</p>
<p>2、Mybatis-plus自定义插件开发</p>
<h1 id="Mybatis-plus的介绍"><a href="#Mybatis-plus的介绍" class="headerlink" title="Mybatis-plus的介绍"></a>Mybatis-plus的介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus （简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>强大的crud</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持lambda链式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错，方便数据库字段修改</li>
<li><strong>内置代码生成器</strong></li>
<li><strong>内置分页插件</strong></li>
<li><strong>内置性能分析插件</strong>：下文中提及</li>
<li><strong>内置全局拦截插件</strong>：下文中提及</li>
</ul>
<h2 id="SpringBoot整合引入"><a href="#SpringBoot整合引入" class="headerlink" title="SpringBoot整合引入"></a>SpringBoot整合引入</h2><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-springboot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-plus-springboot<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql数据源配置</span><br><span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.url</span>= <span class="hljs-string">jdbc:mysql:///mybatis-study</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-meta">mybatis-plus.mapper-locations</span>=<span class="hljs-string">classpath:mapper/system/repository/dao/**/*.xml</span><br><span class="hljs-meta">mybatis-plus.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.study.domain.*.dao&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootClass.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="内置代码生成器"><a href="#内置代码生成器" class="headerlink" title="内置代码生成器"></a>内置代码生成器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisGenerator</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 读取控制台内容</span><br><span class="hljs-comment">     * &lt;/p&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();<br>        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);<br>        System.out.println(help.toString());<br>        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;<br>            String ipt = scanner.next();<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;<br>                <span class="hljs-keyword">return</span> ipt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 代码生成器</span><br>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<br><br>        <span class="hljs-comment">// 全局配置</span><br>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();<br>        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<br>        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/mybatis-plus-springboot/src/main/java&quot;</span>);<br>        gc.setAuthor(<span class="hljs-string">&quot;24khandsome&quot;</span>);<br>        gc.setOpen(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// XML 二级缓存</span><br>        gc.setEnableCache(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 自定义文件命名，注意 %s 会自动填充表实体属性！</span><br>        gc.setEntityName(<span class="hljs-string">&quot;%sPO&quot;</span>);<br>        gc.setMapperName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        gc.setXmlName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<br>        gc.setServiceImplName(<span class="hljs-string">&quot;%sServiceImpl&quot;</span>);<br>        gc.setControllerName(<span class="hljs-string">&quot;%sController&quot;</span>);<br>        gc.setXmlName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        mpg.setGlobalConfig(gc);<br><br>        <span class="hljs-comment">// 数据源配置</span><br>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();<br>        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql:///mybatis-study?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);<br>        <span class="hljs-comment">// dsc.setSchemaName(&quot;public&quot;);</span><br>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        mpg.setDataSource(dsc);<br><br>        <span class="hljs-comment">// 包配置</span><br>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();<br>        pc.setModuleName(scanner(<span class="hljs-string">&quot;模块名&quot;</span>));<br>        pc.setEntity(<span class="hljs-string">&quot;entity.po&quot;</span>);<br>        pc.setMapper(<span class="hljs-string">&quot;dao&quot;</span>);<br>        pc.setController(<span class="hljs-string">&quot;api&quot;</span>);<br>        pc.setParent(<span class="hljs-string">&quot;com.study.domain&quot;</span>);<br>        mpg.setPackageInfo(pc);<br><br>        <span class="hljs-comment">// 自定义配置</span><br>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// to do nothing</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 如果模板引擎是 freemarker</span><br>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.ftl&quot;</span>;<br>        <span class="hljs-comment">// 如果模板引擎是 velocity</span><br>        <span class="hljs-comment">// String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><br>        <span class="hljs-comment">// 自定义输出配置</span><br>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 自定义配置会被优先输出</span><br>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;<br>                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/mybatis-plus-springboot/src/main/resources/mapper/&quot;</span> + pc.getModuleName()<br>                        + <span class="hljs-string">&quot;/repository/dao/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;<br>            &#125;<br>        &#125;);<br><br>        cfg.setFileOutConfigList(focList);<br>        mpg.setCfg(cfg);<br><br>        <span class="hljs-comment">// 配置模板</span><br>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();<br><br>        <span class="hljs-comment">// 配置自定义输出模板</span><br>        <span class="hljs-comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span><br>        <span class="hljs-comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span><br>        <span class="hljs-comment">// templateConfig.setService();</span><br>        <span class="hljs-comment">// templateConfig.setController();</span><br><br>        templateConfig.setXml(<span class="hljs-keyword">null</span>);<br>        mpg.setTemplate(templateConfig);<br>        <span class="hljs-comment">// 选择 freemarker 引擎，默认 Veloctiy</span><br>        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<br>        <span class="hljs-comment">// 策略配置</span><br>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();<br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br><br>        strategy.setSuperEntityClass(BasePO.class);<br>        strategy.setSuperEntityColumns(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-string">&quot;create_user&quot;</span>, <span class="hljs-string">&quot;update_time&quot;</span>,<br>                <span class="hljs-string">&quot;update_user&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;is_delete&quot;</span>, <span class="hljs-string">&quot;last_update_time&quot;</span>);<br>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);<br>        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 公共父类</span><br>        <span class="hljs-comment">//strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span><br>        strategy.setInclude(scanner(<span class="hljs-string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));<br>        strategy.setTablePrefix(pc.getModuleName() + <span class="hljs-string">&quot;_&quot;</span>);<br>        mpg.setStrategy(strategy);<br>        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<br>        mpg.execute();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePO</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(value = &quot;create_user&quot;, fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Long createUser;<br>    <span class="hljs-meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(value = &quot;update_user&quot;, fill = FieldFill.UPDATE)</span><br>    <span class="hljs-keyword">private</span> Long updateUser;<br>    <span class="hljs-meta">@TableField(value = &quot;update_time&quot;, fill = FieldFill.UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Version</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否删除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;is_delete&quot;)</span><br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer isDelete;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除字段枚举</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Delete</span> </span>&#123;<br>        <span class="hljs-comment">//删除枚举</span><br>        NORMAL(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;正常&quot;</span>), DELETED(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;删除&quot;</span>);<br>        <span class="hljs-meta">@Getter</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer code;<br>        <span class="hljs-meta">@Getter</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>        Delete(Integer code, String name) &#123;<br>            <span class="hljs-keyword">this</span>.code = code;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Delete <span class="hljs-title">getDelete</span><span class="hljs-params">(Integer state)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (Delete delete : values()) &#123;<br>                <span class="hljs-keyword">if</span> (delete.getCode().equals(state)) &#123;<br>                    <span class="hljs-keyword">return</span> delete;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/images/Mybatis-plus/image-20210529174638703.png" alt="image-20210529174638703"></p>
<h2 id="自定义SQL语句模板（Sql-注入器）"><a href="#自定义SQL语句模板（Sql-注入器）" class="headerlink" title="自定义SQL语句模板（Sql 注入器）"></a>自定义SQL语句模板（Sql 注入器）</h2><p>参考：<a href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-deluxe">https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-deluxe</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">1.</span>自定义方法<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDeleteAllMethod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMethod</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MappedStatement <span class="hljs-title">injectMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;<br>        String sql;<br>        String sqlMethod = <span class="hljs-string">&quot;&lt;script&gt;\nDELETE FROM %s \n&lt;/script&gt;&quot;</span>;<br>        sql = String.format(sqlMethod, tableInfo.getTableName(), sqlLogicSet(tableInfo),<br>                sqlWhereEntityWrapper(<span class="hljs-keyword">true</span>, tableInfo),<br>                sqlComment());<br>        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addDeleteMappedStatement(mapperClass, <span class="hljs-string">&quot;deleteAll&quot;</span>, sqlSource);<br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>自定义SqlInjector，注册自定义方法<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLogicSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultSqlInjector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;AbstractMethod&gt; <span class="hljs-title">getMethodList</span><span class="hljs-params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;<br>        List&lt;AbstractMethod&gt; list = <span class="hljs-keyword">super</span>.getMethodList(mapperClass);<br>        list.add(<span class="hljs-keyword">new</span> MyTruncateMethod());<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">3.</span>把方法定义到BaseMapper<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyBaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-number">4</span>、mapper继承自己的basemapper<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyBaseMapper</span>&lt;<span class="hljs-title">UserPO</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">UserPO <span class="hljs-title">selectOneUserByName</span><span class="hljs-params">(String userName)</span></span>;<br><br>    <span class="hljs-function">List&lt;UserPO&gt; <span class="hljs-title">findPageUser</span><span class="hljs-params">(Page&lt;UserPO&gt; page)</span></span>;<br>&#125;<br><br><span class="hljs-number">5</span>、覆盖全局SQL注入器配置<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">myLogicSqlInjector</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyLogicSqlInjector();<br>    &#125;<br>&#125;<br><span class="hljs-number">6</span>、使用<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserDao</span>, <span class="hljs-title">UserPO</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.deleteAll();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="内置性能分析插件"><a href="#内置性能分析插件" class="headerlink" title="内置性能分析插件"></a>内置性能分析插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HIKARIPROXY_PREPARED_STATEMENT = <span class="hljs-string">&quot;com.zaxxer.hikari.pool.HikariProxyPreparedStatement&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> SqlFormatter SQL_FORMATTER = <span class="hljs-keyword">new</span> SqlFormatter();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 格式sql</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> boundSql</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sqlFormat</span><span class="hljs-params">(String boundSql, <span class="hljs-keyword">boolean</span> format)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (format) &#123;<br>            <span class="hljs-keyword">return</span> SQL_FORMATTER.format(boundSql);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> boundSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 执行最大时长，超过自动停止运行，有助于发现问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 是否格式化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> format = <span class="hljs-keyword">false</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Statement statement;<br>        Object firstArg = invocation.getArgs()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(firstArg.getClass())) &#123;<br>            statement = (Statement) SystemMetaObject.forObject(firstArg).getValue(<span class="hljs-string">&quot;h.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            statement = (Statement) firstArg;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            statement = (Statement) SystemMetaObject.forObject(statement).getValue(<span class="hljs-string">&quot;stmt.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br><br>        String originalSql = <span class="hljs-keyword">null</span>;<br>        String stmtClassName = statement.getClass().getName();<br>        <span class="hljs-keyword">if</span> (HIKARIPROXY_PREPARED_STATEMENT.equals(stmtClassName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(HIKARIPROXY_PREPARED_STATEMENT);<br>                Method druidGetSqlMethod = clazz.getMethod(<span class="hljs-string">&quot;getSql&quot;</span>);<br>                Object stmtSql = druidGetSqlMethod.invoke(statement);<br>                <span class="hljs-keyword">if</span> (stmtSql != <span class="hljs-keyword">null</span> &amp;&amp; stmtSql <span class="hljs-keyword">instanceof</span> String) &#123;<br>                    originalSql = (String) stmtSql;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (originalSql == <span class="hljs-keyword">null</span>) &#123;<br>            originalSql = statement.toString();<br>        &#125;<br>        originalSql = originalSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">int</span> index = originalSql.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            originalSql = originalSql.substring(index + <span class="hljs-number">1</span>, originalSql.length());<br>        &#125;<br>        String sqlFormat = sqlFormat(originalSql, format);<br>        Object target = realTarget(invocation.getTarget());<br>        MetaObject metaObject = SystemMetaObject.forObject(target);<br>        MappedStatement ms = (MappedStatement) metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>        Logger mybatisLogger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br>        <span class="hljs-comment">// 计算执行 SQL 耗时</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = invocation.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">long</span> timing =  System.currentTimeMillis() - start;<br>            StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder()<br>                    .append(<span class="hljs-string">&quot;execute sql error, use time：&quot;</span>).append(timing).append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                    .append(sqlFormat);<br>            mybatisLogger.error(formatSql.toString());<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <span class="hljs-keyword">long</span> timing = System.currentTimeMillis() - start;<br><br>        <span class="hljs-comment">// 格式化 SQL 打印执行结果</span><br>        StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;Execute sql use time：&quot;</span>).append(timing)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; Execute SQL：&quot;</span>).append(sqlFormat)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; result: &quot;</span>).append(result);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMaxTime() &gt;= <span class="hljs-number">1</span> &amp;&amp; timing &gt; <span class="hljs-keyword">this</span>.getMaxTime()) &#123;<br>            mybatisLogger.error(formatSql.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mybatisLogger.debug(formatSql.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> StatementHandler) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties prop)</span> </span>&#123;<br>        String maxTime = prop.getProperty(<span class="hljs-string">&quot;maxTime&quot;</span>);<br>        String format = prop.getProperty(<span class="hljs-string">&quot;format&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(maxTime)) &#123;<br>            <span class="hljs-keyword">this</span>.maxTime = Long.parseLong(maxTime);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(format)) &#123;<br>            <span class="hljs-keyword">this</span>.format = Boolean.valueOf(format);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">realTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(target.getClass())) &#123;<br>            MetaObject metaObject = SystemMetaObject.forObject(target);<br>            <span class="hljs-keyword">return</span> realTarget(metaObject.getValue(<span class="hljs-string">&quot;h.target&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) target;<br>    &#125;<br><br>&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PerformanceInterceptor <span class="hljs-title">performanceInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PerformanceInterceptor();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="事务检查插件"><a href="#事务检查插件" class="headerlink" title="事务检查插件"></a>事务检查插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisUpdateCheckInterceptor <span class="hljs-title">mybatisUpdateCheckInterceptor</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MybatisUpdateCheckInterceptor(dataSource);<br>&#125;<br><span class="hljs-meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUpdateCheckInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MybatisUpdateCheckInterceptor</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataSource = dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>        <span class="hljs-comment">// 检查事务是否开启</span><br>        assertTransactional();<br><br>        Object[] args = invocation.getArgs();<br>        MappedStatement ms = (MappedStatement) args[<span class="hljs-number">0</span>];<br>        SqlCommandType sqlCommandType = ms.getSqlCommandType();<br><br>        Object param = args[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 插入只判断是否插入成功即可</span><br>        <span class="hljs-keyword">if</span> (SqlCommandType.INSERT == sqlCommandType) &#123;<br>            checkParam(param);<br>            Object proceed = invocation.proceed();<br>            validateReturnGtZero(proceed);<br>            <span class="hljs-keyword">return</span> proceed;<br>        &#125;<br>        Object proceed = invocation.proceed();<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验是否已经开启事务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertTransactional</span><span class="hljs-params">()</span> </span>&#123;<br>        Connection connection = DataSourceUtils.getConnection(dataSource);<br>        <span class="hljs-keyword">if</span> (!DataSourceUtils.isConnectionTransactional(connection, dataSource)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis can not update without transactional&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查参数是否非空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkParam</span><span class="hljs-params">(Object param)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == param) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis update can not insert null object&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验更新数量是否大于0</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proceed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateReturnGtZero</span><span class="hljs-params">(Object proceed)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(proceed <span class="hljs-keyword">instanceof</span> Number)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis update return is not a number&quot;</span>);<br>        &#125;<br><br>        Number result = (Number) proceed;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0L</span> == result.longValue()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;数据已被他人修改，请刷新重试&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="动态表名插件-since-3-4-0"><a href="#动态表名插件-since-3-4-0" class="headerlink" title="动态表名插件(since 3.4.0)"></a>动态表名插件(since 3.4.0)</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>    MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    DynamicTableNameInnerInterceptor interceptor = <span class="hljs-keyword">new</span> DynamicTableNameInnerInterceptor();<br>    <span class="hljs-keyword">int</span> b=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">3</span>);<br>    String[] table = &#123;<span class="hljs-string">&quot;system_user&quot;</span>,<span class="hljs-string">&quot;system_user_copy1&quot;</span>,<span class="hljs-string">&quot;system_user_copy2&quot;</span>&#125;;<br>    Map&lt;String, TableNameHandler&gt; tableNameHandlerMap = <span class="hljs-keyword">new</span> HashMap&lt;String,TableNameHandler&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//自定义逻辑，用新的表明替换旧的表名</span><br>    tableNameHandlerMap.put(<span class="hljs-string">&quot;system_user&quot;</span>,((sql,tablename) -&gt; table[b]));<br>    interceptor.setTableNameHandlerMap(tableNameHandlerMap);<br>    <span class="hljs-comment">//tableNameHandlerMap.put(&quot;system_user&quot;,((sql,tablename) -&gt; tablename +table[b]));</span><br>    mybatisPlusInterceptor.addInnerInterceptor(interceptor);<br>    <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多租户（约等于数据隔离、也可作为权限过滤）"><a href="#多租户（约等于数据隔离、也可作为权限过滤）" class="headerlink" title="多租户（约等于数据隔离、也可作为权限过滤）"></a>多租户（约等于数据隔离、也可作为权限过滤）</h2><blockquote>
<p>多租户 != 权限过滤,不要乱用,租户之间是完全隔离的!!!<br>启用多租户后所有执行的method的sql都会进行处理.<br>自写的sql请按规范书写(sql涉及到多个表的每个表都要给别名,特别是 inner join 的要写标准的 inner join)</p>
</blockquote>
<p>假设有如下场景：</p>
<p>查询某些表的数据需要根据这些表的某个字段进行数据隔离</p>
<p>于是</p>
<blockquote>
<ol>
<li>自定义TenantHandler</li>
<li>自定义MyTenantSqlParser</li>
<li>注册多租户组件</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataAccessTable</span> </span>&#123;<br>    <span class="hljs-comment">//数据权限过滤表名</span><br>    SYSTEM_USER(<span class="hljs-string">&quot;system_user&quot;</span>, <span class="hljs-string">&quot;用户表&quot;</span>, <span class="hljs-string">&quot;user_id&quot;</span>),<br>    ;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, DataAccessTable&gt; TABLE_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (DataAccessTable value : DataAccessTable.values()) &#123;<br>            TABLE_MAP.put(value.getTableName(), value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tableName;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String publisherColumn;<br><br>    DataAccessTable(String tableName, String desc, String publisherColumn) &#123;<br>        <span class="hljs-keyword">this</span>.tableName = tableName;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>        <span class="hljs-keyword">this</span>.publisherColumn = publisherColumn;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">getDataAccessTables</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> TABLE_MAP.keySet();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDataPublisherColumn</span><span class="hljs-params">(String tableName)</span></span>&#123;<br>        DataAccessTable dataAccessTable = TABLE_MAP.get(tableName);<br>        <span class="hljs-keyword">return</span> dataAccessTable == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : dataAccessTable.getPublisherColumn();<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyTenantHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TenantHandler</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义方法</span><br><span class="hljs-comment">     * 获取发布人用户ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tableName 表名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 发布人字段名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getPublishUserIdColumn</span><span class="hljs-params">(String  tableName)</span></span>;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTenantSqlParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TenantSqlParser</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> MyTenantHandler greatTenantHandler;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TenantSqlParser <span class="hljs-title">setTenantHandler</span><span class="hljs-params">(TenantHandler tenantHandler)</span> </span>&#123;<br>        greatTenantHandler = (MyTenantHandler) tenantHandler;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setTenantHandler(tenantHandler);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 目前: 针对自定义的tenantId的条件表达式[tenant_id in (1,2,3)]，无法处理多租户的字段加上表别名</span><br><span class="hljs-comment">     * select a.id, b.name</span><br><span class="hljs-comment">     * from a</span><br><span class="hljs-comment">     * join b on b.aid = a.id and [b.]tenant_id in (1,2) --别名[b.]无法加上 TODO</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expression</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> table</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加上别名的多租户字段表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Expression <span class="hljs-title">processTableAlias4CustomizedTenantIdExpression</span><span class="hljs-params">(Expression expression, Table table)</span> </span>&#123;<br>        Expression target;<br>        <span class="hljs-comment">//判断多租户字段</span><br>        <span class="hljs-keyword">if</span> (expression <span class="hljs-keyword">instanceof</span> ValueListExpression) &#123;<br>            InExpression inExpression = <span class="hljs-keyword">new</span> InExpression();<br>            inExpression.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, greatTenantHandler.getTenantIdColumn()));<br>            inExpression.setRightItemsList(((ValueListExpression) expression).getExpressionList());<br>            target = inExpression;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            EqualsTo equalsTo = <span class="hljs-keyword">new</span> EqualsTo();<br>            equalsTo.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, greatTenantHandler.getTenantIdColumn()));<br>            equalsTo.setRightExpression(expression);<br>            target = equalsTo;<br>        &#125;<br>        String publishUserIdColumn = greatTenantHandler.getPublishUserIdColumn(table.getName());<br>        <span class="hljs-keyword">if</span>(StringUtils.isBlank(publishUserIdColumn))&#123;<br>           <span class="hljs-keyword">return</span> target;<br>        &#125;<br>        <span class="hljs-comment">//自定义多租户逻辑</span><br>        EqualsTo equalsTo = <span class="hljs-keyword">new</span> EqualsTo();<br>        equalsTo.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, publishUserIdColumn));<br>        <span class="hljs-comment">//自定义多租户字段写死 -1</span><br>        equalsTo.setRightExpression(<span class="hljs-keyword">new</span> LongValue(<span class="hljs-string">&quot;8&quot;</span>));<br>        <span class="hljs-comment">// equalsTo.setRightExpression(new LongValue(SessionContext.getCurrentUserId()));</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Parenthesis(<span class="hljs-keyword">new</span> OrExpression(target, equalsTo));<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 租户字段别名设置</span><br><span class="hljs-comment">     * &lt;p&gt;tenantId 或 tableAlias.tenantId&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> table 表对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 字段</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Column <span class="hljs-title">getTableAliasColumn</span><span class="hljs-params">(Table table, String columnName)</span> </span>&#123;<br>        StringBuilder column = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (table.getAlias() != <span class="hljs-keyword">null</span>) &#123;<br>            column.append(table.getAlias().getName()).append(StringPool.DOT);<br>        &#125;<br>        column.append(columnName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Column(column.toString());<br>    &#125;<br>&#125;<br><br><br>	<span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        PaginationInterceptor page = <span class="hljs-keyword">new</span> PaginationInterceptor();<br>        List&lt;ISqlParser&gt; sqlParserList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        MyTenantSqlParser tenantSqlParser = <span class="hljs-keyword">new</span> MyTenantSqlParser();<br>        tenantSqlParser.setTenantHandler(<span class="hljs-keyword">new</span> MyTenantHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPublishUserIdColumn</span><span class="hljs-params">(String tableName)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> DataAccessTable.getDataPublisherColumn(tableName);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Expression <span class="hljs-title">getTenantId</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> select)</span> </span>&#123;<br>                <span class="hljs-comment">//没有设置数据权限，设置为本中心数据权限</span><br>                ValueListExpression expression = <span class="hljs-keyword">new</span> ValueListExpression();<br>                List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                expressions.add(<span class="hljs-keyword">new</span> StringValue(<span class="hljs-string">&quot;木子李&quot;</span>));<br><br><br>                expression.setExpressionList(<span class="hljs-keyword">new</span> ExpressionList(expressions));<br>                <span class="hljs-keyword">return</span> expression;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTenantIdColumn</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;username&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回true忽略，false需要解析多租户字段</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> tableName</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doTableFilter</span><span class="hljs-params">(String tableName)</span> </span>&#123;<br>                <span class="hljs-comment">//查询所有进行数据权限过滤的表名</span><br>                Set&lt;String&gt; tableNameSet = DataAccessTable.getDataAccessTables();<br>                <span class="hljs-comment">// 强制检查表单内，返回false</span><br>                <span class="hljs-keyword">if</span> (tableNameSet.contains(tableName)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;);<br>        sqlParserList.add(tenantSqlParser);<br>        page.setSqlParserList(sqlParserList);<br>        page.setSqlParserFilter(metaObject -&gt;&#123;<br>            <span class="hljs-comment">// 不处理非select之外的语句</span><br>            MappedStatement mappedStatement = (MappedStatement)metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>            <span class="hljs-keyword">if</span>(!SqlCommandType.SELECT.equals(mappedStatement.getSqlCommandType()))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>效果</p>
<p><img src="/images/Mybatis-plus/image-20210531170508023.png" alt="image-20210531170508023"></p>
]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>myBatis缓存与动态SQL</title>
    <url>/2021/05/11/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h1><ol>
<li>1,2级缓存处理</li>
<li>动态化SQL</li>
</ol>
<h1 id="一、1-2级缓存处理"><a href="#一、1-2级缓存处理" class="headerlink" title="一、1,2级缓存处理"></a>一、1,2级缓存处理</h1><hr>
<p>知识点：</p>
<p>1级缓存使用场景</p>
<p>2级缓存使用场景</p>
<h2 id="1、1级缓存使用场景"><a href="#1、1级缓存使用场景" class="headerlink" title="1、1级缓存使用场景"></a>1、1级缓存使用场景</h2><p>订单表与会员表是存在一对多的关系，为了尽可能减少join 查询，进行了分阶段查询，即先查询出订单表，在根据member_id 字段查询出会员表，最后进行数据整合 。如果订单表中存在重复的member_id，就会出现很多没必要的重复查询。</p>
<p>​    针对这种情况myBatis 通过1级缓存来实现，在同一次查询会话中如果出现相同的语句及参数，就会从缓存中取出不在走数据库查询。</p>
<p>​    1级缓存只能作用于<strong>查询会话</strong>中 所以也叫做**==会话缓存==。**</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>  <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(Integer id)</span></span>;<br><br>  <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;<br><br>  <span class="hljs-meta">@Update(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SqlSession sqlSession = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> SqlSession sqlSession2 = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream = MainTest.class.getClassLoader().getResourceAsStream(resource);<br>        SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>        sqlSession = sqlSessionFactory.openSession();<br>        sqlSession2 = sqlSessionFactory.openSession();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test00</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//原始用法</span><br>        User user = (User)sqlSession.selectOne(<span class="hljs-string">&quot;com.study.mapper.UserMapper.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        User user3 = mapper.selectById(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user3);<br>        System.out.println(user2==user1);<br>        System.out.println(user3==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        User user2 = mapper2.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        UserMapper2 mapper2 = sqlSession.getMapper(UserMapper2.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询结束======================&quot;</span>);<br>        User user2 = mapper2.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        sqlSession.clearCache();<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        mapper.updateById(<span class="hljs-number">1</span>);<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>一级缓存的使用条件：</p>
<h3 id="1-必须是相同的SQL和参数"><a href="#1-必须是相同的SQL和参数" class="headerlink" title="1.必须是相同的SQL和参数"></a>1.必须是相同的SQL和参数</h3><h3 id="2-必须是相同的statement-即同一个mapper-接口中的同一个方法"><a href="#2-必须是相同的statement-即同一个mapper-接口中的同一个方法" class="headerlink" title="2.必须是相同的statement 即同一个mapper 接口中的同一个方法"></a>2.必须是相同的statement 即同一个mapper 接口中的同一个方法</h3><h3 id="3-必须是相同的会话"><a href="#3-必须是相同的会话" class="headerlink" title="3.必须是相同的会话"></a>3.必须是相同的会话</h3><h3 id="4-查询语句中间没有执行session-clearCache-方法"><a href="#4-查询语句中间没有执行session-clearCache-方法" class="headerlink" title="4.查询语句中间没有执行session.clearCache() 方法"></a>4.查询语句中间没有执行session.clearCache() 方法</h3><h3 id="5-查询语句中间没有执行-insert-update-delete-方法"><a href="#5-查询语句中间没有执行-insert-update-delete-方法" class="headerlink" title="5.查询语句中间没有执行 insert update delete 方法"></a>5.查询语句中间没有执行 insert update delete 方法</h3><p>（无论变动记录是否与 缓存数据有无关系）</p>
<h3 id="6-必须是相同的namespace-即同一个mapper"><a href="#6-必须是相同的namespace-即同一个mapper" class="headerlink" title="6.必须是相同的namespace 即同一个mapper"></a>6.必须是相同的namespace 即同一个mapper</h3><p>一级缓存源码解析：</p>
<p>缓存获取 ：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">mapper.mapper.selectById(<span class="hljs-number">23</span>)<br>	&gt;org.apache.ibatis.binding.MapperProxy#invoke<br>    &gt;org.apache.ibatis.binding.MapperMethod#execute<br>    	&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne()<br>		&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br>			&gt;org.apache.ibatis.executor.CachingExecutor#query()//尝试获取二级缓存<br>                &gt;org.apache.ibatis.executor.BaseExecutor#query() 142L<br>                	&gt;org.apache.ibatis.cache.impl.PerpetualCache#getObject 55L //尝试获取一级缓存<br></code></pre></td></tr></table></figure>



<p>缓存的存储：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">mapper.mapper.selectById(<span class="hljs-number">23</span>)<br>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br>org.apache.ibatis.executor.CachingExecutor#query()<br>org.apache.ibatis.executor.BaseExecutor#query() 142L<br>org.apache.ibatis.executor.BaseExecutor#queryFromDatabase<br>org.apache.ibatis.cache.impl.PerpetualCache#putObject<br></code></pre></td></tr></table></figure>

<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210509213336367.png" alt="image-20210509213336367"></p>
<p>通过对clearCache 作为入口我们可能追踪到 一级缓存的实现PerpetualCache</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.apache.ibatis.session.defaults.DefaultSqlSession#clearCache<br>org.apache.ibatis.executor.CachingExecutor#clearLocalCache<br>org.apache.ibatis.executor.BaseExecutor#clearLocalCache<br>org.apache.ibatis.cache.impl.PerpetualCache#clear<br></code></pre></td></tr></table></figure>

<h3 id="7-一级缓存是线程不安全的"><a href="#7-一级缓存是线程不安全的" class="headerlink" title="7.一级缓存是线程不安全的"></a>7.一级缓存是线程不安全的</h3><p>提问：</p>
<p>在查询时另一个会话并发去修改查询的数据，一级缓存是否会生效？如果生效是否就会导致数据不正确？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testThread</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                User user1 = userMapper.getUser(<span class="hljs-number">1</span>);<br>                System.out.println(<span class="hljs-string">&quot;线程一：&quot;</span>);<br>                System.out.println(user1);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程一：&quot;</span>);<br>                System.out.println(user1);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                User user2 = userMapper.getUser(<span class="hljs-number">1</span>);<br>                user2.setUsername(<span class="hljs-string">&quot;周树人&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;线程二：&quot;</span>);<br>                System.out.println(user2);<br>                sqlSession.close();<br>            &#125;<br>        &#125;).start();<br></code></pre></td></tr></table></figure>



<p>答：多次查询相同id一级缓存获取到的对象都是同一个应用，并没有做深克隆。所以当线程2查询某个缓存对象后并且人为修改了这个对象，那么也会同步影响线程一原本的对象，存在脏度问题</p>
<h2 id="2、2级缓存使用场景："><a href="#2、2级缓存使用场景：" class="headerlink" title="2、2级缓存使用场景："></a>2、2级缓存使用场景：</h2><p>业务系统中存在很多的静态数据如，字典表、菜单表、权限表等，这些数据的特性是不会轻易修改但又是查询的热点数据。一级缓存针对的是同一个会话当中相同SQL，并不适合这情热点数据的缓存场景。为了解决这个问题引入了二级缓存，它脱离于会话之外。</p>
<p>2级缓存示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheNamespace()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LabelMapper</span> </span>&#123;<br><span class="hljs-meta">@Select(&quot;select * from t_label where id =#&#123;id&#125;&quot;)</span><br><span class="hljs-function">Label <span class="hljs-title">getById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br>属性说明：<br><span class="hljs-meta">@CacheNamespace(</span><br><span class="hljs-meta">implementation = PerpetualCache.class,//  缓存实现 Cache接口 实现类</span><br><span class="hljs-meta">eviction = LruCache.class,// 缓存算法</span><br><span class="hljs-meta">flushInterval =60000,// 刷新间隔时间 毫秒</span><br><span class="hljs-meta">size =1024,// 最大缓存引用对象</span><br><span class="hljs-meta">readWrite =true,// 是否可写</span><br><span class="hljs-meta">blocking = false// 是否阻塞，用来防止缓存击穿</span><br><span class="hljs-meta">)</span><br>    或者<br>&lt;cache  readOnly=<span class="hljs-string">&quot;false&quot;</span> blocking=<span class="hljs-string">&quot;true&quot;</span> flushInterval=<span class="hljs-string">&quot;60000&quot;</span> size=<span class="hljs-string">&quot;1024&quot;</span> eviction=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210510232548387.png" alt="image-20210510232548387"></p>
<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210510232254209.png" alt="image-20210510232254209">bolocking 示意图</p>
<h3 id="1、2级缓存使用条件"><a href="#1、2级缓存使用条件" class="headerlink" title="1、2级缓存使用条件:"></a>1、2级缓存使用条件:</h3><h4 id="1、当会话提交或关闭之后才会填充二级缓存"><a href="#1、当会话提交或关闭之后才会填充二级缓存" class="headerlink" title="1、当会话提交或关闭之后才会填充二级缓存"></a>1、当会话提交或关闭之后才会填充二级缓存</h4><h4 id="2、必须是在同一个命名空间之下"><a href="#2、必须是在同一个命名空间之下" class="headerlink" title="2、必须是在同一个命名空间之下"></a>2、必须是在同一个命名空间之下</h4><h4 id="3、必须是相同的statement-即同一个mapper-接口中的同一个方法"><a href="#3、必须是相同的statement-即同一个mapper-接口中的同一个方法" class="headerlink" title="3、必须是相同的statement 即同一个mapper 接口中的同一个方法"></a>3、必须是相同的statement 即同一个mapper 接口中的同一个方法</h4><h4 id="4、必须是相同的SQL语句和参数"><a href="#4、必须是相同的SQL语句和参数" class="headerlink" title="4、必须是相同的SQL语句和参数"></a>4、必须是相同的SQL语句和参数</h4><h4 id="5、如果readWrite-true（readOnly-”false”）-，实体对像必须实现Serializable-接口"><a href="#5、如果readWrite-true（readOnly-”false”）-，实体对像必须实现Serializable-接口" class="headerlink" title="5、如果readWrite=true（readOnly=”false”） ，实体对像必须实现Serializable 接口"></a>5、如果readWrite=true（readOnly=”false”） ，实体对像必须实现Serializable 接口</h4><p>​    true:表示深克隆，实体需实现序列化，2次查询出来对象不是同一个，readWrite=false时，两次查询获取对象是同一个</p>
<h4 id="6、mapper-xml-的和-Mapper-java-的-CacheNamespace-是两个缓存空间，且不能共存"><a href="#6、mapper-xml-的和-Mapper-java-的-CacheNamespace-是两个缓存空间，且不能共存" class="headerlink" title="6、mapper.xml 的和 Mapper.java 的@CacheNamespace 是两个缓存空间，且不能共存"></a>6、mapper.xml 的<cache>和 Mapper.java 的@CacheNamespace 是两个缓存空间，且不能共存</cache></h4><h3 id="2、2级缓存清除条件："><a href="#2、2级缓存清除条件：" class="headerlink" title="2、2级缓存清除条件："></a>2、2级缓存清除条件：</h3><h4 id="1、xml中配置的update-不能清空-CacheNamespace-中的缓存数据"><a href="#1、xml中配置的update-不能清空-CacheNamespace-中的缓存数据" class="headerlink" title="1、xml中配置的update 不能清空 @CacheNamespace 中的缓存数据"></a>1、xml中配置的update 不能清空 @CacheNamespace 中的缓存数据</h4><h4 id="2、只有修改会话提交之后-才会执行清空操作"><a href="#2、只有修改会话提交之后-才会执行清空操作" class="headerlink" title="2、只有修改会话提交之后 才会执行清空操作"></a>2、只有修改会话提交之后 才会执行清空操作</h4><h4 id="3、任何一种增删改操作-都会清空整个namespace-中的缓存"><a href="#3、任何一种增删改操作-都会清空整个namespace-中的缓存" class="headerlink" title="3、任何一种增删改操作 都会清空整个namespace 中的缓存"></a>3、任何一种增删改操作 都会清空整个namespace 中的缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test00</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>       sqlSession.close();<br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user2 = userMapper2.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2);<br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>       sqlSession.close();<br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user2 = userMapper2.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2);<br>   &#125;<br><br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>       sqlSession.close();<br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user1 = <span class="hljs-keyword">new</span> User();<br>       user1.setUsername(<span class="hljs-string">&quot;lao li&quot;</span>);<br>       user1.setId(<span class="hljs-number">1</span>);<br>       userMapper2.updateUserById(user1);<br>       <span class="hljs-comment">//必须关闭，才能触发清空二级缓存</span><br>       sqlSession2.close();<br>       User user2 = sqlSessionFactory.openSession().getMapper(UserMapper.class).getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2);<br>   &#125;<br></code></pre></td></tr></table></figure>



<p>2级缓存源码解析：</p>
<p>清除缓存！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">org.apache.ibatis.session.defaults.DefaultSqlSession#selectList() 147L<br>org.apache.ibatis.executor.CachingExecutor#query()81L<br>org.apache.ibatis.executor.CachingExecutor#query()95L<br>org.apache.ibatis.executor.CachingExecutor#flushCacheIfRequired() 164L //清除缓存<br></code></pre></td></tr></table></figure>

<p>获取缓存关键源码！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">org.apache.ibatis.cache.TransactionalCacheManager#getObject<br>org.apache.ibatis.cache.decorators.TransactionalCache#getObject<br>org.apache.ibatis.cache.decorators.SynchronizedCache#getObject<br>org.apache.ibatis.cache.decorators.LoggingCache#getObject<br>org.apache.ibatis.cache.decorators.SerializedCache#getObject<br>org.apache.ibatis.cache.decorators.ScheduledCache#getObject<br>org.apache.ibatis.cache.decorators.LruCache#getObject<br>org.apache.ibatis.cache.impl.PerpetualCache#getObject<br></code></pre></td></tr></table></figure>

<p>保存2级缓存 ！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.apache.ibatis.executor.CachingExecutor#close<br>org.apache.ibatis.cache.TransactionalCacheManager#commit<br>org.apache.ibatis.cache.decorators.TransactionalCache#flushPendingEntries<br>org.apache.ibatis.cache.decorators.SynchronizedCache#putObject<br>org.apache.ibatis.cache.decorators.LoggingCache#putObject<br>org.apache.ibatis.cache.decorators.SerializedCache#putObject<br>org.apache.ibatis.cache.decorators.ScheduledCache#putObject<br>org.apache.ibatis.cache.decorators.LruCache#putObject<br>org.apache.ibatis.cache.impl.PerpetualCache#putObject<br>    <br>    <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Cache delegate;<br>  <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-comment">// issue #116</span><br>    Object object = delegate.getObject(key);<br>    <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;<br>      entriesMissedInCache.add(key);<br>    &#125;<br>    <span class="hljs-comment">// issue #146</span><br>    <span class="hljs-keyword">if</span> (clearOnCommit) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> object;<br>    &#125;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object key, Object object)</span> </span>&#123;<br>    entriesToAddOnCommit.put(key, object);<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    clearOnCommit = <span class="hljs-keyword">true</span>;<br>    entriesToAddOnCommit.clear();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (clearOnCommit) &#123;<br>      delegate.clear();<br>    &#125;<br>    flushPendingEntries();<br>    reset();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span> </span>&#123;<br>    unlockMissedEntries();<br>    reset();<br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、如何理解-TransacionCache"><a href="#3、如何理解-TransacionCache" class="headerlink" title="3、如何理解 TransacionCache"></a>3、如何理解 TransacionCache</h3><p>TransacionCache的生命周期是会话（事务）级别</p>
<p>而put进去的chache是引用级别</p>
<p>问题：</p>
<p>为什么存在 TransactionalCache，且二级缓存必须是会话提交后才生效</p>
<p>因此</p>
<ol>
<li>为了防止事务回滚的场景，别的会话脏读了二级缓存的的内容</li>
<li>所以当本次会话未关闭前，二级缓存新增对象都暂存在<strong>entriesToAddOnCommit</strong>本地中</li>
<li>当事务提交时，才触发<strong>entriesToAddOnCommit</strong> 持久化到应用生命周期的<strong>delegate</strong>这个实际cache中</li>
<li>而且每个会话期间，获取二级缓存都是从<strong>delegate</strong>这个实际cache中获取，这样就避免了脏读（读未提交）问题</li>
</ol>
<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210512231601527.png" alt="image-20210512231601527"></p>
<h3 id="4、二级缓存生命周期示意图"><a href="#4、二级缓存生命周期示意图" class="headerlink" title="4、二级缓存生命周期示意图"></a>4、二级缓存生命周期示意图</h3><p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210512231634979.png" alt="image-20210512231634979"></p>
<h1 id="二、动态化SQL"><a href="#二、动态化SQL" class="headerlink" title="二、动态化SQL"></a>二、动态化SQL</h1><hr>
<p>基本命令使用</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p><strong><trim>示例说明：</trim></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span><br>		and id = #&#123;id&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>    	and name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>trim属性说明：<br>* prefix=&quot;where&quot;// 前缀<br>* prefixOverrides=&quot;and|or&quot;// 前缀要替换的词<br>* suffix=&quot;&quot;// 添加后缀<br>* suffixOverrides=&quot;&quot;// 后缀要替换的词<br><br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>元素说明：<br>在where 包裹的SQL前会自动添加 where 字符 并去掉首尾多佘的 and|or 字符 相当于下配置:<br><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>元素说明：<br>在set包裹的SQL前会自动添加 set 字符并去掉首尾多佘的 , 字符。<br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span>&gt;</span> 元素说明:<br><br>在同一个mapper  多个statement 存在多个相同的sql  片段时，可以通过<span class="hljs-tag">&lt;<span class="hljs-name">sql</span>&gt;</span>元素声明，在通过   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>  元素进行引用<br>声明sql 段<br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;files&quot;</span>&gt;</span><br>	id ,name ,createTime<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <br>引用<br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;files&quot;</span> /&gt;</span><br>    <br>    <br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span>&gt;</span> 变量使用<br>有时需要进行一些额外 逻辑运行，通过 声明<span class="hljs-tag">&lt;<span class="hljs-name">bind</span>&gt;</span>元素，并在其value 属性中添加运算脚本，如下示例 自动给likeName 加上了% 分号，然后就可以用#&#123;likeName&#125; 来使用带%分号的like 运算。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likeName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27;+ _parameter.getName() +&#x27;%&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bind</span>&gt;</span><br>    <br>    <br>    <br>    <br></code></pre></td></tr></table></figure>

<h2 id="使用别的解析模板"><a href="#使用别的解析模板" class="headerlink" title="使用别的解析模板"></a>使用别的解析模板</h2><p>引入mybatis 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.scripting<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">内置变量<br>_databaseid  数据库标识ID<br>_parameter 当前参数变理<br>自定义模板解释器<br>以上的if trim where 等逻辑符都是 myBatis 自带的XMLLanguageDriver 所提供的解释语言，除非此之外 我们还可以使用 MyBatis-Velocity 或 mybatis-freemarker 等外部 解释器来编写动态脚本。<br>mybatis-freemarker 使用<br><br>添加sql 语句<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByIds&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;org.mybatis.scripting.freemarker.FreeMarkerLanguageDriver&quot;</span>&gt;</span><br>    select  * from user<br>    	where  id in($&#123;ids?join(&#x27;,&#x27;)&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><br>lang=&quot;org.mybatis.scripting.freemarker.FreeMarkerLanguageDriver&quot;<br>指定解析器<br></code></pre></td></tr></table></figure>



<p>添加接口方法<br>List<User> selectByIds(@Param(“ids”) List<Integer> ids);</Integer></User></p>
]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>缓存</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybati执行对象创建过程与执行</title>
    <url>/2021/05/15/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>概要：</p>
<ol>
<li>执行流程解析</li>
<li>myBatis插件开发</li>
</ol>
<h1 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h1><h2 id="Configuration全局配置对象创建"><a href="#Configuration全局配置对象创建" class="headerlink" title="Configuration全局配置对象创建"></a>Configuration全局配置对象创建</h2><p>讲解解析流程之前先回顾一下myBatis 中配置文件的结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">mybatis-config.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">settting</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>/&gt;</span><br>  &lt;..../&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>mybatis-mapper.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> &gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span>/&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span>/&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span>/&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>配置文件的解析流程即是将上述XML描述元素转换成对应的JAVA对像过程，其最终转换对像及其关系如下图：</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image1.png"></p>
<p>配置元素解析构建器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.builder.xml.XMLConfigBuilder<br>    <span class="hljs-comment">//生成org.apache.ibatis.session.Configuration对象 生命周期：整个应用周期</span><br> &gt;org.apache.ibatis.builder.xml.XMLMapperBuilder<br>    <span class="hljs-comment">//生成生成configuration对象的MappedStatement key为namcspace + 语语句块的id	 </span><br>    <span class="hljs-comment">//生命周期：整个应用周期</span><br>  &gt;org.apache.ibatis.builder.xml.XMLStatementBuilder<br>    <span class="hljs-comment">//Statement 生命周期：整个应用周期</span><br>   &gt;org.apache.ibatis.builder.SqlSourceBuilder<br>    <span class="hljs-comment">//增删改查语句内容构建</span><br>    &gt;org.apache.ibatis.scripting.xmltags.XMLScriptBuilder<br>    <span class="hljs-comment">//动态SQL构建</span><br> &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder<br>    <span class="hljs-comment">//用注解方式构建起如@Select（...）</span><br></code></pre></td></tr></table></figure>

<h2 id="SqlSession-会话对象创建"><a href="#SqlSession-会话对象创建" class="headerlink" title="SqlSession 会话对象创建"></a>SqlSession 会话对象创建</h2><p>首先我们还是先来了解一下会话对像的组成结构如下图：</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516131743828.png" alt="image-20210516131743828"></p>
<p>会话构建源码解析:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession(boolean) &gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource &gt;org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory#newTransaction() &gt;org.apache.ibatis.session.Configuration#newExecutor() &gt;org.apache.ibatis.executor.SimpleExecutor#SimpleExecutor &gt;org.apache.ibatis.executor.CachingExecutor#CachingExecutor //执行器插件包装 &gt;org.apache.ibatis.plugin.InterceptorChain#pluginAll(executor) &gt;org.apache.ibatis.session.defaults.DefaultSqlSession#DefaultSqlSession()<br></code></pre></td></tr></table></figure>

<h2 id="方法执行流程"><a href="#方法执行流程" class="headerlink" title="方法执行流程"></a>方法执行流程</h2><p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516135633903.png" alt="image-20210516135633903"></p>
<p>StatementHandler 源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br> &gt;org.apache.ibatis.executor.CachingExecutor#query()<br>  &gt;org.apache.ibatis.executor.BaseExecutor#query()<br>   &gt;org.apache.ibatis.executor.BaseExecutor#queryFromDatabase<br>&gt;org.apache.ibatis.session.Configuration#newStatementHandler<br>org.apache.ibatis.executor.statement.BaseStatementHandler#BaseStatementHandler<br>org.apache.ibatis.session.Configuration#newParameterHandler<br>org.apache.ibatis.plugin.InterceptorChain#pluginAll(parameterHandler)<br>org.apache.ibatis.session.Configuration#newResultSetHandler<br>org.apache.ibatis.plugin.InterceptorChain#pluginAll(resultSetHandler)<br>&gt;org.apache.ibatis.plugin.InterceptorChain#pluginAll(statementHandler)<br>&gt;org.apache.ibatis.executor.BaseExecutor#getConnection<br>&gt;org.apache.ibatis.executor.statement.PreparedStatementHandler#instantiateStatement<br>&gt;org.apache.ibatis.executor.statement.PreparedStatementHandler#parameterize<br>&gt;org.apache.ibatis.scripting.defaults.DefaultParameterHandler#setParameters<br>org.apache.ibatis.type.BaseTypeHandler#setParameter<br>org.apache.ibatis.type.UnknownTypeHandler#setNonNullParameter<br>org.apache.ibatis.type.IntegerTypeHandler#setNonNullParameter<br></code></pre></td></tr></table></figure>

<h2 id="Mapper接口对象创建（待补充）"><a href="#Mapper接口对象创建（待补充）" class="headerlink" title="Mapper接口对象创建（待补充）"></a>Mapper接口对象创建（待补充）</h2><h1 id="MyBatis插件开发"><a href="#MyBatis插件开发" class="headerlink" title="MyBatis插件开发"></a>MyBatis插件开发</h1><h3 id="插件的四大扩展点"><a href="#插件的四大扩展点" class="headerlink" title="插件的四大扩展点"></a>插件的四大扩展点</h3><p>1、Executor</p>
<p>2、StatementHandler</p>
<p>3、ParameterHandler</p>
<p>4、ResultSetHandler</p>
<h3 id="分页插件实现"><a href="#分页插件实现" class="headerlink" title="分页插件实现"></a>分页插件实现</h3><p>用户在接口中声明Page  对像实现后，由插件实现自动分页。</p>
<p>使用示例如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> szie; <span class="hljs-comment">// 每页大    </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number; <span class="hljs-comment">// 当前页码</span><br>&#125;<br> <span class="hljs-function">List&lt;User&gt;  <span class="hljs-title">selectUserList</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user, <span class="hljs-meta">@Param(&quot;page&quot;)</span> PageDTO page)</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.study.pojo.User&quot;</span>&gt;</span><br>    select * from user where id = #&#123;user.id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>实现目标分解：</p>
<p>1、判断方法参数是否包含Page对象</p>
<p>2、取出page对象生成 limit 语句</p>
<p>3、修改SQL语句添加 limit 语句</p>
<p>4、上述操作必须在Statement（PrepareStatement）对象生成之前完成</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516160916272.png" alt="image-20210516160916272"></p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516161122668.png" alt="image-20210516161122668"></p>
<p>根据第四点和上面俩图得知插件拦截的时，拦截的目标类和目标方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>&#123;<br>    <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection connection, Integer transactionTimeout)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以最终的拦截器代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PagePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       <span class="hljs-keyword">return</span> invocation.getTarget();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target <span class="hljs-keyword">instanceof</span> StatementHandler)&#123;<br>            <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),<br>                    <span class="hljs-keyword">new</span> Class[]&#123;StatementHandler.class&#125;,<br>                    <span class="hljs-keyword">new</span> PageHandler((StatementHandler) target));<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageHandler</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">InvocationHandler</span></span>&#123;<br><br>        <span class="hljs-keyword">private</span> StatementHandler statementHandler;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageHandler</span><span class="hljs-params">(StatementHandler statementHandler)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.statementHandler = statementHandler;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            <span class="hljs-keyword">if</span>(method.getName().equals(<span class="hljs-string">&quot;prepare&quot;</span>))&#123;<br>                ((Map)statementHandler.getBoundSql().getParameterObject()).values().stream()<br>                        .filter(e -&gt; e <span class="hljs-keyword">instanceof</span> PageDTO)<br>                        .findFirst()<br>                        .ifPresent(<br>                                page -&gt; &#123;<br><br>                                    appendPageSql((PageDTO) page);<br>                                &#125;<br>                        );<br>            &#125;<br>            <span class="hljs-keyword">return</span> method.invoke(statementHandler,args);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendPageSql</span><span class="hljs-params">(PageDTO page)</span> </span>&#123;<br>            BoundSql boundSql = statementHandler.getBoundSql();<br>            String sql = boundSql.getSql();<br>            String appendString = String.format(<span class="hljs-string">&quot; limit %s,%s&quot;</span>,(page.getNumber()-<span class="hljs-number">1</span>) * page.getSzie(),page.getSzie());<br>            String result = sql + appendString;<br>            <span class="hljs-keyword">try</span> &#123;<br>                setField(boundSql,<span class="hljs-string">&quot;sql&quot;</span>,result);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setField</span><span class="hljs-params">(BoundSql boundSql, String field, String result)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchFieldException </span>&#123;<br>            Field declaredField = BoundSql.class.getDeclaredField(field);<br>            declaredField.setAccessible(<span class="hljs-keyword">true</span>);<br>            declaredField.set(boundSql,result);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="SQL性能插件"><a href="#SQL性能插件" class="headerlink" title="SQL性能插件"></a>SQL性能插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC4_PREPARED_STATEMENT = <span class="hljs-string">&quot;com.mysql.jdbc.JDBC4PreparedStatement&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 执行最大时长，超过自动停止运行，有助于发现问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 是否格式化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> format = <span class="hljs-keyword">false</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Statement statement;<br>        Object firstArg = invocation.getArgs()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(firstArg.getClass())) &#123;<br>            statement = (Statement) SystemMetaObject.forObject(firstArg).getValue(<span class="hljs-string">&quot;h.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            statement = (Statement) firstArg;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            statement = (Statement) SystemMetaObject.forObject(statement).getValue(<span class="hljs-string">&quot;stmt.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br><br>        String originalSql = <span class="hljs-keyword">null</span>;<br>        String stmtClassName = statement.getClass().getName();<br>        <span class="hljs-keyword">if</span> (JDBC4_PREPARED_STATEMENT.equals(stmtClassName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(JDBC4_PREPARED_STATEMENT);<br>                Method druidGetSqlMethod = clazz.getMethod(<span class="hljs-string">&quot;getSql&quot;</span>);<br>                Object stmtSql = druidGetSqlMethod.invoke(statement);<br>                <span class="hljs-keyword">if</span> (stmtSql != <span class="hljs-keyword">null</span> &amp;&amp; stmtSql <span class="hljs-keyword">instanceof</span> String) &#123;<br>                    originalSql = (String) stmtSql;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (originalSql == <span class="hljs-keyword">null</span>) &#123;<br>            originalSql = statement.toString();<br>        &#125;<br>        originalSql = originalSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">int</span> index = originalSql.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            originalSql = originalSql.substring(index + <span class="hljs-number">1</span>, originalSql.length());<br>        &#125;<br>        String sqlFormat = SqlUtil.sqlFormat(originalSql, format);<br>        Object target = realTarget(invocation.getTarget());<br>        MetaObject metaObject = SystemMetaObject.forObject(target);<br>        MappedStatement ms = (MappedStatement) metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>        Logger mybatisLogger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br>        <span class="hljs-comment">// 计算执行 SQL 耗时</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = invocation.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">long</span> timing =  System.currentTimeMillis() - start;<br>            StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder()<br>                    .append(<span class="hljs-string">&quot;execute sql error, use time：&quot;</span>).append(timing).append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                    .append(sqlFormat);<br>            mybatisLogger.error(formatSql.toString());<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <span class="hljs-keyword">long</span> timing = System.currentTimeMillis() - start;<br><br>        <span class="hljs-comment">// 格式化 SQL 打印执行结果</span><br>        StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;Execute sql use time：&quot;</span>).append(timing)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; Execute SQL：&quot;</span>).append(sqlFormat)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; result: &quot;</span>).append(result);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMaxTime() &gt;= <span class="hljs-number">1</span> &amp;&amp; timing &gt; <span class="hljs-keyword">this</span>.getMaxTime()) &#123;<br>            mybatisLogger.error(formatSql.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mybatisLogger.debug(formatSql.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> StatementHandler) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties prop)</span> </span>&#123;<br>        String maxTime = prop.getProperty(<span class="hljs-string">&quot;maxTime&quot;</span>);<br>        String format = prop.getProperty(<span class="hljs-string">&quot;format&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(maxTime)) &#123;<br>            <span class="hljs-keyword">this</span>.maxTime = Long.parseLong(maxTime);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(format)) &#123;<br>            <span class="hljs-keyword">this</span>.format = Boolean.valueOf(format);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">realTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(target.getClass())) &#123;<br>            MetaObject metaObject = SystemMetaObject.forObject(target);<br>            <span class="hljs-keyword">return</span> realTarget(metaObject.getValue(<span class="hljs-string">&quot;h.target&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) target;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="带参数SQL打印插件"><a href="#带参数SQL打印插件" class="headerlink" title="带参数SQL打印插件"></a>带参数SQL打印插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts</span><br>        (&#123;<br>                <span class="hljs-meta">@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span>,<br>                <span class="hljs-meta">@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)</span><br>        &#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlPrintInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(SqlPrintInterceptor.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateFormat DATE_FORMAT = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];<br>        Object parameterObject = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (invocation.getArgs().length &gt; <span class="hljs-number">1</span>) &#123;<br>            parameterObject = invocation.getArgs()[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><br>        Object result = invocation.proceed();<br><br>        String statementId = mappedStatement.getId();<br>        BoundSql boundSql = mappedStatement.getBoundSql(parameterObject);<br>        Configuration configuration = mappedStatement.getConfiguration();<br>        String sql = getSql(boundSql, parameterObject, configuration);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> timing = end - start;<br>        <span class="hljs-keyword">if</span>(log.isInfoEnabled())&#123;<br>            log.info(<span class="hljs-string">&quot;执行sql耗时:&quot;</span> + timing + <span class="hljs-string">&quot; ms&quot;</span> + <span class="hljs-string">&quot; - id:&quot;</span> + statementId + <span class="hljs-string">&quot; - Sql:&quot;</span> );<br>            log.info(<span class="hljs-string">&quot;   &quot;</span>+sql);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Executor) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSql</span><span class="hljs-params">(BoundSql boundSql, Object parameterObject, Configuration configuration)</span> </span>&#123;<br>        String sql = boundSql.getSql().replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();<br>        TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();<br>        <span class="hljs-keyword">if</span> (parameterMappings != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterMappings.size(); i++) &#123;<br>                ParameterMapping parameterMapping = parameterMappings.get(i);<br>                <span class="hljs-keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;<br>                    Object value;<br>                    String propertyName = parameterMapping.getProperty();<br>                    <span class="hljs-keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;<br>                        value = boundSql.getAdditionalParameter(propertyName);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameterObject == <span class="hljs-keyword">null</span>) &#123;<br>                        value = <span class="hljs-keyword">null</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;<br>                        value = parameterObject;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        MetaObject metaObject = configuration.newMetaObject(parameterObject);<br>                        value = metaObject.getValue(propertyName);<br>                    &#125;<br>                    sql = replacePlaceholder(sql, value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sql;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">replacePlaceholder</span><span class="hljs-params">(String sql, Object propertyValue)</span> </span>&#123;<br>        String result;<br>        <span class="hljs-keyword">if</span> (propertyValue != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (propertyValue <span class="hljs-keyword">instanceof</span> String) &#123;<br>                result = <span class="hljs-string">&quot;&#x27;&quot;</span> + propertyValue + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propertyValue <span class="hljs-keyword">instanceof</span> Date) &#123;<br>                result = <span class="hljs-string">&quot;&#x27;&quot;</span> + DATE_FORMAT.format(propertyValue) + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = propertyValue.toString();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-string">&quot;null&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sql.replaceFirst(<span class="hljs-string">&quot;\\?&quot;</span>, Matcher.quoteReplacement(result));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>执行流程</tag>
        <tag>mybatis插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring04-如何解决循环依赖</title>
    <url>/2021/06/25/Spring04-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%C2%B7/</url>
    <content><![CDATA[<p>读前猜想：</p>
<ol>
<li>什么是Spring的循环依赖</li>
<li>如何检测是否存在循环依赖</li>
<li><strong>如何解决循环依赖</strong></li>
<li>循环依赖解决要满足哪些条件</li>
<li>什么是早期bean</li>
<li>为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？</li>
</ol>
<h1 id="什么是Spring的循环依赖"><a href="#什么是Spring的循环依赖" class="headerlink" title="什么是Spring的循环依赖"></a>什么是Spring的循环依赖</h1><p>多个bean之间相互依赖，形成了一个闭环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="如何检测是否存在循环依赖"><a href="#如何检测是否存在循环依赖" class="headerlink" title="如何检测是否存在循环依赖"></a>如何检测是否存在循环依赖</h1><p>​    检测循环依赖比较简单，使用一个列表来记录当前正在创建的bean，在每个bean创建之前，先去记录中看一下自己是否在列表中，如果存在，则说明存在循环依赖（A-&gt;B-&gt;A）,如果不在，则将其加入到列表中，待到bean创建完成，再从该列表中移除</p>
<h2 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h2><p>spring创建单例bean时候，会调用下面方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，<code>this.singletonsCurrentlyInCreation.add(beanName)</code>返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException</p>
<h2 id="多例"><a href="#多例" class="headerlink" title="多例"></a>多例</h2><p>​    以prototype情况为例，源码位于<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>方法中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常</span><br><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>&#125;<br><br><span class="hljs-comment">//判断scope是否是prototype</span><br><span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>    Object prototypeInstance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//将beanName放入正在创建的列表中</span><br>        beforePrototypeCreation(beanName);<br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//将beanName从正在创建的列表中移除</span><br>        afterPrototypeCreation(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring如何解决循环依赖的问题"><a href="#Spring如何解决循环依赖的问题" class="headerlink" title="Spring如何解决循环依赖的问题"></a>Spring如何解决循环依赖的问题</h1><p>有了前面创建bean的基础后我们知道</p>
<p>Spring创建bean的主要步骤</p>
<p>1、实例化Bean，及调用构造器或者工厂方法创建bean</p>
<p>2、populateBean 填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean</p>
<p>3、初始化bean，调用初始化方法</p>
<p>从Spring Bean创建的过程来看，注入依赖的方式有两种</p>
<ol>
<li><strong>实例化bean时通过构造方法注入</strong></li>
<li><strong>填充属性时</strong></li>
</ol>
<h2 id="构造注入方式导致的循环依赖无法解决"><a href="#构造注入方式导致的循环依赖无法解决" class="headerlink" title="构造注入方式导致的循环依赖无法解决"></a>构造注入方式导致的循环依赖无法解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceA</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceB serviceB;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceA</span><span class="hljs-params">(ServiceB serviceB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceB = serviceB;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceB</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceA serviceA;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceB</span><span class="hljs-params">(ServiceA serviceA)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceA = serviceA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="属性注入方式导致的循环依赖可以解决"><a href="#属性注入方式导致的循环依赖可以解决" class="headerlink" title="属性注入方式导致的循环依赖可以解决"></a>属性注入方式导致的循环依赖可以解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceA</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceB serviceB;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServiceB</span><span class="hljs-params">(ServiceB serviceB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceB = serviceB;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceB</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceA serviceA;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServiceA</span><span class="hljs-params">(ServiceA serviceA)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceA = serviceA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/Spring04-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%C2%B7/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.svg" alt="spring循环依赖数据流程图"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">1.spring轮询准备创建2个bean：serviceA和serviceB<br>2.spring容器发现singletonObjects中没有serviceA<br>3.调用serviceA的构造器创建serviceA实例<br>4.serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br>5.serviceA向spring容器查找serviceB<br>6.spring容器发现singletonObjects中没有serviceB<br>7.调用serviceB的构造器创建serviceB实例<br>8.serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br>9.serviceB向spring容器查找serviceA<br>10.此时又进入步骤2了<br></code></pre></td></tr></table></figure>

<p>完整解决循环依赖的过程：</p>
<ul>
<li>1.从容器中获取serviceA</li>
<li>2.容器尝试从单例缓存中找serviceA，找不到</li>
<li>3.准备创建serviceA<br>4.调用serviceA的构造器创建serviceA，得到serviceA实例，此时serviceA还未填充属性，未进行其他任何初始化的操作</li>
<li>5**.将早期的serviceA暴露出去：即将其丢到第3级缓存==singletonFactories==中**</li>
<li>6.serviceA准备填充属性，发现需要注入serviceB，然后向容器获取serviceB</li>
<li>7.容器尝试从单例缓存中找serviceB，找不到</li>
<li>8.准备创建serviceB</li>
<li>9.调用serviceB的构造器创建serviceB，得到serviceB实例，此时serviceB还未填充属性，未进行其他任何初始化的操作</li>
<li>10.<strong>将早期的serviceB暴露出去：即将其丢到第3级缓存singletonFactories中</strong></li>
<li>11.serviceB准备填充属性，发现需要注入serviceA，然后向容器获取serviceA</li>
<li>12.<strong>容器尝试从单例缓存中找serviceA，发现此时serviceA位于第3级缓存中，经过处理之后，serviceA会从第3级缓存中移除，然后会存到第2级缓存中，然后将其返回给serviceB，此时serviceA通过serviceB中的setServiceA方法被注入到serviceB中</strong></li>
<li>13.<strong>serviceB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</strong></li>
<li>14.serviceB将自己返回给serviceA</li>
<li>15.serviceA通过setServiceB方法将serviceB注入进去</li>
<li>16.serviceB继续执行后续的一些操作，最后完成创建工作,然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</li>
</ul>
<h1 id="循环依赖解决要哪些情况下无法解决"><a href="#循环依赖解决要哪些情况下无法解决" class="headerlink" title="循环依赖解决要哪些情况下无法解决"></a>循环依赖解决要哪些情况下无法解决</h1><p><strong>1、构造器注入（因为暴露早期对象是对象实例化后进行的）</strong></p>
<p><strong>2、A\B都是多例</strong></p>
<p><strong>3、A多例 B单例懒加载 且容器先获取A时(如果先获取B时可以解决循环依赖的)</strong></p>
<p>4、某些情况下使用了在类方法上使用了@async注解的类（后续再讨论）</p>
<h1 id="什么是早期bean"><a href="#什么是早期bean" class="headerlink" title="什么是早期bean"></a>什么是早期bean</h1><p>​    <strong>刚刚实例化好的bean就是早期的bean，此时bean还未进行属性填充，初始化等操作</strong></p>
<h1 id="为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？"><a href="#为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？" class="headerlink" title="为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？"></a>为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？</h1><h2 id="为什么使用三级缓存"><a href="#为什么使用三级缓存" class="headerlink" title="为什么使用三级缓存"></a>为什么使用三级缓存</h2><p>没看源码之前，有我们自己猜想，可能有一个 HashMap，缓存这我们创建的单例bean，每个创建完成后就往这个bean里放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure>

<p>但是单单如此还解决不了问题,如以下场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>spring轮询准备创建<span class="hljs-number">2</span>个bean：serviceA和serviceB<br><span class="hljs-number">2.</span>spring容器发现singletonObjects中没有serviceA<br><span class="hljs-number">3.</span>调用serviceA的构造器创建serviceA实例<br><span class="hljs-number">4.</span>serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br><span class="hljs-number">5.</span>serviceA向spring容器查找serviceB<br><span class="hljs-number">6.</span>spring容器发现singletonObjects中没有serviceB<br><span class="hljs-number">7.</span>调用serviceB的构造器创建serviceB实例<br><span class="hljs-number">8.</span>serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br><span class="hljs-number">9.</span>serviceB向spring容器查找serviceA<br><span class="hljs-number">10.</span>此时又进入步骤<span class="hljs-number">2</span>了<br></code></pre></td></tr></table></figure>

<h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>​    既然要解决循环依赖，那么势必有一个Map可以缓存当前创建实例后的bean，以便别的bean在实例化时可以从这个map中获取对象。因此我们需要第二个Map:secondMap来帮我们保存正在创建的bean。</p>
<p>这样的话，我们猜想Spring创建Bean过程如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>spring轮询准备创建<span class="hljs-number">2</span>个bean：serviceA和serviceB<br><span class="hljs-number">2.</span>spring容器发现<span class="hljs-number">2</span>个map中没有serviceA<br><span class="hljs-number">3.</span>调用serviceA的构造器创建serviceA实例，并且把serviceA实例添加到secondMap中<br><span class="hljs-number">4.</span>serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br><span class="hljs-number">5.</span>serviceA向spring容器查找serviceB<br><span class="hljs-number">6.</span>spring容器发现<span class="hljs-number">2</span>个map中没有serviceB<br><span class="hljs-number">7.</span>调用serviceB的构造器创建serviceB实例，并且把serviceB实例添加到secondMap中<br><span class="hljs-number">8.</span>serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br><span class="hljs-number">9.</span>serviceB向spring容器查找serviceA，secondMap获取到serviceA<br><span class="hljs-number">10.</span>serviceB创建成功，添加到singletonObjects中，移除secondMap对应实例<br><span class="hljs-number">10.</span>serviceA创建成功，添加到singletonObjects中，移除secondMap对应实例<br></code></pre></td></tr></table></figure>

<p>​    咋一看，这样设计也不是不行，实际上，spring中也采用类似的方式，稍微有点区别，上面使用了一个缓存，而spring内部采用了3级缓存来解决这个问题，我们一起来细看一下。</p>
<p>3级缓存对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 第一级缓存：单例bean的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br><span class="hljs-comment">/** 第二级缓存：早期暴露的bean的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><span class="hljs-comment">/** 第三级缓存：单例bean工厂的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<p>因此bean从缓存角度实际的创建过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>从容器中获取serviceA<br><span class="hljs-number">2.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceA，找不到<br><span class="hljs-number">3.</span>准备创建serviceA<br><span class="hljs-number">4.</span>调用serviceA的构造器创建serviceA，得到serviceA实例，此时serviceA还未填充属性，未进行其他任何初始化的操作<br><span class="hljs-number">5.</span>将早期的serviceA暴露出去：即将其丢到第<span class="hljs-number">3</span>级缓存singletonFactories中<br><span class="hljs-number">6.</span>serviceA准备填充属性，发现需要注入serviceB，然后向容器获取serviceB<br><span class="hljs-number">7.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceB，找不到<br><span class="hljs-number">8.</span>准备创建serviceB<br><span class="hljs-number">9.</span>调用serviceB的构造器创建serviceB，得到serviceB实例，此时serviceB还未填充属性，未进行其他任何初始化的操作<br><span class="hljs-number">10.</span>将早期的serviceB暴露出去：即将其丢到第<span class="hljs-number">3</span>级缓存singletonFactories中<br><span class="hljs-number">11.</span>serviceB准备填充属性，发现需要注入serviceA，然后向容器获取serviceA<br><span class="hljs-number">12.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceA，发现此时serviceA位于第<span class="hljs-number">3</span>级缓存中，经过处理之后，serviceA会从第<span class="hljs-number">3</span>级缓存中移除，然后会存到第<span class="hljs-number">2</span>级缓存中，然后将其返回给serviceB，此时serviceA通过serviceB中的setServiceA方法被注入到serviceB中<br><span class="hljs-number">13.</span>serviceB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第<span class="hljs-number">1</span>级缓存中，并将自己从第<span class="hljs-number">2</span>和第<span class="hljs-number">3</span>级缓存中移除<br><span class="hljs-number">14.</span>serviceB将自己返回给serviceA<br><span class="hljs-number">15.</span>serviceA通过setServiceB方法将serviceB注入进去<br><span class="hljs-number">16.</span>serviceB继续执行后续的一些操作，最后完成创建工作,然后会调用addSingleton方法，将自己丢到第<span class="hljs-number">1</span>级缓存中，并将自己从第<span class="hljs-number">2</span>和第<span class="hljs-number">3</span>级缓存中移除<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取缓存</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;<br>    <span class="hljs-comment">//1.先从一级缓存中找</span><br>    Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">//2.从二级缓存中找</span><br>            singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;<br>                <span class="hljs-comment">//3.二级缓存中没找到 &amp;&amp; allowEarlyReference为true的情况下,从三级缓存中找</span><br>                ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//三级缓存返回的是一个工厂，通过工厂来获取创建bean</span><br>                    singletonObject = singletonFactory.getObject();<br>                    <span class="hljs-comment">//将创建好的bean丢到二级缓存中</span><br>                    <span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                    <span class="hljs-comment">//从三级缓存移除</span><br>                    <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br><span class="hljs-comment">//创建完成后，添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">//将bean放入第1级缓存中</span><br>        <span class="hljs-keyword">this</span>.singletonObjects.put(beanName, singletonObject);<br>        <span class="hljs-comment">//将其从第3级缓存中移除</span><br>        <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<br>        <span class="hljs-comment">//将其从第2级缓存中移除</span><br>        <span class="hljs-keyword">this</span>.earlySingletonObjects.remove(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>那回归正题，如上所述，为什么Spring要用3级缓存来解决循环依赖呢？<strong>如果只使用2级缓存，直接将刚实例化好的bean暴露给二级缓存出是否可以？</strong></p>
<p>结论：不能</p>
<p>原因：<strong>这样做是可以解决：早期暴露给其他依赖者的bean和最终暴露的bean不一致的问题。</strong></p>
<p>​    若将刚刚实例化好的bean直接丢到二级缓存中暴露出去，如果后期这个bean对象被更改了，比如可能在上面加了一些拦截器，将其包装为一个代理了，那么暴露出去的bean和最终的这个bean就不一样的，将自己暴露出去的时候是一个原始对象，而自己最终却是一个代理对象，最终会导致被暴露出去的和最终的bean不是同一个bean的，将产生意向不到的效果，而三级缓存就可以发现这个问题，会报错。</p>
<p>举例说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Service1 m1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Service2 service2;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setService2</span><span class="hljs-params">(Service2 service2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service2 = service2;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Service2 m1&quot;</span>);<br>        <span class="hljs-keyword">this</span>.service1.m1();<span class="hljs-comment">//@1</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Service1 service1;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setService1</span><span class="hljs-params">(Service1 service1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service1 = service1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Service1 <span class="hljs-title">getService1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> service1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意上面的<code>@1</code>，service2的m1方法中会调用service1的m1方法。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>​    在service1上面加个拦截器，要求在调用service1的任何方法之前需要先输出一行日志：”你好,service1”</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>新增一个Bean后置处理器来对service1对应的bean进行处理，将其封装为一个代理暴露出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.ProxyFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;service1&quot;</span>.equals(beanName)) &#123;<br>            <span class="hljs-comment">//代理创建工厂，需传入被代理的目标对象</span><br>            ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory(bean);<br>            <span class="hljs-comment">//添加一个方法前置通知，会在方法执行之前调用通知中的before方法</span><br>            proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodBeforeAdvice() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, <span class="hljs-meta">@Nullable</span> Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;你好,service1&quot;</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//返回代理对象</span><br>            <span class="hljs-keyword">return</span> proxyFactory.getProxy();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<code>postProcessAfterInitialization</code>方法内部会在service1初始化之后调用，内部会对service1这个bean进行处理，返回一个代理对象，通过代理来访问service1的方法，访问service1中的任何方法之前，会先输出：<code>你好，service1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &#123;&quot;com.study.cycledepend.thirdlevelcache&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopConfig</span> </span>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>        context.register(AopConfig.class);<br>        context.refresh();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="运行：报错了"><a href="#运行：报错了" class="headerlink" title="运行：报错了"></a>运行：报错了</h4><p>可以看出是<code>AbstractAutowireCapableBeanFactory.java:624</code>这个地方整出来的异常，将这块代码贴出来给大家看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">//@1</span><br>    Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//@2</span><br>        <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>            exposedObject = earlySingletonReference;<br>        &#125;<br>        <span class="hljs-comment">//@3</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>            String[] dependentBeans = getDependentBeans(beanName);<br>            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<br>            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                    actualDependentBeans.add(dependentBean);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,<br>                                                           <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                                                           StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                                                           <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                                                           <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                                                           <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                                                           <span class="hljs-string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来通过代码级别的来解释上面代码：</p>
<p>​    这段代码主要用来判断当有循环依赖的情况下，早期暴露给别人使用的bean是否和最终的bean不一样的情况下，会抛出一个异常。</p>
<p>@1：调用getSingleton(beanName, false)方法，这个方法用来从3个级别的缓存中获取bean，但是注意了，这个地方第二个参数是false，此时只会尝试从第1级和第2级缓存中获取bean，如果能够获取到，说明了什么？说明了第2级缓存中已经有这个bean了，而什么情况下第2级缓存中会有bean？说明这个bean从第3级缓存中已经被别人获取过，然后从第3级缓存移到了第2级缓存中，说明这个早期的bean被别人通过getSingleton(beanName, true)获取过</p>
<p>@2：这个地方用来判断早期暴露的bean和最终spring容器对这个bean走完创建过程之后是否还是同一个bean，上面我们的service1被代理了，所以这个地方会返回false，此时会走到<code>@3</code></p>
<p>@3：<code>allowRawInjectionDespiteWrapping</code>这个参数用来控制是否允许循环依赖的情况下，早期暴露给被人使用的bean在后期是否可以被包装，通俗点理解就是：是否允许早期给别人使用的bean和最终bean不一致的情况，这个值默认是false，表示不允许，也就是说你暴露给别人的bean和你最终的bean需要是一直的，你给别人的是1，你后面不能将其修改成2了啊，不一样了，你给我用个鸟。</p>
<p>而上面代码注入到service2中的service1是早期的service1，而最终spring容器中的service1变成一个代理对象了，早期的和最终的不一致了，而<code>allowRawInjectionDespiteWrapping</code>又是false，所以报异常了。</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>很简单，将<code>allowRawInjectionDespiteWrapping</code>设置为true就可以了，下面改一下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    <span class="hljs-comment">//创建一个BeanFactoryPostProcessor：BeanFactory后置处理器</span><br>    context.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>            <span class="hljs-comment">//将allowRawInjectionDespiteWrapping设置为true</span><br>            ((DefaultListableBeanFactory) beanFactory).setAllowRawInjectionDespiteWrapping(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;);<br>    context.register(IocConfig.class);<br>    context.refresh();<br><br>    System.out.println(<span class="hljs-string">&quot;容器初始化完毕&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上面代码中将<code>allowRawInjectionDespiteWrapping</code>设置为true了，是通过一个<code>BeanFactoryPostProcessor</code>来实现的，后面会有一篇文章来详解<code>BeanFactoryPostProcessor</code>，目前你只需要知道<code>BeanFactoryPostProcessor</code>可以在bean创建之前用来干预<code>BeanFactory</code>的创建过程，可以用来修改<code>BeanFactory</code>中的一些配置。</p>
<p>​    这样配置虽然不报错了，但是spring容器中的Service1和Service2实例中的service1仍旧不是同一个对象,那么这种情况是不是很诧异，如何解决这个问题？</p>
<p>​    既然最终service1是一个代理对象，那么你提前暴露出去的时候，注入到service2的时候，你也必须得是个代理对象啊，需要确保给别人和最终是同一个对象。</p>
<p>这个怎么整？继续看暴露早期bean的源码，注意了下面是重点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;<br>    Object exposedObject = bean;<br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    我们可以自定义一个<code>SmartInstantiationAwareBeanPostProcessor</code>，然后在其<code>getEarlyBeanReference</code>中来创建代理不就可以了，聪明，我们来试试，将<code>MethodBeforeInterceptor</code>代码改成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);<br>        Service1 service1 = context.getBean(Service1.class);<br>        Service2 service2 = context.getBean(Service2.class);<br><br>        service1.m1();<br>        service2.m1();<br>        System.out.println(service1.equals(service2.getService1()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">你好,service1<br>Service1 m1<br>Service2 m1<br>你好,service1<br>Service1 m1<br><span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>

<p>这样就解决问题了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring05-AOP源码</title>
    <url>/2021/07/01/Spring05-AOP%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h1><p>​    AOP（Aspect Oriented Programming），可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。</p>
<p>​    它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>​    使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，<strong>比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来</strong>。</p>
<h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><h3 id="横切关注点-对哪些方法进行切入"><a href="#横切关注点-对哪些方法进行切入" class="headerlink" title="横切关注点(对哪些方法进行切入)"></a>横切关注点(对哪些方法进行切入)</h3><p>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>​    （aspect,把原来糅杂在业务逻辑代码中的非业务代码抽取出来，把功能相同的放在一个类中形成一个切面）</p>
<p>类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
<h3 id="连接点（joinpoint）（需要切入的点）"><a href="#连接点（joinpoint）（需要切入的点）" class="headerlink" title="连接点（joinpoint）（需要切入的点）"></a>连接点（joinpoint）（需要切入的点）</h3><p>​    被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
<h3 id="切入点（pointcut）"><a href="#切入点（pointcut）" class="headerlink" title="切入点（pointcut）"></a>切入点（pointcut）</h3><p>​    对连接点进行拦截的定义</p>
<h3 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h3><p>​    所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
<h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p>​    代理的目标对象</p>
<h3 id="织入（weave）"><a href="#织入（weave）" class="headerlink" title="织入（weave）"></a>织入（weave）</h3><p>​    将切面应用到目标对象并导致代理对象创建的过程</p>
<h3 id="引入（introduction）"><a href="#引入（introduction）" class="headerlink" title="引入（introduction）"></a>引入（introduction）</h3><p>​    在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</p>
<h2 id="基本案例"><a href="#基本案例" class="headerlink" title="基本案例"></a>基本案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...div&quot;</span>);<br>        <span class="hljs-keyword">return</span> x / y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...add&quot;</span>);<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(public int com.study.aop.Calculator.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;前置通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;后置通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturn</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;返回通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;异常通知。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.aop&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);<br>        Calculator calculator = context.getBean(Calculator.class);<br>        <span class="hljs-keyword">int</span> add = calculator.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        log.info(add+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">int</span> div = calculator.div(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br>        log.info(div+<span class="hljs-string">&quot;&quot;</span>);<br><br>    &#125;<br>&#125;<br><br>-- 结果<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.389</span> [main] INFO com.study.aop.CalculateAspect - 前置通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.428</span> [main] INFO com.study.aop.Calculator - Mycaculator...add<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.428</span> [main] INFO com.study.aop.CalculateAspect - 后置通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.428</span> [main] INFO com.study.aop.CalculateAspect - 返回通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.428</span> [main] INFO com.study.aop.CalculateAspect - 异常通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.428</span> [main] INFO com.study.aop.AopMain - <span class="hljs-number">3</span><br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.CalculateAspect - 前置通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.Calculator - Mycaculator...div<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.CalculateAspect - 后置通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.CalculateAspect - 返回通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.CalculateAspect - 异常通知。。。<br><span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">08.429</span> [main] INFO com.study.aop.AopMain - <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<h1 id="从-EnableAspectJAutoProxy说起"><a href="#从-EnableAspectJAutoProxy说起" class="headerlink" title="从@EnableAspectJAutoProxy说起"></a>从@EnableAspectJAutoProxy说起</h1><p>​    不难看出该注解为我们注入了AnnotationAwareAspectJAutoProxyCreator这个类，分析这个类的继承结构</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210701223116469.png" alt="image-20210701223116469"></p>
<p>不难发现这个类觉有BeanFactoryAware、BeanPostProcessor、InstantiationAwareBeanPostProcessor的特性，因此可以得出下图</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aopAnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.svg" alt="aopAnnotationAwareAspectJAutoProxyCreator类关系图"></p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210701230423945.png" alt="image-20210701230423945"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;<br>	<span class="hljs-keyword">super</span>.setBeanFactory(beanFactory);<br>	<span class="hljs-keyword">if</span> (!(beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory)) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>				<span class="hljs-string">&quot;AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: &quot;</span> + beanFactory);<br>	&#125;<br>	initBeanFactory((ConfigurableListableBeanFactory) beanFactory);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>	<span class="hljs-keyword">this</span>.advisorRetrievalHelper = <span class="hljs-keyword">new</span> BeanFactoryAdvisorRetrievalHelperAdapter(beanFactory);<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>	Object cacheKey = getCacheKey(beanClass, beanName);<br><br>	<span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>			<span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Create proxy here if we have a custom TargetSource.</span><br>	<span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span><br>	<span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span><br>	TargetSource targetSource = getCustomTargetSource(beanClass, beanName);<br>	<span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>			<span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);<br>		&#125;<br>		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>		Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>		<span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>		<span class="hljs-keyword">return</span> proxy;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>	<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span><br>	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>	<span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>		<span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>				((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>	<span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>		Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;<br>			<span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="InstantiationAwareBeanPostProcessor的作用"><a href="#InstantiationAwareBeanPostProcessor的作用" class="headerlink" title="InstantiationAwareBeanPostProcessor的作用"></a>InstantiationAwareBeanPostProcessor的作用</h3><p>简述：postProcessBeforeInstantiation() 加载事务和AOP的切面并放到缓存中</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aop%E6%BA%90%E7%A0%81%E4%B9%8BInstantiationAwareBeanPostProcessor%E7%9A%84%E4%BD%9C%E7%94%A8.svg" alt="aop源码之InstantiationAwareBeanPostProcessor的作用"></p>
<h3 id="BeanPostProcessor的作用"><a href="#BeanPostProcessor的作用" class="headerlink" title="BeanPostProcessor的作用"></a>BeanPostProcessor的作用</h3><p>简述：postProcessAfterInitialization() 判断可以之前缓存的切面是否可以应用到类中，代理目标类</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aop%E6%B5%81%E7%A8%8B%E4%B8%89BeanPostProceesor%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B.svg" alt="aop流程三BeanPostProceesor创建代理对象流程"></p>
<h3 id="注解参数"><a href="#注解参数" class="headerlink" title="注解参数"></a>注解参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true,proxyTargetClass = true)</span><br></code></pre></td></tr></table></figure>

<h4 id="proxyTargetClass"><a href="#proxyTargetClass" class="headerlink" title="proxyTargetClass"></a>proxyTargetClass</h4><p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210704164725796.png" alt="image-20210704164725796"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//判断容器的类型ConfigurableListableBeanFactory</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>.beanFactory, beanName, beanClass);<br>		&#125;<br>        <br>        <span class="hljs-comment">//创建代理工程</span><br>		ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>		proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);<br>        <br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 默认配置下，或用户显式配置 proxy-target-class = &quot;false&quot; 时，</span><br><span class="hljs-comment">         * 这里的 proxyFactory.isProxyTargetClass() 也为 false</span><br><span class="hljs-comment">         */</span><br>		<span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>			<span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;<br>				proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);<br>			&#125;<br>			<br>			<span class="hljs-keyword">else</span> &#123;<br>			    <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 检测 beanClass 是否实现了接口，若未实现，则将 </span><br><span class="hljs-comment">             * proxyFactory 的成员变量 proxyTargetClass 设为 true</span><br><span class="hljs-comment">             */</span><br>				evaluateProxyInterfaces(beanClass, proxyFactory);<br>			&#125;<br>		&#125;<br>        <br>        <span class="hljs-comment">//获取容器中的方法增强器</span><br>		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);<br>		proxyFactory.addAdvisors(advisors);<br>		proxyFactory.setTargetSource(targetSource);<br>		customizeProxyFactory(proxyFactory);<br><br>		proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);<br>		<span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;<br>			proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);<br>		&#125;<br>        <br>        <span class="hljs-comment">//创建代理对象</span><br>		<span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> createAopProxy().getProxy(classLoader);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 判断使用哪种方式生成代理类</span><br><span class="hljs-comment">            *  optimize 控制通过cglib创建的代理是否使用激进的优化策略(仅适用于CGLIB，对JDK动态代理无效)</span><br><span class="hljs-comment">            *  proxyTargetClass 是否直接代理目标类</span><br><span class="hljs-comment">            *  hasNoUserSuppliedProxyInterfaces 判断有没有用户自定义的代理接口</span><br><span class="hljs-comment">    	*/</span><br><br>		<span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>			Class&lt;?&gt; targetClass = config.getTargetClass();<br>			<span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>						<span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>			&#125;<br>			<span class="hljs-comment">//本类是否接口 注意，一般而言不会进入这个分支</span><br>			<span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>			    <span class="hljs-comment">//jdk代理</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>			&#125;<br>			<span class="hljs-comment">//cglib代理</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>		    jdk代理<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>			logger.debug(<span class="hljs-string">&quot;Creating JDK dynamic proxy: target source is &quot;</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());<br>		&#125;<br>		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);<br>		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>		<span class="hljs-comment">//创建jdk代理对象</span><br>		<span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);<br>	&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="exposeProxy"><a href="#exposeProxy" class="headerlink" title="exposeProxy"></a>exposeProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...div&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;div result:&#123;&#125;&quot;</span>,x / y);<br>        <span class="hljs-keyword">return</span> x / y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...add&quot;</span>);<br>        Calculator proxy =(Calculator) AopContext.currentProxy();<br>        proxy.div(x,y);<br><br>        log.info(<span class="hljs-string">&quot;add result:&#123;&#125;&quot;</span>,x+y);<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    @EnableAspectJAutoProxy(exposeProxy = true)﻿ 这个东东是用来干什么的？没有配置exposeProxy 暴露代理对象的时候我们方法调用,我们在add方法中 通过this来调用本类的方法div()方法的时候，发现div()的方法不会被拦截,而我们配置了后exposeProxy的属性，我们发现可以通过</p>
<p>int retVal = ((Calculate) AopContext.currentProxy()).div(numA,numB);</p>
<p>​    调用的时候，发现了div()方法可以被拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkDynamicAopProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AopProxy</span>, <span class="hljs-title">InvocationHandler</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;	<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>				<span class="hljs-comment">// Make invocation available if necessary.</span><br>				oldProxy = AopContext.setCurrentProxy(proxy);<br>				setProxyContext = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>原理:把这个exposeProxy设置为true，会把代理对象存放在线程变量中,</strong></p>
<p> AopContext.currentProxy())是从线程变量中获取代理对象（源码中分析）</p>
<h1 id="AOP代理对象的执行流程"><a href="#AOP代理对象的执行流程" class="headerlink" title="AOP代理对象的执行流程"></a>AOP代理对象的执行流程</h1><p>调用过程简述：实际调用 Calculator.add 时，实际上调用的是代理对象的对应方法，以JDK代理为例。运用了 责任链模式、代理模式、模板方法</p>
<p>JdkDynamicAopProxy#invoke</p>
<ol>
<li>进行一些列判断</li>
<li>判断是否暴露代理对象<ol>
<li>是则把本代理对象设置进入上下文</li>
</ol>
</li>
<li>获取调用方法上的拦截器链chain = getInterceptorsAndDynamicInterceptionAdvice<ol>
<li>缓存获取</li>
<li>获取代理类Advised 保存的所有advisors，遍历根据pointcut匹配该方法的advisor</li>
</ol>
</li>
<li>chain为空，则反射调用目标方法</li>
<li>chain不为空 new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain).proceed();<ol>
<li>ExposeInvocationInterceptor.invoke(this)</li>
<li>AspectJAfterThrowingAdvice.invoke(this)</li>
<li>AfterReturnAdvice.invoke(this)</li>
<li>AspectJAfterAdvice.invoke(this)</li>
<li>AspectJmethodBeforeAdvice.invoke(this)</li>
<li>执行before方法</li>
<li>mi.proceed() 目标方法</li>
<li>执行finally，执行后置通知(after)</li>
<li>返回通知/异常通知</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		MethodInvocation invocation;<br>		Object oldProxy = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;<br><br>		TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.targetSource;<br>		Class&lt;?&gt; targetClass = <span class="hljs-keyword">null</span>;<br>		Object target = <span class="hljs-keyword">null</span>;<br><br>		<span class="hljs-keyword">try</span> &#123;<br>		  <br>			Object retVal;<br>            <br>            <span class="hljs-comment">//是否暴露代理对象</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>				<span class="hljs-comment">//把代理对象添加到TheadLocal中</span><br>				oldProxy = AopContext.setCurrentProxy(proxy);<br>				setProxyContext = <span class="hljs-keyword">true</span>;<br>			&#125;<br><br>            <span class="hljs-comment">//获取被代理对象</span><br>			target = targetSource.getTarget();<br>			<span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>			    <span class="hljs-comment">//设置被代理对象的class</span><br>				targetClass = target.getClass();<br>			&#125;<br><br>			<span class="hljs-comment">//把增强器转为方法拦截器链</span><br>			List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br><br>		    <span class="hljs-comment">//若方法拦截器链为空</span><br>			<span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>                <span class="hljs-comment">//通过反射直接调用目标方法</span><br>				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">//创建方法拦截器调用链条</span><br>				invocation = <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);<br>				<span class="hljs-comment">//执行拦截器链</span><br>				retVal = invocation.proceed();<br>			&#125;<br><br>			<span class="hljs-comment">//获取方法的返回值类型</span><br>			Class&lt;?&gt; returnType = method.getReturnType();<br>			<span class="hljs-keyword">if</span> (retVal != <span class="hljs-keyword">null</span> &amp;&amp; retVal == target &amp;&amp;<br>					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;<br>					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>				<span class="hljs-comment">//如果方法返回值为 this，即 return this; 则将代理对象 proxy 赋值给 retVal </span><br>				retVal = proxy;<br>			&#125;<br>			<span class="hljs-comment">//如果返回值类型为基础类型，比如 int，long 等，当返回值为 null，抛出异常</span><br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopInvocationException(<br>						<span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>			&#125;<br>			<span class="hljs-keyword">return</span> retVal;<br>		&#125;<br>		<span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>				<span class="hljs-comment">// Must have come from TargetSource.</span><br>				targetSource.releaseTarget(target);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>				<span class="hljs-comment">// Restore old proxy.</span><br>				AopContext.setCurrentProxy(oldProxy);<br>			&#125;<br>		&#125;<br>	&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">=====================org.springframework.aop.framework.AdvisedSupport#getInterceptorsAndDynamicInterceptionAdvice===========<br>把增强器中转为方法拦截器链<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br>		<span class="hljs-comment">//从缓存中获取缓存key 第一次肯定获取不到</span><br>		MethodCacheKey cacheKey = <span class="hljs-keyword">new</span> MethodCacheKey(method);<br>		<span class="hljs-comment">//通过cacheKey获取缓存值</span><br>		List&lt;Object&gt; cached = <span class="hljs-keyword">this</span>.methodCache.get(cacheKey);<br>		<br>		<span class="hljs-comment">//从缓存中没有获取到</span><br>		<span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;<br>		    <span class="hljs-comment">//获取所有的拦截器</span><br>			cached = <span class="hljs-keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>					<span class="hljs-keyword">this</span>, method, targetClass);<br>		    <span class="hljs-comment">//放入缓存.....</span><br>			<span class="hljs-keyword">this</span>.methodCache.put(cacheKey, cached);<br>		&#125;<br>		<span class="hljs-keyword">return</span> cached;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">=====================org.springframework.aop.framework.AdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice====<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			Advised config, Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br><br>	    <span class="hljs-comment">//创建拦截器集合长度是增强器的长度</span><br>		List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);<br>		<br>		Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-keyword">null</span> ? targetClass : method.getDeclaringClass());<br>		<span class="hljs-keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);<br>		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();<br>        <br>        <span class="hljs-comment">//遍历所有的增强器集合</span><br>		<span class="hljs-keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;<br>			<span class="hljs-comment">//判断增强器是不是PointcutAdvisor</span><br>			<span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>				<span class="hljs-comment">//把增强器转为PointcutAdvisor</span><br>				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;<br>				<span class="hljs-comment">//通过方法匹配器对增强器进行匹配</span><br>				<span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;<br>					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();<br>					<span class="hljs-comment">//能够匹配</span><br>					<span class="hljs-keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;<br>						<span class="hljs-comment">//把增强器转为拦截器</span><br>						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);<br>						<span class="hljs-keyword">if</span> (mm.isRuntime()) &#123;<br>							<span class="hljs-comment">// Creating a new object instance in the getInterceptors() method</span><br>							<span class="hljs-comment">// isn&#x27;t a problem as we normally cache created chains.</span><br>							<span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;<br>								interceptorList.add(<span class="hljs-keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">else</span> &#123;<br>							interceptorList.addAll(Arrays.asList(interceptors));<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;<br>				<span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;<br>					Interceptor[] interceptors = registry.getInterceptors(advisor);<br>					interceptorList.addAll(Arrays.asList(interceptors));<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				Interceptor[] interceptors = registry.getInterceptors(advisor);<br>				interceptorList.addAll(Arrays.asList(interceptors));<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">return</span> interceptorList;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210710173303233.png" alt="image-20210710173303233"></p>
<h1 id="AOP切面如何工作"><a href="#AOP切面如何工作" class="headerlink" title="AOP切面如何工作"></a>AOP切面如何工作</h1><h2 id="第一步：（AOP的概念和如何启用）"><a href="#第一步：（AOP的概念和如何启用）" class="headerlink" title="第一步：（AOP的概念和如何启用）"></a>第一步：（AOP的概念和如何启用）</h2><p>第一点:先跟他说 aop 是什么东西  vs oop<br>第二点:跟他把aop 的基本概念说清楚 ?<br>第三点:@EnableAspectJAutoProxy=====&gt; 导入了AnnotationAwareAspectJAutoProxyCreator组件<br>我们分析出AnnotationAwareAspectJAutoProxyCreator 的继承关系图发现了他具有<br>BeanPostProcessor接口特性和InstantiationAwareBeanPostProcessor的特性.<br>我们发现InstantiationAwareBeanPostProcessor 在实例化之前(调用构造方法之前)执行的.<br>创建第一个bean，根据Bean的生命周期中的createBean的环节<br>resolveBeforeInstantiation连触发我的InstantiationAwareBeanPostProcessor的的before方法.<br>此事在这个环节就会去把我们的切面信息(@Aspectj)的信息找出来 然后进行缓存.</p>
<h2 id="第二步：-创建代理对象的过程"><a href="#第二步：-创建代理对象的过程" class="headerlink" title="第二步：(创建代理对象的过程)"></a>第二步：(创建代理对象的过程)</h2><p>BeanPostProcessor .afterinItialize方法中<br>    创建要切的对象的时候,根据方法进行匹配去找自己的切面(增强器),然后把增强器和被切的对象创成一个代理对象.</p>
<h2 id="第三步-代理对象调用过程（jdk代理-，cglib代理）-proxyTragetClass来指定是否固定cglib"><a href="#第三步-代理对象调用过程（jdk代理-，cglib代理）-proxyTragetClass来指定是否固定cglib" class="headerlink" title="第三步: 代理对象调用过程（jdk代理 ，cglib代理） proxyTragetClass来指定是否固定cglib"></a>第三步: 代理对象调用过程（jdk代理 ，cglib代理） proxyTragetClass来指定是否固定cglib</h2><p>通过责任链模式+递归的来进行调用<br>先执行我们的<br>异常通知…….(catch里面执行异常通知的方法)<br>返回通知:(由于正是在这里返回通知中没有进行任何的try catch处理，，，，那么程序抛出异常 就不会执行返回通知的方法而是直接执行到异常通知了)<br>后置通知:正是因为在后置通知中,代码在finally里中 所以他才是总是被执行的……<br>前置通知:执行我们的前置通知.<br>递归终止条件满足:执行我们的目标方法:<br>1、前置方法<br>2、后置通知<br>3、返回通知/异常通知</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring06-事务原码</title>
    <url>/2021/07/10/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/</url>
    <content><![CDATA[<h1 id="事物概念解析"><a href="#事物概念解析" class="headerlink" title="事物概念解析"></a>事物概念解析</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>​    事务是逻辑上的一组执行单元，要么都执行，要么都不执行.</p>
<h2 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h2><p>​    <img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210711230028299.png" alt="image-20210711230028299"></p>
<p> <strong>什么是ACID</strong>  </p>
<p>   ACID是指数据库管理系统DBMS中事物所具有四个特性</p>
<ol>
<li><p>​    原子性：Automicity</p>
<p>操作不能背分割，要么都成功，要么都失败，若事务出错了，那么事务就会回滚。</p>
</li>
<li><p>​    一致性：Consistency</p>
<p>数据库一直处于一致的状态，事务开始前是一个一致状态，结束后是另一个一致状态</p>
</li>
<li><p>​    隔离性：Isolation</p>
<p>一个事务的影响在该事务提交前对其它事务是不可见的</p>
</li>
<li><p>​    持久性：Durablility</p>
<p>若事务已经提交了，那么就回在数据库中永久的保存下来</p>
</li>
</ol>
<h2 id="Spring事务三大接口介绍"><a href="#Spring事务三大接口介绍" class="headerlink" title="Spring事务三大接口介绍"></a>Spring事务三大接口介绍</h2><h3 id="PlatformTransactionManager：事务管理器"><a href="#PlatformTransactionManager：事务管理器" class="headerlink" title="PlatformTransactionManager：事务管理器"></a>PlatformTransactionManager：事务管理器</h3><p>​    Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。Spring事务管理器的接口是：<br>​    org.springframework.transaction.PlatformTransactionManager ，<br>​    通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlatformTransactionManager</span> </span>&#123;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物状态</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function">TransactionStatus <span class="hljs-title">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *事物提交</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *事物回滚</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="TransactionDefinition：事物属性的定义"><a href="#TransactionDefinition：事物属性的定义" class="headerlink" title="TransactionDefinition：事物属性的定义"></a>TransactionDefinition：事物属性的定义</h3><p>​    事务定义信息（事务隔离级别、传播行为、超时、只读、回滚）</p>
<p>​    org.springframework.transaction.TransactionDefinition</p>
<p>​    TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量，该接口中的常量信息会在后面依次介绍到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionDefinition</span> </span>&#123;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 支持当前事物，若当前没有事物就创建一个事物</span><br><span class="hljs-comment">	 * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_REQUIRED = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_SUPPORTS = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_MANDATORY = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *创建一个新的事务，如果当前存在事务，则把当前事务挂起</span><br><span class="hljs-comment">     **/</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  以非事务方式运行，如果当前存在事务，则把当前事务挂起</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以非事务方式运行，如果当前存在事务，则抛出异常。</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NEVER = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  表示如果当前正有一个事务在运行中，则该方法应该运行在 一个嵌套的事务中，</span><br><span class="hljs-comment">        被嵌套的事务可以独立于封装事务进行提交或者回滚(保存点)，</span><br><span class="hljs-comment">        如果封装事务不存在,行为就像 PROPAGATION_REQUIRES NEW</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NESTED = <span class="hljs-number">6</span>;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_DEFAULT = -<span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 *最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，</span><br><span class="hljs-comment">	 * 也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能通常情况下也不会用到该级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *使用默认的超时时间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> TIMEOUT_DEFAULT = -<span class="hljs-number">1</span>;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的传播行为</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPropagationBehavior</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的隔离级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIsolationLevel</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回事物的超时时间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTimeout</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回当前是否为只读事物</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的名称</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712001245156.png" alt="image-20210712001245156"></p>
<h3 id="TransactionStatus：事务运行状态"><a href="#TransactionStatus：事务运行状态" class="headerlink" title="TransactionStatus：事务运行状态"></a>TransactionStatus：事务运行状态</h3><p>​    TransactionStatus接口用来记录事务的状态，该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p>
<p>​    PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavepointManager</span>, <span class="hljs-title">Flushable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否为新事物</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNewTransaction</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *是否有保存点</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSavepoint</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *设置为只回滚</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRollbackOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *是否为只回滚</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRollbackOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 *属性</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *判断当前事物是否已经完成</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleted</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h1><h2 id="注入了哪些组件"><a href="#注入了哪些组件" class="headerlink" title="注入了哪些组件"></a>注入了哪些组件</h2><p>​    1、注解导入了TransactionManagementConfigurationSelector</p>
<p>​    2、TransactionManagementConfigurationSelector导入了</p>
<p>​        1)AutoProxyRegistrar：导入了 InfrastructureAdvisorAutoProxyCreator</p>
<p>​        2)ProxyTransactionManagementConfiguration</p>
<p>​                BeanFactoryTransactionAttributeSourceAdvisor</p>
<p>​                TransactionAttributeSource</p>
<p>​                TransactionInterceptor</p>
<p>​                <img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712105211686.png" alt="image-20210712105211686"></p>
<p>因此,EnableTransactionManagement，主要帮我们导入了（默认）4个组件</p>
<ol>
<li>InfrastructureAdvisorAutoProxyCreator <ol>
<li>注意，如果开启了@EnableAspectJAutoProxy，则实际上使用的还是AnnotationAwareAspectJAutoProxyCreator（优先级高）</li>
<li><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712152123224.png" alt="image-20210712152123224"></li>
</ol>
</li>
<li>TransactionAttributeSource 事务属性源</li>
<li>TransactionInterceptor 事务拦截器</li>
<li>BeanFactoryTransactionAttributeSourceAdvisor 事务属性源工厂**==增强器==** </li>
</ol>
<h3 id="InfrastructureAdvisorAutoProxyCreator"><a href="#InfrastructureAdvisorAutoProxyCreator" class="headerlink" title="InfrastructureAdvisorAutoProxyCreator"></a>InfrastructureAdvisorAutoProxyCreator</h3><p>类结构图如下，发现与@EnableAspectJAutoProxy导入的：AnnotationAwareAspectJAutoProxyCreator类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712105627407.png" alt="image-20210712105627407"></p>
<p>结合具体源码得到流程图如下：发现结构和也和AnnotationAwareAspectJAutoProxyCreator类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712110900830.png" alt="image-20210712110900830"></p>
<p>因此Spring事务注解的启动原理与AOP类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.svg" alt="事务源码解析"></p>
<p>Spring事务方法调用了流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> AnnotationConfigApplicationContext<br>refresh()<br><span class="hljs-comment">// 创建剩余的组件</span><br>finishBeanFactoryInitialization(beanFactory);<br><span class="hljs-comment">// 第一次运行时缓存所有@Aspect的增强器且 每次都寻找容器中的Advisor</span><br>AbstractAutoProxyCreator.postProcessBeforeInstantiation() <br>    shouskip()<br>    	<span class="hljs-comment">//找到符合条件的增强器</span><br>    	findEligibleAdvisors<br>    		<span class="hljs-comment">//找到候选的增强器</span><br>    		findCandidateAdvisors()<br>			<span class="hljs-comment">//从第一步中获取能用的增强器</span><br>			findAdvisorsThatCanApply()<br>				getTransactionAttributeSource()<br>                    computeTransactionAttribute()<br>    					<span class="hljs-comment">//查找@Transational注解</span><br>    					findTransactionAttribute<br>    					<span class="hljs-number">1</span>、实现类的目标方法上找<br>    					<span class="hljs-number">2</span>、实现类上找<br>    					<span class="hljs-number">3</span>、原方法上找<br>    					<span class="hljs-number">4</span>、原类上找 	<br><span class="hljs-comment">// 初始化后，判断是否存在增强器，存在则创建动态代理对象</span><br>AbstractAutoProxyCreator.postProcessAfterInitialization()<br></code></pre></td></tr></table></figure>

<h1 id="事务代码运行调用流程"><a href="#事务代码运行调用流程" class="headerlink" title="事务代码运行调用流程"></a>事务代码运行调用流程</h1><p>以下是某个事务方法执行大致过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态代理+责任链+递归 </span><br>JdkDynamicAopProxy.invoke-&gt;MethodInterceptor.invoke()<br>    -&gt;ReflectiveMethodInvocation.proceed()<br>    	-&gt;TransactionInterceptor.invoke() <br>    		-&gt;invokeWithinTransaction<br>    			<span class="hljs-comment">//获取事务属性源</span><br>    			getTransactionAttributeSource();<br>				<span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-comment">//在事务执行</span><br>                    invocation.proceedWithInvocation();<br>                &#125;<span class="hljs-keyword">catch</span>&#123;<br>                    <span class="hljs-comment">//可回滚事务</span><br>                    completeTransactionAfterThrowing(txInfo, ex);<br>                &#125;<br>				<span class="hljs-comment">//提交事务</span><br>				commitTransactionAfterReturning(txInfo);<br>				<br><br></code></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PayService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId,<span class="hljs-keyword">double</span> money)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateProductStore</span><span class="hljs-params">(Integer productId)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountInfoDao accountInfoDao;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductInfoDao productInfoDao;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br>        ((PayService) AopContext.currentProxy()).updateProductStore(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(propagation =Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateProductStore</span><span class="hljs-params">(Integer productId)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            productInfoDao.updateProductInfo(productId);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;内部异常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.tx&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring-study&quot;</span>);<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext ioc = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TxConfig.class);<br>        String[] names = ioc.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>        PayService payService = ioc.getBean(PayService.class);<br>        payService.pay(<span class="hljs-string">&quot;123456789&quot;</span>,<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.tx&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring-study&quot;</span>);<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如代码所示</p>
<p>​    payservice.pay()  隔离级别是 Propagation.REQUIRED,加入事务：如果不存在事务，新建事务，存在事务则加入该事务</p>
<p>​    payService.updateProductStore()  隔离级别是 Propagation.REQUIRES_NEW 新建事务：不管是否存在事务，新建一个事务</p>
<p>具体执行过程如下</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E7%89%A9%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE-1626104047827.svg" alt="事物流程简图"></p>
<p>穷举所有情况：</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E7%89%A9%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.svg" alt="事物代理对象调用流程图"></p>
<h1 id="事务提交后执行的原理"><a href="#事务提交后执行的原理" class="headerlink" title="事务提交后执行的原理"></a>事务提交后执行的原理</h1><p>案例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VoidSupplier</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池execute</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(String threadPoolName, VoidSupplier supplier)</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = SpringUtil.getBean(threadPoolName, ThreadPoolTaskExecutor.class);<br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                supplier.get();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                log.error(<span class="hljs-string">&quot;Unexpected error occurred invoking thread pool execute&quot;</span>, e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalUtil</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource MY_DATA_SOURCE;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        MY_DATA_SOURCE = dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            supplier.get();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                supplier.get();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务提交后异步操作</span><br><span class="hljs-comment">     * 可指定线程池</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName 线程池名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier       执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncAfterCommit</span><span class="hljs-params">(String threadPoolName,VoidSupplier supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            ThreadPoolUtil.execute(threadPoolName, supplier);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                ThreadPoolUtil.execute(threadPoolName, supplier);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>其中关键代码TransactionalUtil.afterCommit的原理是什么，我们来一步一步分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 1. 如果当前线程没有开启事务，将立即进行操作</span><br><span class="hljs-comment">    * 2. 事务提交后，在当前线程执行任务操作</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//1、判断当前线程是否开启了事务</span><br>       <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>           supplier.get();<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>           <span class="hljs-comment">//2. 事务提交后，在当前线程执行任务操作</span><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>               supplier.get();<br>           &#125;<br>       &#125;);<br>   &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSynchronizationActive</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (synchronizations.get() != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第1处标注的原理是，以payservice.pay 举例，方法开启了事务，则在执行代理对象执行时</p>
<ul>
<li>invokeWithinTransaction<ul>
<li>createTransactionIfNecessary<ul>
<li>status = tm.getTransaction(txAttr);<ul>
<li>doGetTransaction<ul>
<li>isExistingTransaction(transaction)</li>
<li>suspend(null)(挂机事务)由于不存在事务，不需要挂起当前的</li>
<li>newTransactionStatus创建一个事务状态<ul>
<li>doBegin</li>
<li>prepareSynchronization</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareSynchronization</span><span class="hljs-params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (status.isNewSynchronization()) &#123;<br>		<span class="hljs-comment">//激活事务</span><br>		TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());          <br>		<span class="hljs-comment">//事务隔离级别</span><br>		TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<br>				definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?<br>						definition.getIsolationLevel() : <span class="hljs-keyword">null</span>);<br>		<span class="hljs-comment">//判断是否为只读</span><br>		TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())	<br>		<span class="hljs-comment">//事务名称</span><br>           TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());<br>		<span class="hljs-comment">//初始化同步：就是在这里初始化事务同步回调接口</span><br>		TransactionSynchronizationManager.initSynchronization();<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSynchronization</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br>	<span class="hljs-keyword">if</span> (isSynchronizationActive()) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Cannot activate transaction synchronization - already active&quot;</span>);<br>	&#125;<br>	logger.trace(<span class="hljs-string">&quot;Initializing transaction synchronization&quot;</span>);<br>	synchronizations.set(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第2处标注的原理是</p>
<p>invokeWithinTransaction</p>
<ul>
<li>createTransactionIfNecessary</li>
<li>retVal = invocation.proceedWithInvocation();</li>
<li>commitTransactionAfterReturning(txInfo); 目标方法执行成功，触发事务提交<ul>
<li>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<ul>
<li>processCommit(defStatus);<ul>
<li>triggerAfterCommit(status);<ul>
<li>TransactionSynchronizationUtils.triggerAfterCommit();<ul>
<li>invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());</li>
</ul>
</li>
</ul>
</li>
<li>cleanupAfterCompletion(status);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAfterCommit</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> List&lt;TransactionSynchronization&gt; synchronizations)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (synchronizations != <span class="hljs-keyword">null</span>) &#123;<br>		<span class="hljs-keyword">for</span> (TransactionSynchronization synchronization : synchronizations) &#123;<br>               <span class="hljs-comment">//触发执行我们手动新增的TransactionSynchronizationAdaptor的afterCommit</span><br>			synchronization.afterCommit();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>小坑：最好不要在TransactionSynchronization.afterCommit方法里执行DML操作，如果在事务提交后抛出异常，这个时候对于对于</p>
<p>DataSourceTransactionManager<br>    cleanupAfterCompletion(status)  会把连接设置为自动提交，导致DML操作回滚不了（原事务已提交，afterCommit 方法报错，afterCommit 的数据操作回滚不了）</p>
<p>JPASourceTransactionManager</p>
<p>​    正常回归</p>
<p>最佳时间：</p>
<p>​    1、尽量不在aftercommit里做事务操作，</p>
<p>​    2、如果有，也是现实声明为 @Transactional(propagation =Propagation.REQUIRES_NEW)</p>
<p>​    3、在aftercommit手动捕获异常，避免aftercommit的操作无法回滚</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring07-切面的应用</title>
    <url>/2021/07/11/Spring07-%E5%88%87%E9%9D%A2%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Spring切面应用"><a href="#Spring切面应用" class="headerlink" title="Spring切面应用"></a>Spring切面应用</h1><h2 id="多数据源插件-后续补充"><a href="#多数据源插件-后续补充" class="headerlink" title="多数据源插件(后续补充)"></a>多数据源插件(后续补充)</h2><h2 id="分布式锁插件"><a href="#分布式锁插件" class="headerlink" title="分布式锁插件"></a>分布式锁插件</h2><p>思路：</p>
<p>1、生命一个注解</p>
<p>2、切面环绕通知切这个注解</p>
<p>3、使用redis做分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DistributedLock &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁过期时间 1小时</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">expireMillis</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 3600000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁尝试时间 1分钟</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">timeoutMillis</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 60000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的主key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">mainKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的spEL格式Key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">spelKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无法获得锁时，是否跳过</span><br><span class="hljs-comment">     * true: 跳过</span><br><span class="hljs-comment">     * false: 默认报错</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">skipWhenCanNotGetLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedLockAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisDistributedLock redisDistributedLock;<br><br><br>    String COM_LOCK = <span class="hljs-string">&quot;com:lock:&quot;</span>;<br><br><br>    String COM_LOCK_FEIGN_OAUTH_TOKEN = COM_LOCK + <span class="hljs-string">&quot;token:feign_oauth:&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有被<span class="hljs-doctag">@DistributedLock</span>注解的方法，使用分布式锁，限制一个时间内只有一个任务在执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> distributedLock</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(distributedLock)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point, DistributedLock distributedLock)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String key = generateLockKey(point, distributedLock.mainKey(), distributedLock.spelKey());<br><br>        <span class="hljs-comment">// 判断无法获得锁的时候，是否可以跳过程序</span><br>        <span class="hljs-keyword">if</span> (distributedLock.skipWhenCanNotGetLock() &amp;&amp; redisDistributedLock.isExist(key)) &#123;<br>            log.warn(<span class="hljs-string">&quot;DistributedLock 无法获得锁: &#123;&#125;, 锁已存在, 程序将跳过执行&quot;</span>, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> tryLock = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tryLock = redisDistributedLock.tryLock(key, distributedLock.expireMillis(),<br>                    distributedLock.timeoutMillis());<br>            <span class="hljs-keyword">if</span> (!tryLock) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DistributedLockConcurrentException(<span class="hljs-string">&quot;@DistributedLock获取锁失败，已有相同任务在运行&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> point.proceed();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (tryLock) &#123;<br>                redisDistributedLock.unLock(key);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成分布式锁的key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateLockKey</span><span class="hljs-params">(ProceedingJoinPoint point, String mainKey, String spelKey)</span> </span>&#123;<br>        MethodSignature signature = AopUtil.getMethodSignature(point);<br><br>        String targrtMainKey;<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(mainKey)) &#123;<br>            String className = AopUtil.getClassName(point);<br>            String methodName = signature.getName();<br>            targrtMainKey = className + <span class="hljs-string">&quot;_&quot;</span> + methodName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            targrtMainKey = mainKey;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(spelKey)) &#123;<br>            <span class="hljs-keyword">return</span> COM_LOCK + targrtMainKey;<br>        &#125;<br><br>        Method method = signature.getMethod();<br>        Object[] args = point.getArgs();<br>        String targetSpelKey = AopUtil.parseSpelKey(spelKey, method, args, String.class);<br><br>        <span class="hljs-keyword">return</span> COM_LOCK + targrtMainKey + <span class="hljs-string">&quot;_&quot;</span> + targetSpelKey;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDistributedLock</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key           key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis  锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis 获取锁最大等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> tryLock(key, macThreadId, expireMillis, timeoutMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   获取锁尝试次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLockCnt</span><span class="hljs-params">(String key, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> tryLockCnt(key, macThreadId, tryLockCnt, expireMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> unLock(key, macThreadId);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 延迟释放锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireSecond expireSecond</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLockLater</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireSecond)</span> </span>&#123;<br>        String signature = getThreadSignature();<br>        <span class="hljs-keyword">return</span> unLockLater(key, signature, expireSecond);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 机器锁</span><br><span class="hljs-comment">     * 锁住机器的MAC地址</span><br><span class="hljs-comment">     * 只允许同一台机器执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁的时间，单位秒，null表示锁1天</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMacLock</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> tryLock(key, mac, expireMillis, timeoutMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得机器锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   获取锁尝试次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMacLockCnt</span><span class="hljs-params">(String key, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> tryLockCnt(key, mac, tryLockCnt, expireMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放机器锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unMacLock</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> unLock(key, mac);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断锁是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExist</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-keyword">return</span> redisTemplate.hasKey(lockKey);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁加锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-comment">//return eadisSyncCommands.lock(lockKey, requesterId, expireMillis, timeoutMillis);</span><br>        <span class="hljs-comment">// 利用lambda表达式</span><br>        <span class="hljs-keyword">return</span> (Boolean) redisTemplate.execute(<span class="hljs-keyword">new</span> RedisCallback&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doInRedis</span><span class="hljs-params">(RedisConnection redisConnection)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;<br>                <span class="hljs-keyword">long</span> expireAt = System.currentTimeMillis() + expireMillis + <span class="hljs-number">1</span>;<br>                Boolean acquire = redisConnection.setNX(lockKey.getBytes(), String.valueOf(expireAt).getBytes());<br>                <span class="hljs-keyword">if</span> (acquire) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">byte</span>[] value = redisConnection.get(lockKey.getBytes());<br>                    <span class="hljs-keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">long</span> expireTime = Long.parseLong(<span class="hljs-keyword">new</span> String(value));<br>                        <span class="hljs-keyword">if</span> (expireTime &lt; System.currentTimeMillis()) &#123;<br>                            <span class="hljs-comment">// 如果锁已经过期</span><br>                            <span class="hljs-keyword">byte</span>[] oldValue = redisConnection.getSet(lockKey.getBytes(), String.valueOf(System.currentTimeMillis() + expireMillis + <span class="hljs-number">1</span>).getBytes());<br>                            <span class="hljs-comment">// 防止死锁</span><br>                            <span class="hljs-keyword">return</span> Long.parseLong(<span class="hljs-keyword">new</span> String(oldValue)) &lt; System.currentTimeMillis();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId  锁标识</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   尝试获取锁的次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLockCnt</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; tryLockCnt) &#123;<br>            <span class="hljs-keyword">boolean</span> tryLock = tryLock(key, requesterId, expireMillis, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (tryLock) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == tryLockCnt) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.warn(<span class="hljs-string">&quot;获得分布式锁时，尝试睡眠失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁释放</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String key, String requesterId)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-keyword">return</span> redisTemplate.delete(lockKey);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁延迟释放</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireSecond</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLockLater</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-keyword">long</span> expireSecond)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        Boolean expire = redisTemplate.expire(lockKey, expireSecond, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == expire ? <span class="hljs-keyword">false</span> : expire;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得线程标识</span><br><span class="hljs-comment">     * 只有线程标识相同，才能解锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getThreadSignature</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//String runtimeMxBeanName = ServerRunTimeUtil.getRuntimeMxBeanName();</span><br>        <span class="hljs-comment">//TODO 是否可重写</span><br>        String runtimeMxBeanName = <span class="hljs-string">&quot;&quot;</span>;<br>        String currentThreadId = String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-keyword">return</span> mac + <span class="hljs-string">&quot;_&quot;</span> + runtimeMxBeanName + <span class="hljs-string">&quot;_&quot;</span> + currentThreadId;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成锁的key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateKey</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopUtil</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title">getClassFromJoinPoint</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> point.getTarget().getClass();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title">getMethodFromJoinPoint</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        Signature signature = point.getSignature();<br>        MethodSignature methodSignature = (MethodSignature) signature;<br>        <span class="hljs-keyword">return</span> methodSignature.getMethod();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object[] getMethodArgsFromJoinPoint(ProceedingJoinPoint point) &#123;<br>        <span class="hljs-keyword">return</span> point.getArgs();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得MethodSignature</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodSignature <span class="hljs-title">getMethodSignature</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == point) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Signature pointSignature = point.getSignature();<br>        <span class="hljs-keyword">if</span> (!(pointSignature <span class="hljs-keyword">instanceof</span> MethodSignature)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (MethodSignature) pointSignature;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得Class 全路径</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == point) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Object target = point.getTarget();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Class&lt;?&gt; aClass = target.getClass();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == aClass) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> aClass.getName();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取spEL表达式代表的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">parseSpelKey</span><span class="hljs-params">(String key, Method method, Object[] args, Class&lt;T&gt; clazz)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//获取被拦截方法参数名列表(使用Spring支持类库)</span><br>        LocalVariableTableParameterNameDiscoverer u = <span class="hljs-keyword">new</span> LocalVariableTableParameterNameDiscoverer();<br>        String[] paraNameArr = u.getParameterNames(method);<br><br>        <span class="hljs-comment">//使用SPEL进行key的解析</span><br>        ExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser();<br>        <span class="hljs-comment">//SPEL上下文</span><br>        StandardEvaluationContext context = <span class="hljs-keyword">new</span> StandardEvaluationContext();<br>        <span class="hljs-comment">//把方法参数放入SPEL上下文中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paraNameArr.length; i++) &#123;<br>            context.setVariable(paraNameArr[i], args[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parser.parseExpression(key).getValue(context, clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@DistributedLock(spelKey = &quot;#accountId&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br><br><span class="hljs-comment">//        TransactionalUtil.afterCommit(() -&gt; &#123;</span><br><span class="hljs-comment">//            ((PayService) AopContext.currentProxy()).updateProductStore(1);</span><br><span class="hljs-comment">//        &#125;);</span><br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="异步事务插件（事务提交后执行）"><a href="#异步事务插件（事务提交后执行）" class="headerlink" title="异步事务插件（事务提交后执行）"></a>异步事务插件（事务提交后执行）</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VoidSupplier</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池execute</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(String threadPoolName, VoidSupplier supplier)</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = SpringUtil.getBean(threadPoolName, ThreadPoolTaskExecutor.class);<br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                supplier.get();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                log.error(<span class="hljs-string">&quot;Unexpected error occurred invoking thread pool execute&quot;</span>, e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalUtil</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource MY_DATA_SOURCE;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        MY_DATA_SOURCE = dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            supplier.get();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                supplier.get();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务提交后异步操作</span><br><span class="hljs-comment">     * 可指定线程池</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName 线程池名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier       执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncAfterCommit</span><span class="hljs-params">(String threadPoolName,VoidSupplier supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            ThreadPoolUtil.execute(threadPoolName, supplier);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                ThreadPoolUtil.execute(threadPoolName, supplier);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AsyncAfterCommit &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> DEFAULT_EXECUTOR_POOL</span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAfterCommitAspect</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AsyncUncaughtExceptionHandler syncUncaughtExceptionHandler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有被<span class="hljs-doctag">@AsyncAfterCommit</span>注解的方法，</span><br><span class="hljs-comment">     * 标注这个注解的方法，拥有提交事务后，异步执行的功能</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> asyncAfterCommit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(asyncAfterCommit)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point, AsyncAfterCommit asyncAfterCommit)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String value = asyncAfterCommit.value();<br>        Method method = AopUtil.getMethodFromJoinPoint(point);<br>        Class&lt;?&gt; returnType = method.getReturnType();<br><br>        <span class="hljs-comment">// 由于future模式通常需要使用get方法，而【提交事务后】异步执行，无法在方法内获得运算结果。基于此，不提供future模式</span><br>        <span class="hljs-keyword">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AsyncAfterException(<span class="hljs-string">&quot;@AsyncAfterCommit不支持ListenableFuture模式&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Future.class.isAssignableFrom(returnType)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AsyncAfterException(<span class="hljs-string">&quot;@AsyncAfterCommit不支持Future模式&quot;</span>);<br>        &#125;<br><br>        TransactionalUtil.asyncAfterCommit(value, () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                point.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException var2) &#123;<br>                handleError(var2.getCause(), method, point.getArgs());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>                handleError(var3, method, point.getArgs());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(Throwable ex, Method method, Object... params)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            syncUncaughtExceptionHandler.handleUncaughtException(ex, method, params);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>            log.error(<span class="hljs-string">&quot;Exception handler for async method &#x27;&quot;</span> + method.toGenericString() + <span class="hljs-string">&quot;&#x27; threw unexpected &quot;</span> +<br>                    <span class="hljs-string">&quot;exception itself&quot;</span>, var5);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> 	<span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@DistributedLock(spelKey = &quot;#accountId&quot;)</span><br>    <span class="hljs-meta">@AsyncAfterCommit</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br><br><span class="hljs-comment">//        TransactionalUtil.afterCommit(() -&gt; &#123;</span><br><span class="hljs-comment">//            ((PayService) AopContext.currentProxy()).updateProductStore(1);</span><br><span class="hljs-comment">//        &#125;);</span><br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>    &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>定制化报错通知报警</p>
<p>思路：</p>
<p>1、定义一个注解BizService</p>
<p>2、声明一个切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BizServiceAspect</span> </span>&#123;<br><br>    <span class="hljs-comment">//切自定义注解</span><br>    <span class="hljs-meta">@Pointcut(&quot;@within(自定义注解)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bizServiceCut</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;bizServiceCut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object[] args = proceedingJoinPoint.getArgs();<br>            <span class="hljs-keyword">return</span> proceedingJoinPoint.proceed(args);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 发布告警事件</span><br>                Class bizClazz = proceedingJoinPoint.getTarget().getClass();<br>                Object source = proceedingJoinPoint.getThis();<br>                Signature sig = proceedingJoinPoint.getSignature();<br>                <span class="hljs-keyword">if</span> (sig <span class="hljs-keyword">instanceof</span> MethodSignature) &#123;<br>                    MethodSignature targetMethod = (MethodSignature) sig;<br>                    Method bizMethod = bizClazz.getMethod(targetMethod.getName(), targetMethod.getParameterTypes());<br>                    AppContext.publishEvent(<span class="hljs-keyword">new</span> BizAlertEvent(source, bizClazz, bizMethod, getLogTranceId(), e));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                log.warn(<span class="hljs-string">&quot;告警事件发布失败:&quot;</span>, e1);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getLogTranceId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MDC.get(Constant.LOG_TRACE_ID);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="接口出入参日志打印"><a href="#接口出入参日志打印" class="headerlink" title="接口出入参日志打印"></a>接口出入参日志打印</h2><p>利用切面的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebLogAspect</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(WebLogAspect.class);    <br>    <span class="hljs-comment">/** 以 controller 包下定义的所有请求为切入点 */</span>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * com.ruankao.controller..*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">webLog</span><span class="hljs-params">()</span> </span>&#123;&#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 在切点之前织入    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@Before(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        <span class="hljs-comment">// 开始打印请求日志    </span><br>        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    <br>        HttpServletRequest request = attributes.getRequest();    <br>        <span class="hljs-comment">// 打印请求相关参数    </span><br>        logger.info(<span class="hljs-string">&quot;========================================== Start ==========================================&quot;</span>);    <br>        <span class="hljs-comment">// 打印请求 url    </span><br>        logger.info(<span class="hljs-string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());    <br>        <span class="hljs-comment">// 打印 Http method    </span><br>        logger.info(<span class="hljs-string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());    <br>        <span class="hljs-comment">// 打印调用 controller 的全路径以及执行方法    </span><br>        logger.info(<span class="hljs-string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());    <br>        <span class="hljs-comment">// 打印请求的 IP    </span><br>        logger.info(<span class="hljs-string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());    <br>        <span class="hljs-comment">// 打印请求入参    </span><br>        logger.info(<span class="hljs-string">&quot;Request Args   : &#123;&#125;&quot;</span>, joinPoint.getArgs());<br>    &#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 在切点之后织入    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@After(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <br>        logger.info(<span class="hljs-string">&quot;=========================================== End ===========================================&quot;</span>);    <br>        <span class="hljs-comment">// 每个请求之间空一行    </span><br>        logger.info(<span class="hljs-string">&quot;&quot;</span>);    <br>    &#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 环绕    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proceedingJoinPoint    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@Around(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();    <br>        Object result = proceedingJoinPoint.proceed();    <br>        <span class="hljs-comment">// 打印出参    </span><br>        logger.info(<span class="hljs-string">&quot;Response Args  : &#123;&#125;&quot;</span>,JSON.toJSON(result));<br>        <span class="hljs-comment">// 执行耗时    </span><br>        logger.info(<span class="hljs-string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);    <br>        <span class="hljs-keyword">return</span> result;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用Filter的方式: 重新定义request response，读取内容再写入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(filterName = &quot;logFilter&quot;, urlPatterns = &quot;/*&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> </span>&#123;<br>        HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;<br>        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;<br><br>        <span class="hljs-comment">//转换成代理类</span><br>        ResponseWrapper wrapperResponse = <span class="hljs-keyword">new</span> ResponseWrapper(httpServletResponse);<br>        RequestWrapper requestWrapper = <span class="hljs-keyword">new</span> RequestWrapper(httpServletRequest);<br><br>        <span class="hljs-keyword">long</span> before = System.currentTimeMillis();<br><br>        <span class="hljs-comment">//通过ApplicationContext上下文（spring）找到RequestMappingHandlerMapping这个bean</span><br>        RequestMappingHandlerMapping handlerMapping = ApplicationContextUtil.getBean(RequestMappingHandlerMapping.class);<br>        <span class="hljs-comment">//RequestMappingHandlerMapping是对应url和处理类方法的一个类</span><br>        HandlerExecutionChain handlerChain = handlerMapping.getHandler(requestWrapper);<br>        <span class="hljs-comment">//通过处理链找到对应的HandlerMethod类</span><br>        HandlerMethod handler = (HandlerMethod) handlerChain.getHandler();<br>        <span class="hljs-comment">//HandlerMethod中有bean和method</span><br>        Object bean = handler.getBean();<span class="hljs-comment">//处理请求的类</span><br>        Method method = handler.getMethod();<span class="hljs-comment">//处理请求的方法</span><br><br>        <span class="hljs-comment">// 打印请求相关参数</span><br>        log.info(<span class="hljs-string">&quot;========================================== Start ==========================================&quot;</span>);<br>        <span class="hljs-comment">// 打印请求 url</span><br>        log.info(<span class="hljs-string">&quot;URL            : &#123;&#125;&quot;</span>, httpServletRequest.getRequestURL().toString());<br>        <span class="hljs-comment">// 打印 Http method</span><br>        log.info(<span class="hljs-string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, httpServletRequest.getMethod());<br>        <span class="hljs-comment">// 打印调用 controller 的全路径以及执行方法</span><br>        log.info(<span class="hljs-string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, bean, method);<br>        <span class="hljs-comment">// 打印请求的 IP</span><br>        log.info(<span class="hljs-string">&quot;IP             : &#123;&#125;&quot;</span>, httpServletRequest.getRemoteAddr());<br>        <span class="hljs-comment">// 打印请求入参</span><br>        log.info(<span class="hljs-string">&quot;Request Args   : &#123;&#125;&quot;</span>, JSON.toJSON(requestWrapper.getBody()));<br><br>        log.info(<span class="hljs-string">&quot;=========================================== End ===========================================&quot;</span>);<br>        <span class="hljs-comment">// 每个请求之间空一行</span><br>        log.info(<span class="hljs-string">&quot;&quot;</span>);<br><br>        filterChain.doFilter(requestWrapper, wrapperResponse);<br>        <span class="hljs-comment">//获取返回值</span><br>        <span class="hljs-keyword">byte</span>[] content = wrapperResponse.getContent();<br>        <span class="hljs-comment">// 打印出参</span><br>        log.info(<span class="hljs-string">&quot;Response Args  : &#123;&#125;&quot;</span>, JSON.toJSON(<span class="hljs-keyword">new</span> String(content)));<br>        <span class="hljs-comment">// 执行耗时</span><br>        log.info(<span class="hljs-string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - before);<br><br>        <span class="hljs-comment">//把返回值输出到客户端</span><br>        ServletOutputStream out = httpServletResponse.getOutputStream();<br>        out.write(content);<br>        out.flush();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletResponseWrapper</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ByteArrayOutputStream buffer;<br><br>    <span class="hljs-keyword">private</span> ServletOutputStream out;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ResponseWrapper</span><span class="hljs-params">(HttpServletResponse httpServletResponse)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(httpServletResponse);<br>        buffer = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        out = <span class="hljs-keyword">new</span> WrapperOutputStream(buffer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flushBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;<br>            out.flush();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() <span class="hljs-keyword">throws</span> IOException &#123;<br>        flushBuffer();<br>        <span class="hljs-keyword">return</span> buffer.toByteArray();<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServletOutputStream</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> ByteArrayOutputStream bos;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WrapperOutputStream</span><span class="hljs-params">(ByteArrayOutputStream bos)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bos = bos;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            bos.write(b);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWriteListener</span><span class="hljs-params">(WriteListener arg0)</span> </span>&#123;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String body;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestWrapper</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(request);<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>        InputStream inputStream = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = request.getInputStream();<br>            <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>                bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream));<br>                <span class="hljs-keyword">char</span>[] charBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">128</span>];<br>                <span class="hljs-keyword">int</span> bytesRead = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> ((bytesRead = bufferedReader.read(charBuffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                    stringBuilder.append(charBuffer, <span class="hljs-number">0</span>, bytesRead);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stringBuilder.append(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    inputStream.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bufferedReader.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        body = stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">final</span> ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(body.getBytes());<br>        ServletInputStream servletInputStream = <span class="hljs-keyword">new</span> ServletInputStream() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFinished</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReadListener</span><span class="hljs-params">(ReadListener readListener)</span> </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">return</span> byteArrayInputStream.read();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> servletInputStream;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">this</span>.getInputStream()));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="常见切面-Around-execution表达式"><a href="#常见切面-Around-execution表达式" class="headerlink" title="常见切面@Around execution表达式"></a>常见切面@Around execution表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Around(&quot;@annotation(自定义注解)&quot;)//自定义注解标注在方法上的方法执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;@within(自定义注解)&quot;)//自定义注解标注在的类上；该类的所有方法（不包含子类方法）执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;@within(org.springframework.transaction.annotation.Transactional)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;within(包名前缀.*)&quot;)//com.aop.within包下所有类的所有的方法都会执行(不包含子包) aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;within(com.aop.test.*)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;within(包名前缀..*)&quot;)//com.aop.within包下所有的方法都会执行(包含子包)aop 方法</span><br>如：<span class="hljs-meta">@Around(&quot;within(com.aop.test..*)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;this(java类或接口)&quot;)//实现了该接口的类、继承该类、该类本身的类---的所有方法（包括不是接口定义的方法，但不包含父类的方法）都会执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;this(com.aop.service.TestService)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;target(java类或接口)&quot;)//实现了该接口的类、继承该类、该类本身的类---的所有方法（包括不是接口定义的方法，包含父类的方法）</span><br>如：<span class="hljs-meta">@Around(&quot;this(com.aop.service.TestService)&quot;)</span><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>切面应用</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程01-JMM&amp;volatile</title>
    <url>/2021/08/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&amp;volatile/</url>
    <content><![CDATA[<blockquote>
<p>参考文档：一文解决内存屏障 <a href="https://www.jianshu.com/p/64240319ed60">https://www.jianshu.com/p/64240319ed60</a></p>
</blockquote>
<h1 id="现代计算机理论模型与工作原理"><a href="#现代计算机理论模型与工作原理" class="headerlink" title="现代计算机理论模型与工作原理"></a>现代计算机理论模型与工作原理</h1><h2 id="冯诺依曼计算机模型"><a href="#冯诺依曼计算机模型" class="headerlink" title="冯诺依曼计算机模型"></a>冯诺依曼计算机模型</h2><p>简介：</p>
<p>​    现代计算机模型是基于-冯诺依曼计算机模型 计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存 储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去，直至遇到停止指令。</p>
<h3 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a>计算机五大核心组成部分</h3><ul>
<li>控制器</li>
<li>运算器</li>
<li>存储器</li>
<li>输入</li>
<li>输出</li>
</ul>
<h3 id="冯诺依曼计算机模型图"><a href="#冯诺依曼计算机模型图" class="headerlink" title="冯诺依曼计算机模型图"></a>冯诺依曼计算机模型图</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210829224323237.png" alt="image-20210829224323237"></p>
<h3 id="现代计算机硬件结构原理图"><a href="#现代计算机硬件结构原理图" class="headerlink" title="现代计算机硬件结构原理图"></a>现代计算机硬件结构原理图</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210829224618735.png" alt="image-20210829224618735"></p>
<h1 id="CPU多核缓存架构"><a href="#CPU多核缓存架构" class="headerlink" title="CPU多核缓存架构"></a>CPU多核缓存架构</h1><img src="/images/并发编程01JMM&volatile/image-20210829232930566.png">

<h3 id="CPU内部结构划分"><a href="#CPU内部结构划分" class="headerlink" title="CPU内部结构划分"></a>CPU内部结构划分</h3><ul>
<li>控制单元（包含指令计数器、指令寄存器等）</li>
<li>运算单元</li>
<li>存储单元</li>
</ul>
<p><strong>多CPU</strong></p>
<p>​    一个现代计算机通常由两个或者多个CPU，如果要运行多个程序（<strong>进程</strong>）的话，<strong>假如只有 一个CPU的话，就意味着要经常进行进程上下文切换</strong>，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要<strong>经常进行进程上下文切换，这个代价是很高</strong>的</p>
<p><strong>CPU多核</strong> （<strong>支持进程内同时跑多个线程</strong>）</p>
<p>​    一个现代CPU除了<strong>处理器核心</strong>之外还包括寄存器、L1L2L3缓存这些存储设备、浮点运算 单元、整数运算单元等一些辅助运算设备以及内部总线等。<strong>一个多核的CPU也就是一个CPU上 有多个处理器核心</strong>，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，就意味着<strong>这个程序的不同线程需要经常在CPU之间的外部总线上通信</strong>，<strong>同时还要处理不同CPU之间不同缓存导致数据不一致的问题</strong>，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。</p>
<p><strong>CPU寄存器</strong></p>
<p>​    CPU在寄存器上执行操作的 速度远大于在主存上执行的速度。<strong>这是因为CPU访问寄存器的速度远大于主存。大概是几十到几百倍</strong> </p>
<p><strong>CPU缓存</strong></p>
<p>​    即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于 CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用, 减少CPU的等待时间，提高了系统的效率。 一级Cache(L1 Cache) 二级Cache(L2 Cache) 三级Cache(L3 Cache)，运行速度 寄存器&gt;L1&gt;L2&gt;L3&gt;内存</p>
<p><strong>内存</strong></p>
<p>​    一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得 多</p>
<h1 id="缓存一致性协议（MESI）"><a href="#缓存一致性协议（MESI）" class="headerlink" title="缓存一致性协议（MESI）"></a>缓存一致性协议（MESI）</h1><h2 id="MESI协议的作用"><a href="#MESI协议的作用" class="headerlink" title="MESI协议的作用"></a>MESI协议的作用</h2><p><strong>多线程环境下存在的问题：缓存一致性问题</strong> </p>
<p>​    在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一 块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p>
<p>​    为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、 <strong>MESI</strong>（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</p>
<p>​                                                                    <strong>MESI缓存一致性协议</strong></p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>描述</strong></th>
<th><strong>监听任务</strong></th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>无</td>
</tr>
</tbody></table>
<p> 缓存行：CPU缓存的最小存储单元</p>
<p>总线嗅探机制：多个cpu读取同一份内存变量A到cpu缓存后会嗅探别的cpu对该变量A的读取而修改状态</p>
<p>指令周期内会进行裁决：多个cpu同时向总线递交modified时，指令周期内会裁决A,B哪个线程生效，如果A生效，另一个线程B 标记invalid且已执行过程序（类似代码跑完了，对这个线程来说却实际没有生效）</p>
<h2 id="缓存一致性协议失效的情况："><a href="#缓存一致性协议失效的情况：" class="headerlink" title="缓存一致性协议失效的情况："></a>缓存一致性协议失效的情况：</h2><p>1、要缓存的数据大于一个缓存行的大小，只能加总线锁（一个缓存行可以存多个数据）</p>
<p>2、CPU本身不支持缓存一致性协议    </p>
<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​    现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。<strong>进程是系统分配资源的基本单位</strong></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>​    <strong>现代操作系统调度CPU的最小单元是线程</strong>，也叫轻量级进程 （Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。</p>
<h3 id="线程分为两类"><a href="#线程分为两类" class="headerlink" title="线程分为两类"></a>线程分为两类</h3><ul>
<li><strong>用户线程（User-Level Thread）ULT-对应用户空间</strong><ul>
<li>指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程 是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换， 速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所 有线程）阻塞。<strong>由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</strong> </li>
</ul>
</li>
<li><strong>内核线程(Kernel-Level Tread) KLT-对应内核空间</strong><ul>
<li>线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下 文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。<strong>在 多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度</strong>。由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢 得多，但是仍然比进程的创建和管理操作要快。大多数市场上的操作系统，如Windows， Linux等都支持内核级线程</li>
</ul>
</li>
</ul>
<p>在 4 GB 的内存空间中，只有 3 GB 可以用于用户应用程序。一个进程只能运行 在用户方式（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。在这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈，而内核方式下用的是固定大小的堆栈（一般为一个内存页的大小） 每个进程都有自己的 3 G 用户空间，它们共享1GB的内核空间。当一个进程从用户空间进 入内核空间时，它就不再有自己的进程空间了。<strong>这也就是为什么我们经常说线程上下文切换会 涉及到用户态到内核态的切换原因所在</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830151211718.png"></p>
<h3 id="Java线程与内核线程的关系"><a href="#Java线程与内核线程的关系" class="headerlink" title="Java线程与内核线程的关系"></a>Java线程与内核线程的关系</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830151225845.png" alt="image-20210830151225845"></p>
<h3 id="Java线程生命状态"><a href="#Java线程生命状态" class="headerlink" title="Java线程生命状态"></a>Java线程生命状态</h3><ul>
<li>新建</li>
<li>就绪</li>
<li>运行</li>
<li>终止</li>
<li>阻塞</li>
<li>等待</li>
<li>超时等待</li>
</ul>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830152624403.png" alt="image-20210830152624403"></p>
<h1 id="并发（多线程）的意义"><a href="#并发（多线程）的意义" class="headerlink" title="并发（多线程）的意义"></a>并发（多线程）的意义</h1><h2 id="并发的作用"><a href="#并发的作用" class="headerlink" title="并发的作用"></a>并发的作用</h2><p><strong>1、充分利用多核CPU的计算能力</strong></p>
<blockquote>
<p>​    在单cpu系统中，每一时间点只能有一道程序执行，即微观上这些程序是分时的交替执行，因为分时交替运行的时间是非常短的，只不过给人的感觉是同时运行，在宏观上并发和并行一样都是同时在进行但是在微观上是不一样的。在多个cpu的操作系统中，这些可以并发执行的程序便可以分配到多个处理器（cpu），实现多任务并行执行，就是利用每个处理器来处理一个可以并发执行的程序，这样<strong>多个程序便可以同时执行</strong>。核越多，并行处理的程序越多，可以大大<strong>提高电脑的运行效率</strong>。如果能够合理地使用多线程，将能够缩减复杂应用程序的开发和维护成本，并能提供更好的性能。通过将异步工作流转换为多个序列化工作流，多线程可以更好地对人类的工作和交互方式建模。使用多线程，很多复杂的代码将变得更加直截了当，因此更容易编写、阅读和维护，但是使用多线程也意味着有很大的<strong>风险</strong>。</p>
</blockquote>
<p><strong>2、方便进行业务拆分，提升应用性能</strong></p>
<h2 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h2><p>1、产生频繁的上下文切换</p>
<p>2、多线程安全问题，容器出现死锁，产生的死锁会造成系统功能的阻塞或者不可用</p>
<p>3、代码复杂度提升。。。</p>
<h1 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1><h2 id="JMM概念（Java-Memory-Model）"><a href="#JMM概念（Java-Memory-Model）" class="headerlink" title="JMM概念（Java Memory Model）"></a>JMM概念（Java Memory Model）</h2><p>JMM与JVM内存区域划分是不同的概念层次，JMM描述的是一组规则，通过这种规则控制程序中各个变量在工作内存和主内存的反问方式，JMM是围绕着原子性、有序性、可见性展开的。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830175453639.png" alt="image-20210830175453639"></p>
<h2 id="JMM与硬件内存架构的关系"><a href="#JMM与硬件内存架构的关系" class="headerlink" title="JMM与硬件内存架构的关系"></a>JMM与硬件内存架构的关系</h2><p>​    <strong>JMM模型是依据现代计算机理论模型，以CPU多核缓存架构（硬件内存架构）为基础，屏蔽底层操作系统实现而抽象出来的一种抽象模型</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830175639511.png" alt="image-20210830175639511"></p>
<h2 id="JMM内存交互操作"><a href="#JMM内存交互操作" class="headerlink" title="JMM内存交互操作"></a>JMM内存交互操作</h2><ol>
<li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</li>
<li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li>
<li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li>
<li>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li>
</ol>
<p>现代计算机主要结构组成</p>
<p>​    把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。<strong>但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830181231664.png" alt="image-20210830181231664"></p>
<p>​    </p>
<h2 id="JMM内存同步规则"><a href="#JMM内存同步规则" class="headerlink" title="JMM内存同步规则"></a>JMM内存同步规则</h2><ol>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li>
<li>一个新的<strong>变量只能在主内存中诞生</strong>，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。<strong>lock和unlock必须成对出现</strong>。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li>
</ol>
<h1 id="volatile原理与内存语义"><a href="#volatile原理与内存语义" class="headerlink" title="volatile原理与内存语义"></a>volatile原理与内存语义</h1><p><strong>volatile是Java虚拟机提供的轻量级的同步机制</strong></p>
<p><strong>volatile语义</strong>有如下两个作用<br>    <strong>可见性</strong>：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</p>
<p>​    <strong>有序性</strong>：禁止指令重排序优化(通过内存屏障)。</p>
<p><strong>volatile缓存可见性实现原理</strong></p>
<p>​    JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。</p>
<p>​    底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</p>
<p>​    汇编代码查看<br>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</p>
<h1 id="可见性-amp-原子性-amp-有序性"><a href="#可见性-amp-原子性-amp-有序性" class="headerlink" title="可见性&amp;原子性&amp;有序性"></a>可见性&amp;原子性&amp;有序性</h1><p>并发编程三大特性</p>
<ul>
<li><p>可见性：当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值（高速缓存操作和指令重排会导致可见性丢失）</p>
</li>
<li><p>原子性：原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会 </p>
<p>被其他线程影响。</p>
</li>
<li><p>有序性：<strong>Java允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行</strong>，却会影响到多线程并发执行的正确性。</p>
</li>
</ul>
<p>​    volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p>
<h2 id="有序性-amp-指令重排"><a href="#有序性-amp-指令重排" class="headerlink" title="有序性&amp;指令重排"></a>有序性&amp;指令重排</h2><p>​    java语言规范规定JVM线程内部维持顺序化语义。单线程内保证串行语义执行的一致性:<strong>即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序</strong>。<br>​    指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。可以理解为：只要不影响程序单线程、顺序执行的结果，就可以对两个指令重排序。<br>在<strong>编译器</strong>与<strong>CPU</strong>处理器中都能执行<strong>指令重排优化操作</strong></p>
<h2 id="JMM如何解决原子性-amp-可见性-amp-有序性问题"><a href="#JMM如何解决原子性-amp-可见性-amp-有序性问题" class="headerlink" title="JMM如何解决原子性&amp;可见性&amp;有序性问题"></a><strong>JMM如何解决原子性&amp;可见性&amp;有序性问题</strong></h2><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><strong>as-if-serial语义</strong></h3><pre><code>&gt;不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。 
&gt;
&gt;​    为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被 编译器和处理器重排序。 
</code></pre>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><strong>happens-before 原则</strong></h3><blockquote>
<p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 </p>
<p>happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数 </p>
<p>据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下 </p>
<p>\1. 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 </p>
<p>\2. 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说， </p>
<p>如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。 </p>
<p>\3. volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单 </p>
<p>的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当 </p>
<p>该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能 </p>
<p>够看到该变量的最新值。 </p>
<p>\4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的 </p>
<p>start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量 </p>
<p>的修改对线程B可见 </p>
<p>\5. 传递性 A先于B ，B先于C 那么A必然先于C </p>
<p>\6. 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前 </p>
<p>执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法 </p>
<p>成功返回后，线程B对共享变量的修改将对线程A可见。 </p>
<p>\7. 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中 </p>
<p>断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 </p>
<p>\8. 对象终结规则 对象的构造函数执行，结束先于finalize()方法 </p>
</blockquote>
<h3 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a><strong>volatile保证可见性</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileVisibilitySample</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initFlag = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.initFlag = <span class="hljs-keyword">true</span>;<br>        String threadname = Thread.currentThread().getName();<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;:修改共享变量initFlag&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>&#123;<br>        String threadname = Thread.currentThread().getName();<br>        <span class="hljs-keyword">while</span> (!initFlag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;当前线程还在跑空循环&quot;</span>);<br>            <span class="hljs-comment">//线程在此处空跑，等待initFlag状态改变</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;当前线程嗅探到initFlag的状 态的改变&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        VolatileVisibilitySample sample = <span class="hljs-keyword">new</span> VolatileVisibilitySample();<br>        Thread threadA = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; sample.save(); &#125;,<span class="hljs-string">&quot;threadA&quot;</span>);<br>        Thread threadB = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; sample.load(); &#125;,<span class="hljs-string">&quot;threadB&quot;</span>);<br>        threadB.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        threadA.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="volatile无法保证原子性"><a href="#volatile无法保证原子性" class="headerlink" title="volatile无法保证原子性"></a><strong>volatile无法保证原子性</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * volatile无法保证原子性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileAtomicSample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                    counter++; <span class="hljs-comment">//不是一个原子操作,第一轮循环结果是没有刷入主存，这一轮循环已经无效</span><br>                    <span class="hljs-comment">//1 load counter 到工作内存</span><br>                    <span class="hljs-comment">//2 add counter 执行自加</span><br>                    <span class="hljs-comment">//其他的代码段？</span><br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(counter);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="volatile禁止重排优化"><a href="#volatile禁止重排优化" class="headerlink" title="volatile禁止重排优化"></a><strong>volatile禁止重排优化</strong></h3><p>案例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileReOrderSample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b =<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (;;)&#123;<br>            i++;<br>            x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>;<br>            Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span><br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">1000</span>));<br>                    a = <span class="hljs-number">1</span>; <span class="hljs-comment">//是读还是写？store，volatile写</span><br>                    <span class="hljs-comment">//storeload ,读写屏障，不允许volatile写与第二部volatile读发生重排</span><br>                    <span class="hljs-comment">//手动加内存屏障</span><br>                    <span class="hljs-comment">//UnsafeInstance.reflectGetUnsafe().storeFence();</span><br>                    x = b; <span class="hljs-comment">// 读还是写？读写都有，先读volatile，写普通变量</span><br>                    <span class="hljs-comment">//分两步进行，第一步先volatile读，第二步再普通写</span><br>                &#125;<br>            &#125;);<br>            Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    b = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//UnsafeInstance.reflectGetUnsafe().storeFence();</span><br>                    y = a;<br>                &#125;<br>            &#125;);<br>            t1.start();<br>            t2.start();<br>            t1.join();<br>            t2.join();<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * cpu或者jit对我们的代码进行了指令重排？</span><br><span class="hljs-comment">             * 1,1</span><br><span class="hljs-comment">             * 0,1</span><br><span class="hljs-comment">             * 1,0</span><br><span class="hljs-comment">             * 0,0</span><br><span class="hljs-comment">             */</span><br>            String result = <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次 (&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;）&quot;</span>;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>                System.err.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shortWait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> interval)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">long</span> end;<br>        <span class="hljs-keyword">do</span>&#123;<br>            end = System.nanoTime();<br>        &#125;<span class="hljs-keyword">while</span>(start + interval &gt;= end);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>案例二：DCL 单例模式-双重检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleCheckLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DoubleCheckLock instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DoubleCheckLock</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckLock <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance)&#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckLock.class)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DoubleCheckLock();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为instance = new DoubleCheckLock();可以分为以下3步完成(伪代码) </p>
<p>memory = allocate();//1.分配对象内存空间 </p>
<p>instance(memory);//2.初始化对象 </p>
<p>instance = memory;//3.设置instance指向刚分配的内存地址，此时 </p>
<p>instance！=null </p>
<p>由于步骤1和步骤2间可能会重排序，如下： </p>
<p>memory=allocate();//1.分配对象内存空间 </p>
<p>instance=memory;//3.设置instance指向刚分配的内存地址，此时instance！ </p>
<p>=null，但是对象还没有初始化完成！ </p>
<p>instance(memory);//2.初始化对象 </p>
<p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单 </p>
<p>线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一 </p>
<p>致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null </p>
<p>时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很 </p>
<p>简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p>
</blockquote>
<h3 id="内存屏障-Memory-Barrier）"><a href="#内存屏障-Memory-Barrier）" class="headerlink" title="内存屏障(Memory Barrier）"></a>内存屏障(Memory Barrier）</h3><blockquote>
<p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，<strong>一是保证特定操作的执行</strong> </p>
<p><strong>顺序</strong>，<strong>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</strong>。由于编译 </p>
<p>器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器 </p>
<p>和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏 </p>
<p>障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出 </p>
<p>各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。==总之，== </p>
<p>==volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化==</p>
</blockquote>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210831163732484.png" alt="image-20210831163732484"></p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来 禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数 几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。 </p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。 </li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。 </li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。 </li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<blockquote>
<p>先简单了解两个指令：</p>
<ul>
<li>Store：将处理器缓存的数据刷新到内存中。</li>
<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>
</blockquote>
<p>volatile关键字与CAS使用过多会产生什么问题？有没有听过总线风暴</p>
<p>1、Cpu工作内存与主内存存在大量交互，且大量的无效工作内存变量产生</p>
<p>嗅探机制</p>
<p>读内存、写内存</p>
<p>无效交互</p>
<p>无效变量产生</p>
<p>导致IO总线通道被大量无效占据，导致总线风暴</p>
<p>2、解决办法：适当使用synchronize关键字</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JMM</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程05-Atomic&amp;Unsafe魔法类详解</title>
    <url>/2021/11/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05-Atomic&amp;Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Atomic-amp-Unsafe魔法类详解"><a href="#Atomic-amp-Unsafe魔法类详解" class="headerlink" title="Atomic&amp;Unsafe魔法类详解"></a>Atomic&amp;Unsafe魔法类详解</h1><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>​    原子（atom）本意是“不能被进一步分割的最小粒子”，而<strong>原子操作（atomic operation）意为”不可被中断的一个或一系列操作</strong>” 。</p>
<table>
<thead>
<tr>
<th><strong>术语名称</strong></th>
<th><strong>英文</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>Cache line</td>
<td>缓存的最小操作单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先<strong>比较</strong>下在旧值有没有发生变化，如果没有发生变化，才<strong>交换</strong>成新值，发生了变化则不交换。</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td><strong>Memory order violation</strong></td>
<td>内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td>
</tr>
</tbody></table>
<h2 id="多CPU原子操作的实现方式"><a href="#多CPU原子操作的实现方式" class="headerlink" title="多CPU原子操作的实现方式"></a>多CPU原子操作的实现方式</h2><p>​    <strong>前提</strong>：<strong>处理器自动保证基本内存操作的原子性</strong>，处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作时原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p>​    <strong>实现：2种加锁机制</strong></p>
<p>1、缓存行加锁（基于缓存加锁，基于MESI协议）<br>2、总线加锁（锁住cpu和内存之间的通信）</p>
<p>缓存行加锁失效的场景：</p>
<p>1、CPU不支持缓存锁定</p>
<p>2、缓存数据过大，一个缓存行放不下</p>
<h2 id="JAVA原子操作的实现"><a href="#JAVA原子操作的实现" class="headerlink" title="JAVA原子操作的实现"></a>JAVA原子操作的实现</h2><p>​    1、锁<br>​    2、CAS操作（利用处理器提供的<strong>CMPXCHG</strong>指令实现原子操作）。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>​    在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更 新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p><strong>基本类：</strong>AtomicInteger、AtomicLong、AtomicBoolean；</p>
<p><strong>引用类型：</strong>AtomicReference、AtomicReference的ABA实例、 AtomicStampedRerence、AtomicMarkableReference； </p>
<p><strong>数组类型：</strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray </p>
<p><strong>属性原子修改器（Updater）</strong>：AtomicIntegerFieldUpdater、 AtomicLongFieldUpdater、AtomicReferenceFieldUpdater </p>
<p><strong>1、原子更新基本类型类</strong> </p>
<p>用于通过原子的方式更新基本类型，Atomic包提供了以下三个类： </p>
<ul>
<li>AtomicBoolean：原子更新布尔类型。 </li>
<li>AtomicInteger：原子更新整型。 </li>
<li>AtomicLong：原子更新长整型。 </li>
</ul>
<p>AtomicInteger的常用方法如下： </p>
<ul>
<li>int addAndGet(int delta) ：以原子方式将输入的数值与实例中的值 （AtomicInteger里的value）相加，并返回结果 </li>
<li>boolean compareAndSet(int expect, int update) ：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。 </li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意：这里返回的是自增前的值。</li>
<li>void lazySet(int newValue)：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 </li>
<li>int getAndSet(int newValue)：以原子方式设置为newValue的值，并返回旧值。 </li>
</ul>
<p>Atomic包提供了三种基本类型的原子更新，但是Java的基本类型里还有char，float和double等。那么问题来了，如何原子的更新其他的基本类型呢？Atomic包里的类基本都是使用Unsafe实现的，Unsafe只提供了三种CAS方法，compareAndSwapObject， compareAndSwapInt和compareAndSwapLong，再看AtomicBoolean源码，发现其是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新double也可以用类似的思路来实现。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>                    atomicInteger.incrementAndGet();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;自加10次数值：---&gt;&quot;</span>+atomicInteger.get());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、原子更新数组类</strong></p>
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下三个类： </p>
<p>​    AtomicIntegerArray：原子更新整型数组里的元素。</p>
<p>​    AtomicLongArray：原子更新长整型数组里的元素。 </p>
<p>​    AtomicReferenceArray：原子更新引用类型数组里的元素。 </p>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下 </p>
<p>​    int addAndGet(int i, int delta)：</p>
<p>​    以原子方式将输入值与数组中索引i的元素相加。</p>
<p>​    boolean compareAndSet(int i, int expect, int update)：</p>
<p>​    如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-keyword">static</span> AtomicIntegerArray aiArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(value);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        aiArray.getAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">if</span>(!aiArray.compareAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;更新失败&quot;</span>);<br>        &#125;<br>        System.out.println(aiArray.get(<span class="hljs-number">0</span>));<br>        System.out.println(value[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(aiArray.get(<span class="hljs-number">0</span>) != value[<span class="hljs-number">0</span>])&#123;<br>            System.out.println(<span class="hljs-string">&quot;不相等&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3、原子更新引用类型</strong> </p>
<p>​    原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子的更新多个变 </p>
<p>量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下三个类： </p>
<p>​    AtomicReference：原子更新引用类型。 </p>
<p>​    AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 </p>
<p>​    AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(VinitialRef, boolean initialMark) </p>
<p><strong>4、原子更新字段类</strong> </p>
<p>如果我们只需要某个类里的某个字段，那么就需要使用原子更新字段类，Atomic包提供了以下三个类： </p>
<p>​    AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 </p>
<p>​    AtomicLongFieldUpdater：原子更新长整型字段的更新器。 </p>
<p>​    AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值 </p>
<p>与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。 原子更新字段类都是抽象类，每次使用都时候必须使用静态方法newUpdater创建一个 </p>
<p>更新器。原子更新类的字段的必须使用public volatile修饰符</p>
<h4 id="5、AtomicInteger存在ABA问题"><a href="#5、AtomicInteger存在ABA问题" class="headerlink" title="5、AtomicInteger存在ABA问题"></a>5、AtomicInteger存在ABA问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicAbaProblemTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread main = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> a = atomicInteger.get();<br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--修改前操作数值:&quot;</span>+a);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">boolean</span> isCasSuccess = atomicInteger.compareAndSet(a,<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span>(isCasSuccess)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--Cas修改后操作数值:&quot;</span>+atomicInteger.get());<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;CAS修改失败&quot;</span>);<br>                &#125;<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;主线程&quot;</span>);<br><br>        Thread other = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                atomicInteger.incrementAndGet();<span class="hljs-comment">// 1+1 = 2;</span><br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--increase后值:&quot;</span>+atomicInteger.get());<br>                atomicInteger.decrementAndGet();<span class="hljs-comment">// atomic-1 = 2-1;</span><br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--decrease后值:&quot;</span>+atomicInteger.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;干扰线程&quot;</span>);<br><br>        main.start();<br>        other.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义原子更新字段类"><a href="#自定义原子更新字段类" class="headerlink" title="自定义原子更新字段类"></a>自定义原子更新字段类</h4><p>利用Unsafe类 + 字段偏移量定位应用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStudentAgeUpdater</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset(AtomicStudentAgeUpdater.class.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;valueOffset:---&gt;&quot;</span>+valueOffset);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compareAndSwapAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> old,<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>,valueOffset,old,target);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicStudentAgeUpdater</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicStudentAgeUpdater updater = <span class="hljs-keyword">new</span> AtomicStudentAgeUpdater(<span class="hljs-string">&quot;杨过&quot;</span>,<span class="hljs-number">18</span>);<br>        updater.compareAndSwapAge(<span class="hljs-number">18</span>,<span class="hljs-number">56</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;真实的杨过年龄---&quot;</span>+updater.getAge());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Unsafe魔法类"><a href="#Unsafe魔法类" class="headerlink" title="Unsafe魔法类"></a>Unsafe魔法类</h2><p>​    Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。<br>​    Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123; <br>    <span class="hljs-comment">// 单例对象 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Unsafe</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-meta">@CallerSensitive</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123; <br>        Class var0 = Reflection.getCallerClass(); <br>            <span class="hljs-comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法 </span><br>        <span class="hljs-keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">&quot;Unsafe&quot;</span>); <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">return</span> theUnsafe; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h3><p>1、把调用Unsafe相关方法的类Demo所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载<br>    java -Xbootclasspath/Demo:${path} // 其中path为调用Unsafe相关方法的类所在jar包路径<br>2、通过反射获取单例对象theUnsafe</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeInstance</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Unsafe功能介绍"><a href="#Unsafe功能介绍" class="headerlink" title="Unsafe功能介绍"></a>Unsafe功能介绍</h3><p>Unsafe可以绕过JVM做一些操作，所以称之为魔法类。直接操作提供的API大致可分为</p>
<p><img src="/images/Untitled/image-20211103234945888.png" alt="image-20211103234945888"></p>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>​    这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。 </p>
<h4 id="CAS-原子操作"><a href="#CAS-原子操作" class="headerlink" title="CAS 原子操作"></a>CAS 原子操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, Object var4, Object var5)</span>; </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4, <span class="hljs-keyword">int</span> var5)</span>; </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">long</span> var4, <span class="hljs-keyword">long</span> var6)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field var1)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>包括线程挂起、恢复、锁机制等方法。<br>**//取消阻塞线程 **</p>
<p>public native void unpark(Object thread); </p>
<p>**//阻塞线程 **</p>
<p>public native void park(boolean isAbsolute, long time);</p>
<p>**//获得对象锁（类似可重入锁ReentrantLock或者Synchronized） **</p>
<p>public native void monitorEnter(Object o); </p>
<p>**//释放对象锁 **</p>
<p>public native void monitorExit(Object o);</p>
<p><strong>//尝试获取对象锁</strong></p>
<p>public native boolean tryMonitorEnter(Object o);</p>
<p>​    方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方 法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现； unpark可以终止一个挂起的线程，使其恢复正常</p>
<p>**典型应用:**Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用 LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而 LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>​    在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类 同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的 所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存屏障前后，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFence</span><span class="hljs-params">()</span>; 相当于loadload屏障</span><br><span class="hljs-function"><span class="hljs-comment">//内存屏障前后，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后， 屏障后的store操作不能被重排序到屏障前</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeFence</span><span class="hljs-params">()</span>; 相当于storestore屏障</span><br><span class="hljs-function"><span class="hljs-comment">//内存屏障前后，禁止load、store操作重排序 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fullFence</span><span class="hljs-params">()</span>; 相当于 <span class="hljs-title">loadFence</span><span class="hljs-params">()</span>+<span class="hljs-title">storeFence</span><span class="hljs-params">()</span>;使所有Full Barrier之前发生的操作，对所有Full Barrier之后的操作都是可见的</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> :利用内存屏障手动防止指令</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FenceTest</span> </span>&#123;<br><br><br><span class="hljs-comment">//    public static void main(String[] args) &#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().loadFence();//读屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().storeFence();//写屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().fullFence();//读写屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b =<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (;;)&#123;<br>            i++;<br>            x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>;<br>            Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span><br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    a = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//不允许2次store操作发生重排</span><br>                    <span class="hljs-comment">//手动加内存屏障</span><br>                    UnsafeInstance.reflectGetUnsafe().storeFence();<br>                    x = b; <span class="hljs-comment">// read-load、assign、store-write</span><br>                    <span class="hljs-comment">//分两步进行，第一步先volatile读，第二步再普通写</span><br>                &#125;<br>            &#125;);<br>            Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    b = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//不允许2次store操作发生重排</span><br>                    UnsafeInstance.reflectGetUnsafe().storeFence();<br>                    y = a;<br>                &#125;<br>            &#125;);<br>            t1.start();<br>            t2.start();<br>            t1.join();<br>            t2.join();<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * cpu或者jit对我们的代码进行了指令重排？</span><br><span class="hljs-comment">             * 1,1</span><br><span class="hljs-comment">             * 0,1</span><br><span class="hljs-comment">             * 1,0</span><br><span class="hljs-comment">             * 0,0</span><br><span class="hljs-comment">             */</span><br>            String result = <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次 (&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;）&quot;</span>;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>                System.err.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shortWait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> interval)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">long</span> end;<br>        <span class="hljs-keyword">do</span>&#123;<br>            end = System.nanoTime();<br>        &#125;<span class="hljs-keyword">while</span>(start + interval &gt;= end);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Class相关</li>
<li>对象操作</li>
<li>系统信息获取</li>
<li>数组操</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程08-ForkJoin原理与应用</title>
    <url>/2021/11/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="任务的性质"><a href="#任务的性质" class="headerlink" title="任务的性质"></a>任务的性质</h1><h2 id="CPU密集型（CPU-bound）"><a href="#CPU密集型（CPU-bound）" class="headerlink" title="CPU密集型（CPU-bound）"></a>CPU密集型（CPU-bound）</h2><p>​        CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPULoading100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPULoading很高。在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPUbound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPUbound的程序。CPUbound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p>
<p>​        线程数一般设置为：<strong>线程数=CPU核数+1(现代CPU支持超线程)</strong></p>
<h2 id="IO密集型（I-Obound）"><a href="#IO密集型（I-Obound）" class="headerlink" title="IO密集型（I/Obound）"></a>IO密集型（I/Obound）</h2><p>​        IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O(硬盘/内存)的读/写操作，此时CPULoading并不高。I/Obound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>
<p>​        线程数一般设置为：<strong>线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数目</strong></p>
<h2 id="CPU密集型vsIO密集型"><a href="#CPU密集型vsIO密集型" class="headerlink" title="CPU密集型vsIO密集型"></a>CPU密集型vsIO密集型</h2><p>​    我们可以把任务分为计算密集型和IO密集型。</p>
<p>​    计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>​    第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h1 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h1><p>​        如何充分利用多核CPU，计算很大数组中所有整数的和？</p>
<p>1、单线程累加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumSequential</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> SumUtils.sumRange(arr, <span class="hljs-number">0</span>, arr.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br><br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> result = sum(arr);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br>        System.out.println(<span class="hljs-string">&quot;单线程:&quot;</span>+ (end - begin));<br>    &#125;<br>&#125;<br>The array length is: <span class="hljs-number">200000</span><br>The result is: <span class="hljs-number">9905876</span><br>单线程:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>2、多线程拆分（定义步长，1为2,2分为4,4分为8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumRecursiveMT</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursiveSumTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEQUENTIAL_CUTOFF = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lo;<br>        <span class="hljs-keyword">int</span> hi;<br>        <span class="hljs-keyword">int</span>[] arr; <span class="hljs-comment">// arguments</span><br>        ExecutorService executorService;<br><br>        RecursiveSumTask( ExecutorService executorService, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h) &#123;<br>            <span class="hljs-keyword">this</span>.executorService = executorService;<br>            <span class="hljs-keyword">this</span>.arr = a;<br>            <span class="hljs-keyword">this</span>.lo = l;<br>            <span class="hljs-keyword">this</span>.hi = h;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// override</span><br>            System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to compute %n&quot;</span>,<br>                    Thread.currentThread().getName(), lo, hi);<br>            <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (hi - lo &lt;= SEQUENTIAL_CUTOFF) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt; hi; i++)<br>                    result += arr[i];<br><br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to finished %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                RecursiveSumTask left = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, lo, (hi + lo) / <span class="hljs-number">2</span>);<br>                RecursiveSumTask right = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, (hi + lo) / <span class="hljs-number">2</span>, hi);<br>                Future&lt;Long&gt; lr = executorService.submit(left);<br>                Future&lt;Long&gt; rr = executorService.submit(right);<br><br>                result = lr.get() + rr.get();<br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] finished to compute %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> nofProcessors = Runtime.getRuntime().availableProcessors();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//ExecutorService executorService = Executors.newCachedThreadPool();</span><br><br>        RecursiveSumTask task = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-keyword">long</span> result =  executorService.submit(task).get();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br><br>        <span class="hljs-keyword">long</span> result = sum(arr);<br><br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//无法正常运行 4个线程无法完成递归</span><br>The array length is: <span class="hljs-number">200000</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">200000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">100000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> range [<span class="hljs-number">100000</span>-<span class="hljs-number">200000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">50000</span>] begin to compute <br></code></pre></td></tr></table></figure>

<p>3、多线程拆分（定义步长，拆分为 数组长度/步长  个线程去计算对应段的素组长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumMultiThreads</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">1000</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, ExecutorService executor)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> numThreads = arr.length / NUM &gt; <span class="hljs-number">0</span> ? arr.length / NUM : <span class="hljs-number">1</span>;<br><br>        SumTask[] tasks = <span class="hljs-keyword">new</span> SumTask[numThreads];<br>        Future&lt;Long&gt;[] sums = <span class="hljs-keyword">new</span> Future[numThreads];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++) &#123;<br>            tasks[i] = <span class="hljs-keyword">new</span> SumTask(arr, (i * NUM), ((i + <span class="hljs-number">1</span>) * NUM));<br>            sums[i] = executor.submit(tasks[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++) &#123;<br>            result += sums[i].get();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br><br>        <span class="hljs-keyword">int</span> numThreads = arr.length / NUM &gt; <span class="hljs-number">0</span> ? arr.length / NUM : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br>        ExecutorService executor = Executors.newFixedThreadPool(numThreads);<br><br>        <span class="hljs-keyword">long</span> result = sum(arr, executor);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br>        System.out.println(<span class="hljs-string">&quot;多线程:&quot;</span>+ (end - begin));<br>    &#125;<br>&#125;<br>The array length is: <span class="hljs-number">200000</span><br>The result is: <span class="hljs-number">9904260</span><br>多线程:<span class="hljs-number">177</span><br></code></pre></td></tr></table></figure>

<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>基本思想：把一个规模大的问题划分为规模较小的子问题，然后分而治之，最后合并子问题的解得到原问题的解。<br>步骤：<br>1、分割原问题：<br>2、求解子问题：<br>3、合并子问题的解为原问题的解。<br>在分治法中，子问题一般是相互独立的，因此，经常通过递归调用算法来求解子问题。</p>
<h3 id="拆分任务"><a href="#拆分任务" class="headerlink" title="拆分任务"></a>拆分任务</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124220037943.png" alt="image-20211124220037943"></p>
<h3 id="递归分解"><a href="#递归分解" class="headerlink" title="递归分解"></a>递归分解</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124220208261.png" alt="image-20211124220208261"></p>
<h1 id="什么是Fork-Join框架？"><a href="#什么是Fork-Join框架？" class="headerlink" title="什么是Fork/Join框架？"></a>什么是Fork/Join框架？</h1><p>​        Fork/Join框架是Java7提供了的一个用于**==并行执行==**任务的框架，是一个把大任务分割成若干个小任务（互不依赖），最终汇总每个小任务结果后得到大任务结果的框架。</p>
<blockquote>
<p>​    对Java而言，对支持Concurrency(并发)/Parallelism(并行)的不断完善，明显地体现在优化并发与并行<br>Java 1 支持threads, locks, condition queues<br>Java 5 引入了 thread pools, blocking queues, concurrent collections<br>Java 7 加入了fork-join库<br>Java 8 加入了 parallel streams</p>
</blockquote>
<p>​        Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…..＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。如下图所示：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-Fork-Join%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124203343127.png" alt="image-20211124203343127"></p>
<h2 id="Fork-Jion特性："><a href="#Fork-Jion特性：" class="headerlink" title="Fork/Jion特性："></a>Fork/Jion特性：</h2><ol>
<li><p>ForkJoinPool不是为了替代ExecutorService，而是它的补充，在某些应用场景下性能比ExecutorService更好。（见JavaTip:When to use ForkJoinPool vs ExecutorService ）</p>
</li>
<li><p>ForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如quicksort等。</p>
</li>
<li><p>ForkJoinPool最适合的是计算密集型的任务，如果存在I/O，线程间同步，sleep()等会造成线程长时间阻塞的情况时，最好配合使用ManagedBlocker。</p>
</li>
</ol>
<h2 id="ForkJoinPool框架主要类"><a href="#ForkJoinPool框架主要类" class="headerlink" title="ForkJoinPool框架主要类"></a>ForkJoinPool框架主要类</h2><p>​    <strong>ForkJoinPool</strong> 实现ForkJoin的线程池——对应ThreadPool<br>​        ForkJoinWorkerThread  实现ForkJoin的线程</p>
<p>   <strong>ForkJoinTask</strong><V>一个描述ForkJoin的抽象类——对应Runnable/Callable<br>        <strong>RecursiveAction</strong> 无返回结果的ForkJoinTask类似Runnable<br>        <strong>RecursiveTask<V></V></strong> 有返回结果的ForkJoinTask类似Callable<br>        <strong>CountedCompleter<T></T></strong> 在任务完成执行后会触发执行一个自定义的钩子函数    </V></p>
<h2 id="ForkJoinPool-提交任务"><a href="#ForkJoinPool-提交任务" class="headerlink" title="ForkJoinPool 提交任务"></a><strong>ForkJoinPool</strong> 提交任务</h2><table>
<thead>
<tr>
<th><strong>返回值</strong></th>
<th><strong>方法名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>execute(ForkJoinTask&lt;?&gt; task)execute(Runnable task)</strong></td>
</tr>
<tr>
<td>T</td>
<td><strong>invoke(ForkJoinTask<T> task)</T></strong></td>
</tr>
<tr>
<td>List&gt;</td>
<td><strong>invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)</T></strong></td>
</tr>
<tr>
<td>ForkJoinTask</td>
<td><strong>submit(ForkJoinTask<T> task)<br>submit(Callable<T> task)<br>submit(Runnable task)<br>submit(Runnable task, T result)</T></T></strong></td>
</tr>
</tbody></table>
<h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p><strong>ForkJoinTask主要包括两个方法分别实现任务的分拆与合并：</strong></p>
<p>1、fork()类似于Thread.start()，但是它并不立即执行任务，而是将任务放入工作队列中<br>2、跟Thread.join()不同，ForkJoinTask的join()方法并不简单的阻塞线程<br>        利用工作线程运行其他任务<br>        当一个工作线程中调用join()，它将处理其他任务，直到注意到目标子任务已经完成 </p>
<table>
<thead>
<tr>
<th>ForkJoinTask<T></T></th>
<th>fork()–Arranges to asynchronously execute this task in the appropriate pool</th>
</tr>
</thead>
<tbody><tr>
<td><strong>V</strong></td>
<td><strong>join()–Returns the result of the computation when itis done</strong></td>
</tr>
</tbody></table>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125213137146.png"></p>
<h4 id="1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue"><a href="#1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue" class="headerlink" title="1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue"></a>1、<strong>ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue</strong></h4><ul>
<li>双端队列（Deque) </li>
<li>从队头取任务</li>
<li>线程私有，不共享<br><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125223853349.png" alt="image-20211125223853349"></li>
</ul>
<h4 id="2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头"><a href="#2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头" class="headerlink" title="2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头"></a>2、<strong>ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头</strong></h4><ul>
<li><p>工作线程以<strong>LIFO（LAST IN FIRST OUT）</strong>的顺序来处理它队列中的任务</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125223923062.png" alt="image-20211125223923062"></p>
</li>
</ul>
<h4 id="3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行"><a href="#3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行" class="headerlink" title="3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行"></a>3、<strong>为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行</strong></h4><ul>
<li><p>从工作队列的队尾“窃取”任务，以减少竞争</p>
</li>
<li><p>任务的“窃取”是以**FIFO(FIRST IN FIRST OUT)**顺序进行的，因为先放入的任务往往表示更大的工作量</p>
</li>
</ul>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125224015897.png" alt="image-20211125224015897"></p>
<h4 id="4、WorkQueue双端队列最小化任务“窃取”的竞争"><a href="#4、WorkQueue双端队列最小化任务“窃取”的竞争" class="headerlink" title="4、WorkQueue双端队列最小化任务“窃取”的竞争"></a>4、<strong>WorkQueue双端队列最小化任务“窃取”的竞争</strong></h4><ul>
<li>push()/pop()仅在其所有者工作线程中调用<ul>
<li>这些操作都是通过CAS来实现的，是Wait-free的</li>
</ul>
</li>
<li>poll() 则由其他工作线程来调用“窃取”任务<ul>
<li>可能不是wait-free</li>
</ul>
</li>
</ul>
<h4 id="5、异常处理"><a href="#5、异常处理" class="headerlink" title="5、异常处理"></a>5、<strong>异常处理</strong></h4><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出 异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。示例 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(task.isCompletedAbnormally())&#123; <br>	System.out.println(task.getException()); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>getException 方法返回 Throwable 对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null</p>
<h4 id="6、ForkJoinPool构造函数"><a href="#6、ForkJoinPool构造函数" class="headerlink" title="6、ForkJoinPool构造函数"></a>6、<strong>ForkJoinPool构造函数</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parallelism,</span></span><br><span class="hljs-function"><span class="hljs-params">                     ForkJoinWorkerThreadFactory factory,</span></span><br><span class="hljs-function"><span class="hljs-params">                     UncaughtExceptionHandler handler,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">int</span> mode,</span></span><br><span class="hljs-function"><span class="hljs-params">                     String workerNamePrefix)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.workerNamePrefix = workerNamePrefix;<br>    <span class="hljs-keyword">this</span>.factory = factory;<br>    <span class="hljs-keyword">this</span>.ueh = handler;<br>    <span class="hljs-keyword">this</span>.config = (parallelism &amp; SMASK) | mode;<br>    <span class="hljs-keyword">long</span> np = (<span class="hljs-keyword">long</span>)(-parallelism); <span class="hljs-comment">// offset ctl counts</span><br>    <span class="hljs-keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重要参数解释<br>①parallelism：并行度（ the parallelism level），默认情况下跟我们机器的cpu个数保持 一致，使用 Runtime.getRuntime().availableProcessors()可以得到我们机器运行时可用的 CPU个数。 </p>
<p>②factory：创建新线程的工厂（ the factory for creating new threads）。默认情况下使 用ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory。 </p>
<p>③handler：线程异常情况下的处理器（Thread.UncaughtExceptionHandler handler），该处理器在线程执行任务时由于某些无法预料到的错误而导致任务线程中断时 进行一些处理，默认情况为null。 </p>
<p>④asyncMode：这个参数要注意，在ForkJoinPool中，每一个工作线程都有一个独立的任 务队列，asyncMode表示工作线程内的任务队列是采用何种方式进行调度，可以是先进先 出FIFO，也可以是后进先出LIFO。如果为true，则线程池中的工作线程则使用先进先出方 式进行任务调度，默认情况下是false。</p>
<h4 id="7、ForkJoinTask-fork-方法"><a href="#7、ForkJoinTask-fork-方法" class="headerlink" title="7、ForkJoinTask fork 方法"></a><strong>7、ForkJoinTask fork 方法</strong></h4><p>fork() 做的工作只有一件事，既是把任务推入当前工作线程的工作队列里。可以参看以下的 源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title">fork</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8、ForkJoinTask-join-方法"><a href="#8、ForkJoinTask-join-方法" class="headerlink" title="8、ForkJoinTask join 方法"></a><strong>8、ForkJoinTask join 方法</strong></h4><p>join() 的工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名 的 Thread.join()。</p>
<ol>
<li>检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线 程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。 </li>
<li> 查看任务的完成状态，如果已经完成，直接返回结果。</li>
<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。 </li>
<li>如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务 （以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。 </li>
<li>如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务 时，则找到小偷的小偷，帮助它完成它的任务。</li>
<li>递归地执行第5步</li>
</ol>
<p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127132444426.png" alt="image-20211127132444426"></p>
<h4 id="9、ForkJoinPool-submit-方法"><a href="#9、ForkJoinPool-submit-方法" class="headerlink" title="9、ForkJoinPool.submit 方法"></a>9、<strong>ForkJoinPool.submit 方法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">ForkJoinTask&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    externalPush(task);<br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ForkJoinPool 自身拥有工作队列，这些工作队列的作用是用来接收由外部线程 （非 ForkJoinThread 线程）提交过来的任务，而这些工作队列被称 为 submitting queue 。 submit() 和 fork() 其实没有本质区别，只是提交对象变成了 submitting queue 而已（还有一些同步，初始化的操作）。</p>
<p>submitting queue 和其他 work queue 一样，是工作线程”窃取“的对象，因此当其中的任务被一个工作线程 成功窃取时，就意味着提交的任务真正开始进入执行阶段。</p>
<h4 id="10、Fork-Join框架执行流程"><a href="#10、Fork-Join框架执行流程" class="headerlink" title="10、Fork/Join框架执行流程"></a>10、Fork/Join框架执行流程</h4><p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127132530364.png" alt="image-20211127132530364"></p>
<h2 id="RecursiveTask使用实例"><a href="#RecursiveTask使用实例" class="headerlink" title="RecursiveTask使用实例"></a>RecursiveTask使用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongSumMain</span> </span>&#123;<br>	<span class="hljs-comment">/** for time conversion */</span><br><span class="hljs-comment">//获取逻辑处理器数量</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> calcSum;<br><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> reportSteals = <span class="hljs-keyword">true</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>		<span class="hljs-keyword">int</span>[] array = Utils.buildRandomIntArray(<span class="hljs-number">200000000</span>);<br>		System.out.println(<span class="hljs-string">&quot;cpu-num:&quot;</span>+NCPU);<br>		<span class="hljs-comment">//单线程下计算数组数据总和</span><br>		<span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br> 		calcSum = seqSum(array);<br>		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>		System.out.println(<span class="hljs-string">&quot;seq sum=&quot;</span> + calcSum);<br>		System.out.println(<span class="hljs-string">&quot;单线程:&quot;</span>+ (end - begin));<br><br>		<span class="hljs-comment">//采用fork/join方式将数组求和任务进行拆分执行，最后合并结果</span><br>		LongSum ls = <span class="hljs-keyword">new</span> LongSum(array, <span class="hljs-number">0</span>, array.length);<br>  		ForkJoinPool fjp  = <span class="hljs-keyword">new</span> ForkJoinPool(NCPU); <span class="hljs-comment">//使用的线程数</span><br>		begin = System.currentTimeMillis();<br>		ForkJoinTask&lt;Long&gt; task = fjp.submit(ls);<br>		System.out.println(<span class="hljs-string">&quot;forkjoin sum=&quot;</span> + task.get());<br>		end = System.currentTimeMillis();<br>		System.out.println(<span class="hljs-string">&quot;forkjoin:&quot;</span>+ (end - begin));<br>		<span class="hljs-keyword">if</span>(task.isCompletedAbnormally())&#123;<br>			System.out.println(task.getException());<br>		&#125;<br><br>		fjp.shutdown();<br><br>	&#125;<br><br><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">seqSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>		<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)<br>			sum += array[i];<br>		<span class="hljs-keyword">return</span> sum;<br>	&#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">RecursiveTask 并行计算，同步有返回值</span><br><span class="hljs-comment">ForkJoin框架处理的任务基本都能使用递归处理，比如求斐波那契数列等，但递归算法的缺陷是：</span><br><span class="hljs-comment">一只会只用单线程处理，</span><br><span class="hljs-comment">二是递归次数过多时会导致堆栈溢出；</span><br><span class="hljs-comment">ForkJoin解决了这两个问题，使用多线程并发处理，充分利用计算资源来提高效率，同时避免堆栈溢出发生。</span><br><span class="hljs-comment">当然像求斐波那契数列这种小问题直接使用线性算法搞定可能更简单，实际应用中完全没必要使用ForkJoin框架，</span><br><span class="hljs-comment">所以ForkJoin是核弹，是用来对付大家伙的，比如超大数组排序。</span><br><span class="hljs-comment">最佳应用场景：多核、多内存、可以分割计算再合并的计算密集型任务</span><br><span class="hljs-comment">*/</span><br>cpu-num:<span class="hljs-number">12</span><br>seq sum=<span class="hljs-number">9899269760</span><br>单线程:<span class="hljs-number">132</span><br>forkjoin sum=<span class="hljs-number">9899269760</span><br>forkjoin:<span class="hljs-number">106</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongSum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEQUENTIAL_THRESHOLD = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> NPS = (<span class="hljs-number">1000L</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> extraWork = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// change to add more than just a sum</span><br><br><br>    <span class="hljs-keyword">int</span> low;<br>    <span class="hljs-keyword">int</span> high;<br>    <span class="hljs-keyword">int</span>[] array;<br><br>    LongSum(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi) &#123;<br>        array = arr;<br>        low = lo;<br>        high = hi;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fork()方法：将任务放入队列并安排异步执行，一个任务应该只调用一次fork()函数，除非已经执行完毕并重新初始化。</span><br><span class="hljs-comment">     * tryUnfork()方法：尝试把任务从队列中拿出单独处理，但不一定成功。</span><br><span class="hljs-comment">     * join()方法：等待计算完成并返回计算结果。</span><br><span class="hljs-comment">     * isCompletedAbnormally()方法：用于判断任务计算是否发生异常。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (high - low &lt;= SEQUENTIAL_THRESHOLD) &#123;<br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt; high; ++i) &#123;<br>                sum += array[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            LongSum left = <span class="hljs-keyword">new</span> LongSum(array, low, mid);<br>            LongSum right = <span class="hljs-keyword">new</span> LongSum(array, mid, high);<br>            left.fork();<br>            right.fork();<br>            <span class="hljs-keyword">long</span> rightAns = right.join();<br>            <span class="hljs-keyword">long</span> leftAns = left.join();<br>            <span class="hljs-keyword">return</span> leftAns + rightAns;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ForkJoi</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优02-Explain详解与索引最佳实践</title>
    <url>/2021/12/11/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Explain详解与索引最佳实践"><a href="#Explain详解与索引最佳实践" class="headerlink" title="Explain详解与索引最佳实践"></a>Explain详解与索引最佳实践</h1><h2 id="Explain工具介绍"><a href="#Explain工具介绍" class="headerlink" title="Explain工具介绍"></a>Explain工具介绍</h2><p>​    使用EXPLAIN关键字可以<strong>模拟优化器执行SQL语句</strong>，分析你的查询语句或是结构的性能瓶颈，在 select语句之前增加explain关键字，MySQL会在查询上设置一个标记，<strong>执行查询会返回执行计划的信息，而不是执行这条SQL</strong></p>
<p>​    注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中</p>
<h2 id="Explain分析示例"><a href="#Explain分析示例" class="headerlink" title="Explain分析示例"></a>Explain分析示例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 示例表：</span><br><span class="hljs-comment">-- actor表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `actor`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `actor` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">45</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` )<br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `actor` ( `id`, `name`, `update_time` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> ),<br>	( <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> ),<br>	( <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> );<br>	<br><span class="hljs-comment">-- film表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `film`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `film` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">10</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>    KEY `idx_name` ( `name` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `film` ( `id`, `name` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;film0&#x27;</span> ),<br>	( <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;film1&#x27;</span> ),<br>	( <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;film 2&#x27;</span> );<br><br><span class="hljs-comment">-- flim_actor表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `film_actor`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `film_actor` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `film_id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `actor_id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `remark` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>    KEY `idx_film_actor_id` ( `film_id`, `actor_id` )<br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `film_actor` (`id`, `film_id`, `actor_id`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p><strong>explain select * from actor;</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211213633437.png" alt="image-20211211213633437"></p>
<p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行</p>
<h3 id="explain-两个变种"><a href="#explain-两个变种" class="headerlink" title="explain 两个变种"></a>explain 两个变种</h3><p>1）<strong>explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通 过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表 进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<p><strong>explain extended select * from film where id = 1;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211214335940.png" alt="image-20211211214335940"></p>
<p><strong>show warnings;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211214428788.png" alt="image-20211211214428788"></p>
<p>2）<strong>explain partitions</strong>：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h2 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h2><p>接下来我们将展示 explain 中每个列的信息。</p>
<h3 id="1、id列"><a href="#1、id列" class="headerlink" title="1、id列"></a>1、id列</h3><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。</p>
<p><strong>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</strong></p>
<h3 id="2、select-type列"><a href="#2、select-type列" class="headerlink" title="2、select_type列"></a>2、select_type列</h3><p>select_type 表示对应行是简单还是复杂的查询。 </p>
<p>1）<strong>simple</strong>：简单查询。查询不包含子查询和union </p>
<p>explain select * from film where id = 2; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215053062.png" alt="image-20211211215053062"></p>
<p>2）<strong>primary</strong>：复杂查询中最外层的 select</p>
<p>3）<strong>subquery</strong>：包含在 select 中的子查询（不在 from 子句中） </p>
<p>4）<strong>derived</strong>：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为 </p>
<p>派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#关闭mysql5<span class="hljs-number">.7</span>新特性对衍生表的合并优化 <br><span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>; <br>explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der; <br>#还原默认配置 <br><span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=on&#x27;</span>; <br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215525618.png" alt="image-20211211215525618"></p>
<p>5）union：在 union 中的第二个和随后的 select </p>
<p>explain select 1 union all select 1</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215544724.png" alt="image-20211211215544724"></p>
<h3 id="3、table列"><a href="#3、table列" class="headerlink" title="3、table列"></a>3、table列</h3><p>这一列表示 explain 的一行正在访问哪个表。 </p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 </derivenN></p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的select 行id。 </p>
<h3 id="4、type列"><a href="#4、type列" class="headerlink" title="4、type列"></a>4、type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概 </p>
<p>范围。 </p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong> </p>
<p>一般来说，得保证查询达到range级别，最好达到ref </p>
<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在 </p>
<p>索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表 </p>
<p>explain select min(id) from film;（id列刚好再索引列内）</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221009216.png" alt="image-20211211221009216"></p>
<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果。<br>用于 <strong>primary key 或 unique key</strong> 的所有列与常数比较时，<strong>所以表最多有一个匹配行</strong>，读取1次，速度比较快。system是const的特例，查询范围里表里只有一条元组匹配时为 system</p>
<p>explain extended select * from film where id = 1;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221743242.png" alt="image-20211211221743242">explain extended select * from (select * from film where id = 1) tmp; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221228877.png" alt="image-20211211221228877">show warnings;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221246720.png" alt="image-20211211221246720"></p>
<p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分<strong>被连接使用</strong> ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种type。<br>explain select * from film_actor left join film on film_actor.film_id = film.id;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211222109808.png" alt="image-20211211222109808"></p>
<p>ref：相比 eq_ref，不使用唯一索引，而是<strong>使用普通索引或者唯一性索引的部分前缀</strong>，索引要和某个值相比较，可能会找到多个符合条件的行。 </p>
<p><strong>1、简单 select 查询，name是普通索引（非唯一索引）</strong> </p>
<p>explain select * from film where name = ‘film1’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223431263.png" alt="image-20211211223431263"></p>
<p><strong>2、关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</strong> </p>
<p>explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223453739.png" alt="image-20211211223453739"></p>
<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。 </p>
<p>explain select * from actor where id &gt; 1;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223553807.png" alt="image-20211211223553807"></p>
<p><strong>index</strong>：扫描全表索引，这通常比ALL快一<strong>（所有字段都在索引范围内）</strong></p>
<p>explain select * from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223615906.png" alt="image-20211211223615906"></p>
<p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了 </p>
<p>explain select * from actor;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223639660.png" alt="image-20211211223639660"></p>
<h3 id="5、possible-keys列"><a href="#5、possible-keys列" class="headerlink" title="5、possible_keys列"></a>5、possible_keys列</h3><p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </p>
<h3 id="6、key列"><a href="#6、key列" class="headerlink" title="6、key列"></a>6、key列</h3><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 </p>
<p>引，在查询中使用 force index、ignore index。<br><strong>explain select * from actor ignore index(PRIMARY) where id &gt; 1</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211224827205.png" alt="image-20211211224827205"></p>
<h3 id="7、key-len列"><a href="#7、key-len列" class="headerlink" title="7、key_len列"></a>7、key_len列</h3><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成， </p>
<p>并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执 </p>
<p>行索引查找。 </p>
<p>explain select * from film_actor where film_id = 2<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211224908363.png" alt="image-20211211224908363"></p>
<p>key_len计算规则如下： </p>
<ul>
<li>字符串 <ul>
<li>char(n)：n字节长度 </li>
<li>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li>
</ul>
</li>
<li>数值类型<ul>
<li>tinyint：1字节 </li>
<li>smallint：2字节 </li>
<li>int：4字节 </li>
<li>bigint：8字节 </li>
</ul>
</li>
<li>时间类型<ul>
<li>date：3字节 </li>
<li>timestamp：4字节 </li>
<li>datetime：8字节 </li>
</ul>
</li>
<li>如果字段允许为 NULL，需要1字节记录是否为 NULL </li>
</ul>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<p>explain select * from film_actor where film_id = 1<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230231364.png" alt="image-20211211230231364"></p>
<p>explain select * from film_actor where film_id = 1 and actor_id = 1<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230247482.png" alt="image-20211211230247482"></p>
<h3 id="8、ref列"><a href="#8、ref列" class="headerlink" title="8、ref列"></a>8、ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p>
<h3 id="9、rows列"><a href="#9、rows列" class="headerlink" title="9、rows列"></a>9、rows列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </p>
<h3 id="10、-Extra列"><a href="#10、-Extra列" class="headerlink" title="10、 Extra列"></a>10、 Extra列</h3><p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>1）Using index：使用覆盖索引 </p>
<p>explain select film_id from film_actor where film_id = 1; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230656337.png" alt="image-20211211230656337"></p>
<p>2）Using where：使用 where 语句来处理结果，<strong>查询的列未被索引覆盖</strong> </p>
<p>explain select * from actor where name = ‘a’;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230707631.png" alt="image-20211211230707631"></p>
<p>3）Using index condition：<strong>查询的列不完全被索引覆盖</strong>，where条件中是一个前导列的范围；</p>
<p>explain select * from film_actor where film_id &gt; 1;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230818309.png" alt="image-20211211230818309"></p>
<p>4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行 </p>
<p>优化的，首先是想到用索引来优化。 </p>
<p>1、actor.name没有索引，此时创建了张临时表来distinct </p>
<p>explain select distinct name from actor; </p>
<p>2、film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表 </p>
<p>explain select distinct name from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230955403.png" alt="image-20211211230955403"></p>
<p>5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。 </p>
<p>1、actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 </p>
<p>explain select * from actor order by name; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231636847.png" alt="image-20211211231636847"></p>
<p>2、film.name建立了idx_name索引,此时查询时extra是using index </p>
<p>explain select * from film order by name; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231657103.png" alt="image-20211211231657103"></p>
<p>6）Select tables optimized away：<strong>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</strong></p>
<p>explain select min(id) from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231723599.png" alt="image-20211211231723599"></p>
<h2 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position, hire_time )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;LiLei&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;mana ger&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) );<br></code></pre></td></tr></table></figure>

<h3 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1.全值匹配"></a>1.全值匹配</h3><p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132754065.png" alt="image-20211212132754065"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132810459.png" alt="image-20211212132810459"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132821885.png" alt="image-20211212132821885"></p>
<h3 id="2-最左前缀法则"><a href="#2-最左前缀法则" class="headerlink" title="2.最左前缀法则"></a>2.最左前缀法则</h3><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列</p>
<p>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212133112471.png" alt="image-20211212133112471"></p>
<h3 id="3-不在索引列上做任何操作"><a href="#3-不在索引列上做任何操作" class="headerlink" title="3.不在索引列上做任何操作"></a>3.不在索引列上做任何操作</h3><p>（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212133313784.png" alt="image-20211212133313784"></p>
<p>给hire_time增加一个普通索引： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_hire_time` (`hire_time`) <span class="hljs-keyword">USING</span> BTREE;<br></code></pre></td></tr></table></figure>

<p>EXPLAIN select * from employees where date(hire_time) =’2018-09-30’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212134448828.png" alt="image-20211212134448828"></p>
<p>转化为日期范围查询，会走索引,再还原最初索引状态 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_hire_time` (`hire_time`) <span class="hljs-keyword">USING</span> BTREE;<br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> hire_time <span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2018-09-30 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> hire_time <span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2018-09-30 23:59:59&#x27;</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <span class="hljs-keyword">DROP</span> INDEX `idx_hire_time`;<br></code></pre></td></tr></table></figure>

<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212134848499.png" alt="image-20211212134848499"></p>
<h3 id="4-存储引擎不能使用索引中范围条件右边的列"><a href="#4-存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="4.存储引擎不能使用索引中范围条件右边的列"></a>4.存储引擎不能使用索引中范围条件右边的列</h3><p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212135038639.png" alt="image-20211212135038639"></p>
<h3 id="5-尽量使用覆盖索引"><a href="#5-尽量使用覆盖索引" class="headerlink" title="5.尽量使用覆盖索引"></a>5.尽量使用覆盖索引</h3><p>（只访问索引的查询（索引列包含查询列）），减少select *语句 </p>
<p>EXPLAIN SELECT name,age FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140701049.png" alt="image-20211212140701049"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140533870.png" alt="image-20211212140533870"></p>
<h3 id="6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描"><a href="#6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描" class="headerlink" title="6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描"></a>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</h3><p>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140732839.png" alt="image-20211212140732839"></p>
<p>走索引覆盖优化<br>EXPLAIN SELECT name  FROM employees WHERE name != ‘LiLei’;<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141216350.png" alt="image-20211212141216350"></p>
<h3 id="7-is-null-is-not-null-也无法使用索引"><a href="#7-is-null-is-not-null-也无法使用索引" class="headerlink" title="7.is null,is not null 也无法使用索引"></a>7.is null,is not null 也无法使用索引</h3><p>EXPLAIN SELECT * FROM employees WHERE name is null </p>
<p>优化方案:字段定义not null且设置默认值</p>
<h3 id="8-like以通配符开头（’-abc…’）"><a href="#8-like以通配符开头（’-abc…’）" class="headerlink" title="8.like以通配符开头（’%abc…’）"></a>8.like以通配符开头（’%abc…’）</h3><p>​    mysql索引失效会变成全表扫描操作 </p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141604151.png" alt="image-20211212141604151"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141623205.png" alt="image-20211212141623205"></p>
<p>问题：解决like’%字符串%’索引不被使用的方法？ </p>
<p>a）使用覆盖索引，查询字段必须是建立覆盖索引字段 </p>
<p>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141653284.png" alt="image-20211212141653284"></p>
<p>b）如果不能使用覆盖索引则可能需要借助搜索引擎 如：ES</p>
<h3 id="9-字符串不加单引号索引失效"><a href="#9-字符串不加单引号索引失效" class="headerlink" title="9.字符串不加单引号索引失效"></a>9.字符串不加单引号索引失效</h3><p>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141729418.png" alt="image-20211212141729418"></p>
<h3 id="10-少用or或in"><a href="#10-少用or或in" class="headerlink" title="10.少用or或in"></a>10.少用or或in</h3><p>​    用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化 </p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’; </p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142110215.png" alt="image-20211212142110215"></p>
<h3 id="11-范围查询优化"><a href="#11-范围查询优化" class="headerlink" title="11.范围查询优化"></a>11.范围查询优化</h3><p>给年龄添加单值索引 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_age` (`age`) <span class="hljs-keyword">USING</span> BTREE ; <br></code></pre></td></tr></table></figure>

<p>explain select * from employees where age &gt;=1 and age &lt;=2000;<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142353972.png" alt="image-20211212142353972"></p>
<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引<br>优化方法：可以讲大的范围拆分成多个小范围 </p>
<p>explain select * from employees where age &gt;=0 and age &lt;=10;<br><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142511643.png" alt="image-20211212142511643"></p>
<p>还原最初索引状态 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">DROP</span> INDEX `idx_age`; <br></code></pre></td></tr></table></figure>

<h2 id="索引使用总结："><a href="#索引使用总结：" class="headerlink" title="索引使用总结："></a>索引使用总结：</h2><p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212212248730.png" alt="image-20211212212248730"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优04-Mysql锁与事务隔离级别与MVCC</title>
    <url>/2021/12/19/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Mysql锁与事务隔离级别"><a href="#Mysql锁与事务隔离级别" class="headerlink" title="Mysql锁与事务隔离级别"></a>Mysql锁与事务隔离级别</h1><h2 id="1、锁定义"><a href="#1、锁定义" class="headerlink" title="1、锁定义"></a>1、锁定义</h2><p>​        锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外， 数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性 是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个 重要因素。</p>
<h2 id="2、锁分类"><a href="#2、锁分类" class="headerlink" title="2、锁分类"></a>2、锁分类</h2><p>1、从性能上分为<strong>悲观锁</strong> 和<strong>乐观锁</strong>(用版本对比来实现)</p>
<p>2、从对数据库操作的类型分，分为<strong>读锁</strong>和<strong>写锁</strong>(<strong>==都属于悲观锁==</strong>) </p>
<p>​        1、读锁（共享锁）：针对同一份数据，<strong>多个读操作可以同时进行而不会互相影响</strong> </p>
<p>​        2、写锁（排它锁）：当前写操作没有完成前，它<strong>会阻断其他写锁和读锁</strong> </p>
<p>​                1、从对数据操作的粒度分，分为表锁和行锁</p>
<h3 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h3><p>​        每次操作锁住整张表。</p>
<p>​        开销小，加锁快；不会出现死锁；</p>
<p>​        锁定粒度大，发生锁冲突的概率最高，并发度最低</p>
<h4 id="2-1-1-基本操作"><a href="#2-1-1-基本操作" class="headerlink" title="2.1.1 基本操作"></a>2.1.1 基本操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mylock` (<br>	`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, <br>	`NAME` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>	<span class="hljs-keyword">PRIMARY</span> KEY ( `id` ) <br>) ENGINE <span class="hljs-operator">=</span> MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-comment">-- 插入数据 </span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `mylock` ( `id`, `NAME` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span> );<br>	<br>	<br>session <span class="hljs-number">1</span>	<br><span class="hljs-comment">-- 手动增加表锁</span><br>lock <span class="hljs-keyword">table</span> mylock read<br><span class="hljs-comment">-- 查看表上加过的锁</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> tables;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mylock<br><span class="hljs-comment">-- 删除表锁</span><br>unlock tables<br><br></code></pre></td></tr></table></figure>

<p>存在锁<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211220212824765.png" alt="image-20211220212824765"></p>
<h4 id="2-1-2-案例分析-加读锁）"><a href="#2-1-2-案例分析-加读锁）" class="headerlink" title="2.1.2 案例分析(加读锁）"></a>2.1.2 案例分析(加读锁）</h4><p>​    当前session和其他session都可以读该表 </p>
<p>​    当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p>
<h4 id="2-1-3-案例分析-加写锁）"><a href="#2-1-3-案例分析-加写锁）" class="headerlink" title="2.1.3 案例分析(加写锁）"></a>2.1.3 案例分析(加写锁）</h4><p>​    当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p>
<h4 id="2-1-4-案例结论"><a href="#2-1-4-案例结论" class="headerlink" title="2.1.4 案例结论"></a>2.1.4 案例结论</h4><p>​        MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。 </p>
<p>​    1、对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。 </p>
<p>​    2、对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作 </p>
<p><strong>总结：</strong> <strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</p>
<h3 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h3><p>​    每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p>
<p> InnoDB与MYISAM的最大不同有两点：</p>
<p>​    <strong>支持事务（TRANSACTION）</strong> </p>
<p>​    <strong>支持行级锁</strong> </p>
<h4 id="2-2-1行锁支持事务"><a href="#2-2-1行锁支持事务" class="headerlink" title="2.2.1行锁支持事务"></a>2.2.1行锁支持事务</h4><h5 id="事务（Transaction）及其ACID属性"><a href="#事务（Transaction）及其ACID属性" class="headerlink" title="事务（Transaction）及其ACID属性"></a>事务（Transaction）及其ACID属性</h5><p>​        1、<strong>原子性(Atomicity)</strong> ：事务是一个原子操作单元,其对数据的修改,要么全都执 行,要么全都不执行。</p>
<p>​        2、<strong>一致性(Consistent)</strong> ：在事务开始和完成时,数据都必须保持一致状态。这意 味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束 时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。 </p>
<p>​        3、<strong>隔离性(Isolation)</strong> ：数据库系统提供一定的隔离机制,保证事务在不受外部并 发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是 不可见的,反之亦然。</p>
<pre><code>     4、**持久性(Durable)** ：事务完成之后,它对于数据的修改是永久性的,即使出现系 统故障也能够保持
</code></pre>
<h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><p>​        1、**更新丢失（Lost Update）(脏写)**当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每 个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p>
<p>​        就是两个事务都更新一个数据，结果有一个人回滚了把另外一个人更新的数据也回滚没了        </p>
<p>​        解决办法：乐观锁加版本号或者悲观锁加行锁</p>
<p>​        2、<strong>脏读（Dirty Reads）</strong>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数 据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控 制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提 交的数据依赖关系。这种现象被形象的叫做“脏读”。 一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基 础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p>
<p>​        3、<strong>不可重读（Non-Repeatable Reads）</strong>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现 其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不 可重复读”。 一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性</p>
<p>​        4、<strong>幻读（Phantom Reads）</strong> 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插 入了满足其查询条件的新数据，这种现象就称为“幻读”。 一句话：事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>​    脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数 据库提供一定的事务隔离机制来解决。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211220223800568.png" alt="image-20211220223800568"></p>
<p>​    数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔 离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。 </p>
<p>​    同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用 对“不可重复读”和“幻读”并不敏感,可能更关心数据并发访问的能力。 </p>
<p>​    <strong>常看当前数据库的事务隔离级别: show variables like ‘tx_isolation’;</strong> </p>
<p>​    <strong>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</strong></p>
<p>​    set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable Read | Serializable;</p>
<h4 id="2-2-2-行锁与隔离级别案例分析"><a href="#2-2-2-行锁与隔离级别案例分析" class="headerlink" title="2.2.2 行锁与隔离级别案例分析"></a>2.2.2 行锁与隔离级别案例分析</h4><h5 id="1、行锁演示"><a href="#1、行锁演示" class="headerlink" title="1、行锁演示"></a>1、行锁演示</h5><p>​    一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞 </p>
<h5 id="2、读未提交"><a href="#2、读未提交" class="headerlink" title="2、读未提交"></a>2、读未提交</h5><p>（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交 读），查询表account的初始值： set tx_isolation=’read-uncommitted’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>
<p>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p>
<p>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那 客户端A查询到的数据其实就是脏数据： </p>
<p>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不 一致啊，如果你这么想就太天真 了，在应用程序中，并 不知道其他会话回滚了，要想解决这个问题可以采用<strong>读已提交</strong>的隔离级别</p>
<h5 id="3、读已提交"><a href="#3、读已提交" class="headerlink" title="3、读已提交"></a>3、读已提交</h5><p>（1）打开一个客户端A，并设置当前事务模式为read committed（读已提交 ），查询表account的所有记录： set tx_isolation=’read-committed’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account： </p>
<p>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</p>
<p>（4）客户端B的事务提交 </p>
<p>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p>
<h5 id="4、可重复读"><a href="#4、可重复读" class="headerlink" title="4、可重复读"></a>4、可重复读</h5><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表 account的所有记录 </p>
<p>​        set tx_isolation=’repeatable-read’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提 交</p>
<p>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没 有出现不可重复读的问题 </p>
<p>（4）在客户端A，接着执行update account set balance = balance - 50 where id = 1，balance没有变成400-50=350，balance值用的是步骤 （2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的 隔离级别下使用了MVCC(multi-version concurrency control)机制，</p>
<p>​    select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本 号，是当前读（当前版本）。</p>
<h5 id="5、串行化"><a href="#5、串行化" class="headerlink" title="5、串行化"></a>5、串行化</h5><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account 的初始值： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level serializable; <br><span class="hljs-keyword">start</span> transaction; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account; <br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> lilei <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> hanmei <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">3</span> <span class="hljs-operator">|</span> lucy <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">4</span> <span class="hljs-operator">|</span> lily <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br></code></pre></td></tr></table></figure>

<p>（2）打开一个客户端B，并设置当前事务模式为serializable，插入一条记录 报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，<strong>这种隔离级别并发性极低</strong>，开发中很少会用到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level serializable;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">0</span>); <br>Lock wait timeout exceeded; <br>try restarting transaction<br></code></pre></td></tr></table></figure>

<h5 id="Mysql默认级别是repeatable-read，有办法解决幻读问题吗？"><a href="#Mysql默认级别是repeatable-read，有办法解决幻读问题吗？" class="headerlink" title="Mysql默认级别是repeatable-read，有办法解决幻读问题吗？"></a>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？</h5><p>​    <strong>间隙锁在某些情况下可以解决幻读问题</strong></p>
<p>​    要避免幻读可以用间隙锁在Session_1下面执行update account set name = ‘zhuge’ where id &gt; 10 and id &lt;=20;，则其他Session没法在这个范围所包含的 间隙里插入或修改任何数据</p>
<h5 id="无索引行锁会升级为表锁"><a href="#无索引行锁会升级为表锁" class="headerlink" title="无索引行锁会升级为表锁"></a>无索引行锁会升级为表锁</h5><p>​    锁主要是加在索引上，如果对非索引字段更新, 行锁可能会变表锁 ，**==且InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。==**</p>
<h5 id="其他加锁方式"><a href="#其他加锁方式" class="headerlink" title="其他加锁方式"></a>其他加锁方式</h5><p>​    SELECT … LOCK IN SHARE MODE走的是IS锁(意向共享锁)</p>
<blockquote>
<p>​    一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行select * from parent where c_child_id=100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child(child_id) values (100)就ok了。</p>
</blockquote>
<p>​    SELECT … FOR UPDATE 走的是IX锁(意向排它锁)</p>
<h4 id="2-2-3-案例结论"><a href="#2-2-3-案例结论" class="headerlink" title="2.2.3 案例结论"></a>2.2.3 案例结论</h4><p>​    Innodb存储引擎由于实现了<strong>行级锁</strong>定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体<strong>并发处理能力</strong>方面要远远优 于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和 MYISAM相比就会有比较明显的优势了。</p>
<p>​    相对来说，Innodb的风险更高，容易锁死锁</p>
<h4 id="2-2-4-行锁分析"><a href="#2-2-4-行锁分析" class="headerlink" title="2.2.4 行锁分析"></a>2.2.4 行锁分析</h4><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况 </p>
<p>show status like’innodb_row_lock%’; </p>
<p>对各个状态量的说明如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">Innodb_row_lock_current_waits: 当前正在等待锁定的数量 <br>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 <br>Innodb_row_lock_time_avg: 每次等待所花平均时间 <br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间 <br>Innodb_row_lock_waits:系统启动后到现在总共等待的次数 <br>对于这<span class="hljs-number">5</span>个状态变量，比较重要的主要是： <br>Innodb_row_lock_time_avg （等待平均时长） <br>Innodb_row_lock_waits （等待总次数） <br>Innodb_row_lock_time（等待总时长）<br></code></pre></td></tr></table></figure>

<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统 中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p>
<h4 id="2-2-5-死锁"><a href="#2-2-5-死锁" class="headerlink" title="2.2.5 死锁"></a>2.2.5 死锁</h4><p><strong>set tx_isolation=’<strong>repeatable-read</strong>‘;</strong> </p>
<p>Session_1执行：select * from account where id=1 for update; </p>
<p>Session_2执行：select * from account where id=2 for update; </p>
<p>Session_1执行：select * from account where id=2 for update; </p>
<p>Session_2执行：select * from account where id=1 for update;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 查看近期死锁日志信息：show engine innodb status</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">24</span> <span class="hljs-number">0x750c</span> INNODB MONITOR OUTPUT<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-keyword">Per</span> <span class="hljs-keyword">second</span> averages calculated <span class="hljs-keyword">from</span> the <span class="hljs-keyword">last</span> <span class="hljs-number">39</span> seconds<br><span class="hljs-comment">-----------------</span><br>BACKGROUND THREAD<br><span class="hljs-comment">-----------------</span><br>srv_master_thread loops: <span class="hljs-number">698</span> srv_active, <span class="hljs-number">0</span> srv_shutdown, <span class="hljs-number">695589</span> srv_idle<br>srv_master_thread log flush <span class="hljs-keyword">and</span> writes: <span class="hljs-number">696287</span><br><span class="hljs-comment">----------</span><br>SEMAPHORES<br><span class="hljs-comment">----------</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: reservation count <span class="hljs-number">585</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: signal count <span class="hljs-number">545</span><br>RW<span class="hljs-operator">-</span>shared spins <span class="hljs-number">548</span>, rounds <span class="hljs-number">960</span>, OS waits <span class="hljs-number">417</span><br>RW<span class="hljs-operator">-</span>excl spins <span class="hljs-number">25</span>, rounds <span class="hljs-number">595</span>, OS waits <span class="hljs-number">27</span><br>RW<span class="hljs-operator">-</span>sx spins <span class="hljs-number">3</span>, rounds <span class="hljs-number">61</span>, OS waits <span class="hljs-number">2</span><br>Spin rounds <span class="hljs-keyword">per</span> wait: <span class="hljs-number">1.75</span> RW<span class="hljs-operator">-</span>shared, <span class="hljs-number">23.80</span> RW<span class="hljs-operator">-</span>excl, <span class="hljs-number">20.33</span> RW<span class="hljs-operator">-</span>sx<br><span class="hljs-comment">------------------------</span><br>LATEST DETECTED DEADLOCK<br><span class="hljs-comment">------------------------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">01</span> <span class="hljs-number">0xe360</span><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">1</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">399250</span>, ACTIVE <span class="hljs-number">30</span> sec starting index read<br>mysql tables <span class="hljs-keyword">in</span> use <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br>LOCK WAIT <span class="hljs-number">3</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">2</span> <span class="hljs-type">row</span> lock(s)<br>MySQL thread id <span class="hljs-number">33</span>, OS thread handle <span class="hljs-number">23912</span>, query id <span class="hljs-number">802533</span> localhost ::<span class="hljs-number">1</span> root statistics<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> update<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">1</span>) WAITING <span class="hljs-keyword">FOR</span> THIS LOCK <span class="hljs-keyword">TO</span> BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399250</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000002</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061775</span>; <span class="hljs-keyword">asc</span>      u;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a90000011e0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">6e616</span>d65; <span class="hljs-keyword">asc</span> name;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80003e80</span>; <span class="hljs-keyword">asc</span>   <span class="hljs-operator">&gt;</span> ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">399251</span>, ACTIVE <span class="hljs-number">15</span> sec starting index read, thread declared inside InnoDB <span class="hljs-number">5000</span><br>mysql tables <span class="hljs-keyword">in</span> use <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br><span class="hljs-number">3</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">2</span> <span class="hljs-type">row</span> lock(s)<br>MySQL thread id <span class="hljs-number">34</span>, OS thread handle <span class="hljs-number">58208</span>, query id <span class="hljs-number">802537</span> localhost ::<span class="hljs-number">1</span> root statistics<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> update<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) HOLDS THE LOCK(S):<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399251</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000002</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061775</span>; <span class="hljs-keyword">asc</span>      u;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a90000011e0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">6e616</span>d65; <span class="hljs-keyword">asc</span> name;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80003e80</span>; <span class="hljs-keyword">asc</span>   <span class="hljs-operator">&gt;</span> ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) WAITING <span class="hljs-keyword">FOR</span> THIS LOCK <span class="hljs-keyword">TO</span> BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399251</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">6</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000001</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061771</span>; <span class="hljs-keyword">asc</span>      q;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a7000001df0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">5</span>; hex <span class="hljs-number">6</span>c696c6569; <span class="hljs-keyword">asc</span> lilei;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">800001</span>c2; <span class="hljs-keyword">asc</span>     ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> WE ROLL BACK TRANSACTION (<span class="hljs-number">2</span>)<br><span class="hljs-comment">------------</span><br>TRANSACTIONS<br><span class="hljs-comment">------------</span><br>Trx id counter <span class="hljs-number">399252</span><br>Purge done <span class="hljs-keyword">for</span> trx<span class="hljs-string">&#x27;s n:o &lt; 399236 undo n:o &lt; 0 state: running but idle</span><br><span class="hljs-string">History list length 540</span><br><span class="hljs-string">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="hljs-string">---TRANSACTION 283720369143296, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 283720369145040, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 283720369141552, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 399250, ACTIVE 53 sec</span><br><span class="hljs-string">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="hljs-string">MySQL thread id 33, OS thread handle 23912, query id 802544 localhost ::1 root</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">FILE I/O</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">I/O thread 0 state: wait Windows aio (insert buffer thread)</span><br><span class="hljs-string">I/O thread 1 state: wait Windows aio (log thread)</span><br><span class="hljs-string">I/O thread 2 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 3 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 4 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 5 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 6 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 7 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 8 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 9 state: wait Windows aio (write thread)</span><br><span class="hljs-string">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="hljs-string"> ibuf aio reads:, log i/o&#x27;</span>s:, sync i<span class="hljs-operator">/</span>o<span class="hljs-string">&#x27;s:</span><br><span class="hljs-string">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="hljs-string">11388 OS file reads, 275231 OS file writes, 268926 OS fsyncs</span><br><span class="hljs-string">0.00 reads/s, 0 avg bytes/read, 0.15 writes/s, 0.00 fsyncs/s</span><br><span class="hljs-string">-------------------------------------</span><br><span class="hljs-string">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="hljs-string">-------------------------------------</span><br><span class="hljs-string">Ibuf: size 1, free list len 113, seg size 115, 51 merges</span><br><span class="hljs-string">merged operations:</span><br><span class="hljs-string"> insert 76, delete mark 78, delete 42</span><br><span class="hljs-string">discarded operations:</span><br><span class="hljs-string"> insert 0, delete mark 0, delete 0</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 3 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">0.36 hash searches/s, 0.38 non-hash searches/s</span><br><span class="hljs-string">---</span><br><span class="hljs-string">LOG</span><br><span class="hljs-string">---</span><br><span class="hljs-string">Log sequence number 3913168090</span><br><span class="hljs-string">Log flushed up to   3913168090</span><br><span class="hljs-string">Pages flushed up to 3913168090</span><br><span class="hljs-string">Last checkpoint at  3913168081</span><br><span class="hljs-string">0 pending log flushes, 0 pending chkp writes</span><br><span class="hljs-string">267248 log i/o&#x27;</span>s done, <span class="hljs-number">0.00</span> log i<span class="hljs-operator">/</span>o<span class="hljs-string">&#x27;s/second</span><br><span class="hljs-string">----------------------</span><br><span class="hljs-string">BUFFER POOL AND MEMORY</span><br><span class="hljs-string">----------------------</span><br><span class="hljs-string">Total large memory allocated 8585216</span><br><span class="hljs-string">Dictionary memory allocated 3494975</span><br><span class="hljs-string">Buffer pool size   512</span><br><span class="hljs-string">Free buffers       246</span><br><span class="hljs-string">Database pages     256</span><br><span class="hljs-string">Old database pages 0</span><br><span class="hljs-string">Modified db pages  0</span><br><span class="hljs-string">Pending reads      0</span><br><span class="hljs-string">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="hljs-string">Pages made young 0, not young 0</span><br><span class="hljs-string">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="hljs-string">Pages read 10815, created 2268, written 6967</span><br><span class="hljs-string">0.00 reads/s, 0.00 creates/s, 0.15 writes/s</span><br><span class="hljs-string">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="hljs-string">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="hljs-string">LRU len: 256, unzip_LRU len: 0</span><br><span class="hljs-string">I/O sum[9]:cur[0], unzip sum[0]:cur[0]</span><br><span class="hljs-string">--------------</span><br><span class="hljs-string">ROW OPERATIONS</span><br><span class="hljs-string">--------------</span><br><span class="hljs-string">0 queries inside InnoDB, 0 queries in queue</span><br><span class="hljs-string">0 read views open inside InnoDB</span><br><span class="hljs-string">Process ID=5632, Main thread ID=0000000000000B1C , state=sleeping</span><br><span class="hljs-string">Number of rows inserted 279451, updated 682, deleted 187, read 1383947</span><br><span class="hljs-string">0.15 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.97 reads/s</span><br><span class="hljs-string">----------------------------</span><br><span class="hljs-string">END OF INNODB MONITOR OUTPUT</span><br><span class="hljs-string">============================</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<h4 id="2-2-6-优化建议"><a href="#2-2-6-优化建议" class="headerlink" title="2.2.6 优化建议"></a>2.2.6 优化建议</h4><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p>
<p>合理设计索引，尽量缩小锁的范围 </p>
<p>尽可能减少检索条件范围，避免间隙锁 </p>
<p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql </p>
<p>尽量放在事务最后执行 </p>
<p>尽可能低级别事务隔离</p>
<h1 id="MVCC机制详解"><a href="#MVCC机制详解" class="headerlink" title="MVCC机制详解"></a>MVCC机制详解</h1><p>多个事务并发运行的时候，同时读写一个数据，可能会出现脏写、脏读、不可重复读、幻读几个问题</p>
<p>​    脏写，就是两个事务都更新一个数据，结果有一个人回滚了把另外一个人更新的数据也回滚没了；<br>​    脏读，就是一个事务读到了另外一个还没提交的时候修改的数据，结果另外一个事务回滚了，下次读就读不到了；<br>​    不可重复读，就是多次读同一条数据，别的事务修改数据值还提交了，多次读到的值不同；<br>​    幻读，就是范围查询，每次查询的的数据不同，有时候别的事务插入了新的值，就会读到的值不同</p>
<p>针对这些问题,<strong>才有了 RU（读未提交）、RC（读已提交）、RR（可重复读） 和串行四个隔离级别</strong></p>
<p>​    <strong>RU 隔离级别，就是可以读到别人还没提交的事务修改过的数据，只能避免脏写问题；</strong><br>​    <strong>RC 隔离级别，可以读到人家提交的事务修改过的数据，可以避免脏写和脏读问题；</strong><br>​    <strong>RR 是不会读到别的事务已经提交事务修改的数据，可以避免脏读、脏写和不可重复读的问题；</strong><br>​    <strong>串行是让事务都串行执行，可以避免所有问题</strong></p>
<p>MySQL 实现 MVCC 机制的时候，是基于 <strong>undo log 多版本链条</strong> + <strong>ReadView</strong> 机制来做的，默认的 RR 隔离级别，就是基于这套机制实现了 RR 级别，除了避免脏写、脏读、不可重复读，还能避免幻读问题。因此我们一般来说我们都用默认的 RR 隔离级别就可以了</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>​    总起起来，就是多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏<br>字段 trx_id 和 roll_pointer，同时之前多个数据快照对应的 undo log，会通过roll_pointer 指针串联起来，形成一个重要的版本链</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211222230309957.png" alt="image-20211222230309957"></p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>​    ReadView简单来说就是你执行一个事务的时候就给你生成一个 ReadView，里面比较关键的东西有 4个</p>
<p>m_ids，这个就是说此时有哪些事务在 MySQL 里执行还没提交的<br>min_trx_id，就是 m_ids 里面最小的值<br>max_trx_id，就是说 MySQL 下一个要生成的事务 id，就是最大事务 id<br>creator_trx_id，就是你这个事务的 id</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211222230650385.png" alt="image-20211222230650385"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Review 其实就是查询时更具事务id，去查询数据中事务id &lt;= 当前事务id的记录，如果发现记录事务id大于当前事务id，则沿着undo log链找到 &lt;= 当前事务id的记录。</p>
<p>2、在读已提交的事务隔离级别下，每次执行select拍快照ReadView</p>
<p>3、在可重复读的事务隔离级别下，事务后首次查询时拍快照ReadView，从而达到可重复度的效果</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Mysql</tag>
        <tag>事务</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优03-Mysql索引优化实战</title>
    <url>/2021/12/12/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="Mysql如何选择合适的索引"><a href="#Mysql如何选择合适的索引" class="headerlink" title="Mysql如何选择合适的索引"></a>Mysql如何选择合适的索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position, hire_time )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;LiLei&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;mana ger&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) );<br></code></pre></td></tr></table></figure>

<p><strong>mysql&gt; EXPLAIN select * from employees where name &gt; ‘a’;</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212213552032.png" alt="image-20211212213552032"></p>
<p>如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下： </p>
<p>还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下： </p>
<p><strong>mysql&gt; EXPLAIN select name,age,position from employees where name &gt; ‘a’ ;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212213730591.png" alt="image-20211212213730591"></p>
<p><strong>mysql&gt; EXPLAIN select * from employees where name &gt; ‘zzz’ ;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212214147100.png" alt="image-20211212214147100"></p>
<p>select * from employees where name &gt; ‘a’;<br>select * from employees where name &gt; ‘zzz’；</p>
<p>对于上面这两种 name&gt;’a’ 和 name&gt;’zzz’ 的执行结果，mysql最终是否选择走索引或者一张表涉及多个索引，mysql最终如何选择索引，我们可以用trace工具来一查究竟，开启trace工具会影响mysql性能，所以只能临时分析sql使用，用完之后立即关闭</p>
<h3 id="trace工具用法"><a href="#trace工具用法" class="headerlink" title="trace工具用法"></a>trace工具用法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>; <span class="hljs-comment">-- 开启trace</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE;<br><span class="hljs-comment">-- 结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描 </span><br>查看trace字段：<br>&#123;<br>  &quot;steps&quot;: [<br>    &#123;<br>      &quot;join_preparation&quot;: &#123;  -- 第一阶段：SQL准备阶段 10<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;expanded_query&quot;: &quot;/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` &gt; &#x27;a&#x27;) order by `employees`.`position`&quot;<br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_preparation */<br>    &#125;,<br>    &#123;<br>      &quot;join_optimization&quot;: &#123;  -- 第二阶段：SQL优化阶段<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;condition_processing&quot;: &#123; -- 条件处理<br>              &quot;condition&quot;: &quot;WHERE&quot;,<br>              &quot;original_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;,<br>              &quot;steps&quot;: [<br>                &#123;<br>                  &quot;transformation&quot;: &quot;equality_propagation&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;,<br>                &#123;<br>                  &quot;transformation&quot;: &quot;constant_propagation&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;,<br>                &#123;<br>                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* steps */</span><br>            &#125; /* condition_processing */<br>          &#125;,<br>          &#123;<br>            &quot;substitute_generated_columns&quot;: &#123;<br>            &#125; /* substitute_generated_columns */<br>          &#125;,<br>          &#123;<br>            &quot;table_dependencies&quot;: [ <span class="hljs-comment">-- 表依赖详情</span><br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;row_may_be_null&quot;: <span class="hljs-literal">false</span>,<br>                &quot;map_bit&quot;: <span class="hljs-number">0</span>,<br>                &quot;depends_on_map_bits&quot;: [<br>                ] <span class="hljs-comment">/* depends_on_map_bits */</span><br>              &#125;<br>            ] <span class="hljs-comment">/* table_dependencies */</span><br>          &#125;,<br>          &#123;<br>            &quot;ref_optimizer_key_uses&quot;: [<br>            ] <span class="hljs-comment">/* ref_optimizer_key_uses */</span><br>          &#125;,<br>          &#123;<br>            &quot;rows_estimation&quot;: [ <span class="hljs-comment">-- 预估表的访问成本</span><br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;range_analysis&quot;: &#123;<br>                  &quot;table_scan&quot;: &#123; -- 全表扫描情况<br>                    &quot;rows&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 扫描行数</span><br>                    &quot;cost&quot;: <span class="hljs-number">3.7</span> <span class="hljs-comment">-- 查询成本(相对值，同一个trace内部比较才有意义)</span><br>                  &#125; /* table_scan */,<br>                  &quot;potential_range_indexes&quot;: [ <span class="hljs-comment">-- 查询可能使用的索引</span><br>                    &#123;<br>                      &quot;index&quot;: &quot;PRIMARY&quot;, <span class="hljs-comment">-- 主键索引</span><br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 不采用</span><br>                      &quot;cause&quot;: &quot;not_applicable&quot;<br>                    &#125;,<br>                    &#123;<br>                      &quot;index&quot;: &quot;idx_name_age_position&quot;, <span class="hljs-comment">-- 其他辅助索引</span><br>                      &quot;usable&quot;: <span class="hljs-literal">true</span>, <span class="hljs-comment">-- 采用</span><br>                      &quot;key_parts&quot;: [<br>                        &quot;name&quot;,<br>                        &quot;age&quot;,<br>                        &quot;position&quot;,<br>                        &quot;id&quot;<br>                      ] <span class="hljs-comment">/* key_parts */</span><br>                    &#125;,<br>                    &#123;<br>                      &quot;index&quot;: &quot;idx_age&quot;,<br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>                      &quot;cause&quot;: &quot;not_applicable&quot;<br>                    &#125;<br>                  ] <span class="hljs-comment">/* potential_range_indexes */</span>, <br>                  &quot;setup_range_conditions&quot;: [<br>                  ] <span class="hljs-comment">/* setup_range_conditions */</span>,<br>                  &quot;group_index_range&quot;: &#123;<br>                    &quot;chosen&quot;: <span class="hljs-literal">false</span>,<br>                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;<br>                  &#125; /* group_index_range */,<br>                  &quot;analyzing_range_alternatives&quot;: &#123; -- 分析各个索引使用成本<br>                    &quot;range_scan_alternatives&quot;: [<br>                      &#123;<br>                        &quot;index&quot;: &quot;idx_name_age_position&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;a &lt; name&quot;<br>                        ] <span class="hljs-comment">/* ranges */</span>,<br>                        &quot;index_dives_for_eq_ranges&quot;: <span class="hljs-literal">true</span>,<br>                        &quot;rowid_ordered&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 使用该索引获取的记录是否按照主键排序</span><br>                        &quot;using_mrr&quot;: <span class="hljs-literal">false</span>,<br>                        &quot;index_only&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 是否使用覆盖索引</span><br>                        &quot;rows&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 索引扫描行数</span><br>                        &quot;cost&quot;: <span class="hljs-number">4.61</span>,<span class="hljs-comment">-- 索引使用成本</span><br>                        &quot;chosen&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 是否选择该索引</span><br>                        &quot;cause&quot;: &quot;cost&quot; <span class="hljs-comment">-- 原因：耗时成本</span><br>                      &#125;<br>                    ] <span class="hljs-comment">/* range_scan_alternatives */</span>,<br>                    &quot;analyzing_roworder_intersect&quot;: &#123;<br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;<br>                    &#125; /* analyzing_roworder_intersect */<br>                  &#125; /* analyzing_range_alternatives */<br>                &#125; /* range_analysis */<br>              &#125;<br>            ] <span class="hljs-comment">/* rows_estimation */</span><br>          &#125;,<br>          &#123;<br>            &quot;considered_execution_plans&quot;: [<br>              &#123;<br>                &quot;plan_prefix&quot;: [<br>                ] <span class="hljs-comment">/* plan_prefix */</span>,<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;best_access_path&quot;: &#123; -- 最优访问路径<br>                  &quot;considered_access_paths&quot;: [ <span class="hljs-comment">-- 最终选择的访问路径 </span><br>                    &#123;<br>                      &quot;rows_to_scan&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 访问类型：为scan，全表扫描</span><br>                      &quot;access_type&quot;: &quot;scan&quot;,<br>                      &quot;resulting_rows&quot;: <span class="hljs-number">3</span>,<br>                      &quot;cost&quot;: <span class="hljs-number">1.6</span>,<br>                      &quot;chosen&quot;: <span class="hljs-literal">true</span>,  <span class="hljs-comment">-- 确定选择</span><br>                      &quot;use_tmp_table&quot;: <span class="hljs-literal">true</span><br>                    &#125;<br>                  ] <span class="hljs-comment">/* considered_access_paths */</span><br>                &#125; /* best_access_path */,<br>                &quot;condition_filtering_pct&quot;: <span class="hljs-number">100</span>,<br>                &quot;rows_for_plan&quot;: <span class="hljs-number">3</span>,<br>                &quot;cost_for_plan&quot;: <span class="hljs-number">1.6</span>,<br>                &quot;sort_cost&quot;: <span class="hljs-number">3</span>,<br>                &quot;new_cost_for_plan&quot;: <span class="hljs-number">4.6</span>,<br>                &quot;chosen&quot;: <span class="hljs-literal">true</span><br>              &#125;<br>            ] <span class="hljs-comment">/* considered_execution_plans */</span><br>          &#125;,<br>          &#123;<br>            &quot;attaching_conditions_to_tables&quot;: &#123;<br>              &quot;original_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;,<br>              &quot;attached_conditions_computation&quot;: [<br>              ] <span class="hljs-comment">/* attached_conditions_computation */</span>,<br>              &quot;attached_conditions_summary&quot;: [<br>                &#123;<br>                  &quot;table&quot;: &quot;`employees`&quot;,<br>                  &quot;attached&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* attached_conditions_summary */</span><br>            &#125; /* attaching_conditions_to_tables */<br>          &#125;,<br>          &#123;<br>            &quot;clause_processing&quot;: &#123;<br>              &quot;clause&quot;: &quot;ORDER BY&quot;,<br>              &quot;original_clause&quot;: &quot;`employees`.`position`&quot;,<br>              &quot;items&quot;: [<br>                &#123;<br>                  &quot;item&quot;: &quot;`employees`.`position`&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* items */</span>,<br>              &quot;resulting_clause_is_simple&quot;: <span class="hljs-literal">true</span>,<br>              &quot;resulting_clause&quot;: &quot;`employees`.`position`&quot;<br>            &#125; /* clause_processing */<br>          &#125;,<br>          &#123;<br>            &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;<br>              &quot;clause&quot;: &quot;ORDER BY&quot;,<br>              &quot;index_order_summary&quot;: &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;index_provides_order&quot;: <span class="hljs-literal">false</span>,<br>                &quot;order_direction&quot;: &quot;undefined&quot;,<br>                &quot;index&quot;: &quot;unknown&quot;,<br>                &quot;plan_changed&quot;: <span class="hljs-literal">false</span><br>              &#125; /* index_order_summary */<br>            &#125; /* reconsidering_access_paths_for_index_ordering */<br>          &#125;,<br>          &#123;<br>            &quot;refine_plan&quot;: [<br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;<br>              &#125;<br>            ] <span class="hljs-comment">/* refine_plan */</span><br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_optimization */<br>    &#125;,<br>    &#123;<br>      &quot;join_execution&quot;: &#123;<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;filesort_information&quot;: [<br>              &#123;<br>                &quot;direction&quot;: &quot;asc&quot;,<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;field&quot;: &quot;position&quot;<br>              &#125;<br>            ] <span class="hljs-comment">/* filesort_information */</span>,<br>            &quot;filesort_priority_queue_optimization&quot;: &#123;<br>              &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>              &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot;<br>            &#125; /* filesort_priority_queue_optimization */,<br>            &quot;filesort_execution&quot;: [<br>            ] <span class="hljs-comment">/* filesort_execution */</span>,<br>            &quot;filesort_summary&quot;: &#123;<br>              &quot;rows&quot;: <span class="hljs-number">3</span>,<br>              &quot;examined_rows&quot;: <span class="hljs-number">3</span>,<br>              &quot;number_of_tmp_files&quot;: <span class="hljs-number">0</span>,<br>              &quot;sort_buffer_size&quot;: <span class="hljs-number">200704</span>,<br>              &quot;sort_mode&quot;: &quot;&lt;sort_key, packed_additional_fields&gt;&quot;<br>            &#125; /* filesort_summary */<br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_execution */<br>    &#125;<br>  ] <span class="hljs-comment">/* steps */</span><br>&#125;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;zzz&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE; <br><span class="hljs-comment">-- 查看trace字段可知索引扫描的成本低于全表扫描，所以mysql最终选择索引扫描 </span><br><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=off&quot;; <span class="hljs-comment">-- 关闭trace</span><br><br></code></pre></td></tr></table></figure>

<h2 id="常见sql深入优化"><a href="#常见sql深入优化" class="headerlink" title="常见sql深入优化"></a>常见sql深入优化</h2><h3 id="Order-by与Group-by优化"><a href="#Order-by与Group-by优化" class="headerlink" title="Order by与Group by优化"></a>Order by与Group by优化</h3><h4 id="Case1："><a href="#Case1：" class="headerlink" title="Case1："></a>Case1：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221238882.png" alt="image-20211212221238882"></p>
<p>分析：利用最左前缀法则：中间字段不能断，因此查询用到了name索引，从key_len=74也能看出，age索引列用 </p>
<p>在排序过程中，因为Extra字段里没有using filesort </p>
<h4 id="Case-2："><a href="#Case-2：" class="headerlink" title="Case 2："></a>Case 2：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221451865.png" alt="image-20211212221451865"> </p>
<p>分析： 从explain的执行结果来看：key_len=74，查询使用了name索引，由于用了position进行排序，跳过了 </p>
<p>age，出现了<strong>Using filesort</strong>。 </p>
<h4 id="Case-3："><a href="#Case-3：" class="headerlink" title="Case 3："></a>Case 3：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221554635.png"></p>
<p>分析： 查找只用到索引name，age和position用于排序，无Using filesort。 </p>
<h4 id="Case-4："><a href="#Case-4：" class="headerlink" title="Case 4："></a>Case 4：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221654266.png"></p>
<p>分析： 和Case 3中explain的执行结果一样，但是出现了Using filesort，因为索引的创建顺序为 name,age,position，但是排序的时候age和position颠倒位置了。 </p>
<h4 id="Case-5："><a href="#Case-5：" class="headerlink" title="Case 5："></a>Case 5：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222142762.png" alt="image-20211212222142762"></p>
<p>分析： <strong>与Case 4对比，在Extra中并未出现Using filesort，因为age为常量，在排序中被优化，所以索引未颠倒，不会出现Using filesort。</strong> </p>
<h4 id="Case-6："><a href="#Case-6：" class="headerlink" title="Case 6："></a>Case 6：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222333327.png" alt="image-20211212222333327"></p>
<p>分析： 虽然排序的字段列与索引顺序一样，且order by默认升序，这里position desc变成了降序，<strong>导致与索引的</strong> </p>
<p><strong>排序方式不同</strong>，从而产生Using filesort。Mysql8以上版本有降序索引可以支持该种查询方式。 </p>
<h4 id="Case-7："><a href="#Case-7：" class="headerlink" title="Case 7："></a>Case 7：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222622724.png" alt="image-20211212222622724"></p>
<p>分析：对于排序来说，多个相等条件也是范围查询 </p>
<h4 id="Case-8："><a href="#Case-8：" class="headerlink" title="Case 8："></a>Case 8：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223349317.png" alt="image-20211212223349317"> </p>
<p>可以用覆盖索引优化 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223626651.png" alt="image-20211212223626651"></p>
<p>也可以用 force index 强制使用索引</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223536584.png" alt="image-20211212223536584"></p>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>1、MySQL支持两种方式的排序<strong>filesort</strong>和<strong>index</strong>，Using index是指MySQL扫描索引本身完成排序。index 效率高，filesort效率低。</p>
<p>2、order by满足两种情况会使用Using index。 </p>
<p>​    1) order by语句使用索引<strong>最左前列</strong>。 </p>
<p>​    2) 使用where子句与order by子句条件列<strong>组合满足索引最左前列</strong></p>
<p>3、尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则。 </p>
<p>4、如果order by的条件不在索引列上，就会产生Using filesort。 </p>
<p>5、能用覆盖索引尽量用覆盖索引 （即查询的所有列被组合索引的字段包含）</p>
<p>6、group by与order by很类似，其实质是<strong>先排序后分组</strong>，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上<strong>order by null禁止排序</strong>。注意，where高于having，能写在where中 的限定条件就不要去having限定了。</p>
<h3 id="1、Using-filesort文件排序原理详解"><a href="#1、Using-filesort文件排序原理详解" class="headerlink" title="1、Using filesort文件排序原理详解"></a>1、Using filesort文件排序原理详解</h3><h4 id="filesort文件排序方式"><a href="#filesort文件排序方式" class="headerlink" title="filesort文件排序方式"></a>filesort文件排序方式</h4><h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a>单路排序</h5><p>​    是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可 以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</p>
<h5 id="双路排序（又叫回表排序模式）"><a href="#双路排序（又叫回表排序模式）" class="headerlink" title="双路排序（又叫回表排序模式）"></a>双路排序（又叫<strong>回表</strong>排序模式）</h5><p>​    是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行数据的行ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具 </p>
<p>可以看到sort_mode信息里显示&lt; sort_key, rowid &gt; </p>
<h5 id="max-length-for-sort-data"><a href="#max-length-for-sort-data" class="headerlink" title="max_length_for_sort_data"></a>max_length_for_sort_data</h5><p>​    MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来判断使用哪种排序模式。<br>​    如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式；<br>​    如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>; <span class="hljs-comment">-- 开启trace </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhuge&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.OPTIMIZER_TRACE;<br>trace排序部分结果： <br><br>&quot;join_execution&quot;: &#123; --Sql执行阶段 <br>&quot;select#&quot;: <span class="hljs-number">1</span>, <br>&quot;steps&quot;: [ <br>&#123; <br> &quot;filesort_information&quot;: [ <br> &#123; <br> &quot;direction&quot;: &quot;asc&quot;, <br> &quot;table&quot;: &quot;`employees`&quot;, <br> &quot;field&quot;: &quot;position&quot; <br> &#125; <br> ] <span class="hljs-comment">/* filesort_information */</span>, <br> &quot;filesort_priority_queue_optimization&quot;: &#123; <br> &quot;usable&quot;: <span class="hljs-literal">false</span>, <br> &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot; <br> &#125; /* filesort_priority_queue_optimization */, <br> &quot;filesort_execution&quot;: [ <br> ] <span class="hljs-comment">/* filesort_execution */</span>, <br> &quot;filesort_summary&quot;: &#123; --文件排序信息 <br> &quot;rows&quot;: <span class="hljs-number">10000</span>, <span class="hljs-comment">--预计扫描行数 </span><br> &quot;examined_rows&quot;: <span class="hljs-number">10000</span>, <span class="hljs-comment">--参数排序的行 </span><br> &quot;number_of_tmp_files&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">--使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的 磁盘文件排序 </span><br> &quot;sort_buffer_size&quot;: <span class="hljs-number">262056</span>, <span class="hljs-comment">--排序缓存的大小 </span><br> &quot;sort_mode&quot;: &quot;&lt;sort_key, packed_additional_fields&gt;&quot; <span class="hljs-comment">--排序方式，这里用的单路排序 </span><br>&#125; /* filesort_summary */ <br> &#125; <br>] <span class="hljs-comment">/* steps */</span> <br>&#125; /* join_execution */ <br><br><br><span class="hljs-keyword">set</span> max_length_for_sort_data <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">--employees表所有字段长度总和肯定大于10字节 </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhuge&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.OPTIMIZER_TRACE;<br><br>trace排序部分结果： <br>&quot;join_execution&quot;: &#123; <br>&quot;select#&quot;: <span class="hljs-number">1</span>,<br>&quot;steps&quot;: [ <br>&#123; <br>&quot;filesort_information&quot;: [ <br>&#123; <br>&quot;direction&quot;: &quot;asc&quot;, <br>&quot;table&quot;: &quot;`employees`&quot;, <br>&quot;field&quot;: &quot;position&quot; <br>&#125; <br>] <span class="hljs-comment">/* filesort_information */</span>, <br>&quot;filesort_priority_queue_optimization&quot;: &#123; <br>&quot;usable&quot;: <span class="hljs-literal">false</span>, <br>&quot;cause&quot;: &quot;not applicable (no LIMIT)&quot; <br>&#125; /* filesort_priority_queue_optimization */, <br>&quot;filesort_execution&quot;: [ <br>] <span class="hljs-comment">/* filesort_execution */</span>, <br>&quot;filesort_summary&quot;: &#123; <br>&quot;rows&quot;: <span class="hljs-number">10000</span>, <br>&quot;examined_rows&quot;: <span class="hljs-number">10000</span>, <br>&quot;number_of_tmp_files&quot;: <span class="hljs-number">2</span>, <br>&quot;sort_buffer_size&quot;: <span class="hljs-number">262136</span>, <br>&quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot; <span class="hljs-comment">--排序方式，这里用的双路排序 </span><br>&#125; /* filesort_summary */ <br>&#125; <br>] <span class="hljs-comment">/* steps */</span> <br>&#125; /* join_execution */ <br><br><br><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=off&quot;; <span class="hljs-comment">--关闭trace</span><br></code></pre></td></tr></table></figure>

<h3 id="2、分页查询优化"><a href="#2、分页查询优化" class="headerlink" title="2、分页查询优化"></a>2、分页查询优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> employees;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100000</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position )<br>		<span class="hljs-keyword">VALUES</span><br>			( CONCAT( <span class="hljs-string">&#x27;zhuge&#x27;</span>, i ), i, <span class="hljs-string">&#x27;dev&#x27;</span> );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br></code></pre></td></tr></table></figure>

<p>很多时候我们业务系统实现分页功能可能会用如下sql实现<br>    select * from employees limit 10000,10;<br>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率 是非常低的。</p>
<h4 id="1、根据自增且连续的主键排序的分页查询"><a href="#1、根据自增且连续的主键排序的分页查询" class="headerlink" title="1、根据自增且连续的主键排序的分页查询"></a>1、根据自增且连续的主键排序的分页查询</h4><p>select * from employees limit 90000,5;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216224501539.png" alt="image-20211216224501539"></p>
<p>select * from employees where id &gt; 90000 limit 5;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216231835906.png" alt="image-20211216231835906"></p>
<p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 但是，这条改写的SQL 在很多场景并<strong>不实用</strong>，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如下图试验 所示（先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL）：</p>
<p>​    两条 SQL 的结果并不一样，因此，如果主键不连续，不能使用上面描述的优化方法。 另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满 足以下两个条件：</p>
<p>​    1、主键自增且连续 </p>
<p>​    2、结果是按照主键排序的</p>
<h4 id="2、根据非主键字段排序的分页查询"><a href="#2、根据非主键字段排序的分页查询" class="headerlink" title="2、根据非主键字段排序的分页查询"></a>2、根据非主键字段排序的分页查询</h4><p>EXPLAIN select * from employees ORDER BY name limit 90000,5; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216232215527.png" alt="image-20211216232215527"><br>Explain select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;<br>    发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因上文讲过：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。 知道不走索引的原因，那么怎么优化呢？ 其实关键是<strong>让排序时返回的字段尽可能少（索引覆盖）</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216232245214.png" alt="image-20211216232245214"></p>
<p>原SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。 </p>
<h3 id="3、Join关联查询优化"><a href="#3、Join关联查询优化" class="headerlink" title="3、Join关联查询优化"></a>3、Join关联查询优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t1` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`a` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`b` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_a` ( `a` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2 <span class="hljs-keyword">LIKE</span> t1;<br><span class="hljs-comment">-- 往t2表插入100行记录</span><br><span class="hljs-keyword">truncate</span> t2;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2 ( a, b )<br>		<span class="hljs-keyword">VALUES</span><br>			( i, i<span class="hljs-operator">*</span>i );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br><span class="hljs-comment">-- 往t1表插入1万行记录</span><br><span class="hljs-keyword">truncate</span> t1;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 ( a, b )<br>		<span class="hljs-keyword">VALUES</span><br>			( i, i<span class="hljs-operator">*</span>i );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br></code></pre></td></tr></table></figure>

<h4 id="1、mysql的表关联常见有两种算法"><a href="#1、mysql的表关联常见有两种算法" class="headerlink" title="1、mysql的表关联常见有两种算法"></a>1、mysql的表关联常见有两种算法</h4><p>1、Nested-Loop Join 算法 </p>
<p>2、Block Nested-Loop Join 算法 </p>
<h5 id="1、-嵌套循环连接-Nested-Loop-Join-NLJ-算法"><a href="#1、-嵌套循环连接-Nested-Loop-Join-NLJ-算法" class="headerlink" title="1、 嵌套循环连接 Nested-Loop Join(NLJ) 算法"></a>1、 嵌套循环连接 Nested-Loop Join(NLJ) 算法</h5><p>​    一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行<strong>（走索引所以很快，再从磁盘中读取目标行，所以当做只做一次磁盘IO）</strong>，然后取出两张表的结果合集。</p>
<p>EXPLAIN select * from t1 inner join t2 on t1.a= t2.a;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218203442806.png" alt="image-20211218203442806"></p>
<p>​    从执行计划中可以看到这些信息： 驱动表是t2，被驱动表是t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优 化器一般会优先选择小表做驱动表。<strong>所以使用 inner join时，排在前面的表并不一定就是驱动表</strong>。 使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer 则表示使用的 join 算 法是 NLJ。</p>
<p>上面sql的大致流程如下： </p>
<p>1、从表 t2 中读取一行数据； </p>
<p>2、从第1步的数据中，取出关联字段 a，到表 t1中查找； </p>
<p>3、取出表t1中满足条件的行，跟t2中获取到的结果合并，作为结果返回给客户端； </p>
<p>4、重复上面 3 步</p>
<p>​    整个过程会读取t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了<strong>200</strong>行。 如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join 算法。</p>
<h5 id="2、基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#2、基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="2、基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法"></a><strong>2、基于块的嵌套循环连接</strong> Block Nested-Loop Join(BNL)算法</h5><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。 </p>
<p><strong>EXPLAIN select*from t1 inner join t2 on t1.b= t2.b;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218205149807.png" alt="image-20211218205149807"></p>
<p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。 </p>
<p>上面sql的大致流程如下： </p>
<p>1、 把 t2 的所有数据放入到 join_buffer 中 </p>
<p>2、把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 </p>
<p>3、返回满足 join 条件的数据 </p>
<p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。 <strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join呢？</strong> </p>
<p>​    如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = <strong>100万</strong>次，这个是<strong>磁盘扫描</strong>。很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。 </p>
<p>​    <strong>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下NLJ 算法比 BNL算法性能更高</strong> </p>
<h4 id="2、对于关联sql的优化"><a href="#2、对于关联sql的优化" class="headerlink" title="2、对于关联sql的优化"></a>2、对于关联sql的优化</h4><p>1、<strong>关联字段加索引</strong>，让mysql做join操作时尽量选择NLJ算法 </p>
<p>2、<strong>小标驱动大表</strong>，写多表连接sql时如果明确知道哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间（<strong>注意left join 已经决定了驱动表是左边，同理right join,使用inner join时myslq优化器才能自动优化</strong>）</p>
<p>​    <strong>straight_join</strong>：straight_join功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。 </p>
<p>比如：select * from t2 straight_join t1 on t2.a = t1.a; 代表制定mysql选着 t2 表作为驱动表。 </p>
<p>​    <strong>straight_join只适用于inner join</strong>，并不适用于left join，right join。（因为left join，right join已经代表指 </p>
<p>定了表的执行顺序） </p>
<p>​    <strong>尽可能让优化器去判断</strong>，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因 </p>
<p>为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</p>
<h3 id="4、in和exsits优化"><a href="#4、in和exsits优化" class="headerlink" title="4、in和exsits优化"></a>4、in和exsits优化</h3><p>原则：<strong>小表驱动大表，即小的数据集驱动大的数据集</strong></p>
<p><strong>in：</strong>当B表的数据集小于A表的数据集时，in优于exists </p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br># 等价于：<br>for(select id from B)&#123; <br>	<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>exists：</strong>当A表的数据集小于B表的数据集时，exists优于in </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id) <br>#等价于: <br>for(select * from A)&#123; <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id <br>&#125; <br>#A表与B表的ID字段应建立索引<br></code></pre></td></tr></table></figure>

<p>1、EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会 忽略SELECT清单,因此没有区别 </p>
<p>2、EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比 </p>
<p>3、EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</p>
<h3 id="5、count-查询优化"><a href="#5、count-查询优化" class="headerlink" title="5、count(*)查询优化"></a>5、count(*)查询优化</h3><p><strong>EXPLAIN select count(1) from employees;</strong><br><strong>EXPLAIN select count(id) from employees;</strong><br><strong>EXPLAIN select count(name) from employees;</strong><br><strong>EXPLAIN select count(*) from employees;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224055599.png" alt="image-20211218224055599"></p>
<p>​    四个sql的执行计划一样，说明这四个sql执行效率应该差不多，区别在于根据某个字段count不会统计字段为null值的数 据行为什么mysql最终选择辅助索引而不是主键聚集索引？<strong>因为二级索引相对主键索引存储数据更少，检索性能应该更高</strong></p>
<h4 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h4><h5 id="1、查询mysql自己维护的总行数"><a href="#1、查询mysql自己维护的总行数" class="headerlink" title="1、查询mysql自己维护的总行数"></a>1、查询mysql自己维护的总行数</h5><p>​    对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224321258.png" alt="image-20211218224321258"></p>
<p>对于innodb存储引擎的表mysql不会存储表的总记录行数，查询count需要实时计算</p>
<h5 id="2、show-table-status"><a href="#2、show-table-status" class="headerlink" title="2、show table status"></a>2、show table status</h5><p>​    如果只需要知道表总行数的<strong>估计值</strong>可以用如下sql查询，性能很高 </p>
<p><strong>1、ANALYZE  table employees;</strong><br><strong>2、show table status where name = “employees”</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224401104.png" alt="image-20211218224401104"></p>
<h5 id="3、将总数维护到Redis里"><a href="#3、将总数维护到Redis里" class="headerlink" title="3、将总数维护到Redis里"></a>3、将总数维护到Redis里</h5><p>​    插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难 保证表操作和redis操作的事务一致性</p>
<h5 id="4、增加计数表"><a href="#4、增加计数表" class="headerlink" title="4、增加计数表"></a>4、增加计数表</h5><p>​    插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优06Nginx核心模块与实战</title>
    <url>/2021/10/03/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="1、Nginx-简介"><a href="#1、Nginx-简介" class="headerlink" title="1、Nginx 简介"></a>1、Nginx 简介</h2><p>​    Nginx是一个高性能<strong>WEB服务器</strong>，除它之外<strong>Apache</strong>、<strong>Tomcat</strong>、<strong>Jetty</strong>、<strong>IIS</strong>，它们都是Web服务器，或者叫做WWW（World Wide Web）服务器，相应地也都具备Web服务器的基本功能。Nginx  相对基它WEB服务有什么优势呢？</p>
<ol>
<li>Tomcat、Jetty 面向java语言，先天就是重量级的WEB服务器，其性能与Nginx没有可比性。</li>
<li>IIS只能在Windows操作系统上运行。Windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此，在需要高性能Web服务器的场合下IIS并不占优。</li>
<li>Apache(一个线程处理一个请求)的发展时期很长，而且是目前毫无争议的世界第一大Web服务器，其有许多优点，如稳定、开源、跨平台等，但它出现的时间太长了，在它兴起的年代，互联网的产业规模远远比不上今天，所以它被设计成了一个<strong>重量级的、不支持高并发的Web</strong>服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量内存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量CPU资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能Web服务器，这也促使了Lighttpd和Nginx的出现。</li>
</ol>
<h2 id="2、编译安装与基本命令"><a href="#2、编译安装与基本命令" class="headerlink" title="2、编译安装与基本命令"></a>2、编译安装与基本命令</h2><p>​    略</p>
<p>控制命令：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">#查看命令帮助<br>./sbin/nginx -?<br>#默认方式启动：<br>./sbin/nginx <br>#指定配置文件启动 <br>./sbing/nginx -c /tmp/nginx.conf <br>#指定nginx程序目录启动<br>./sbin/nginx -p /usr/local/nginx/<br><br>#快速停止<br>./sbin/nginx -s stop<br>#优雅停止<br>./sbin/nginx -s quit<br><br># 热装载配置文件 <br>./sbin/nginx -s reload<br># 重新打开日志文件<br>./sbin/nginx -s reopen<br># 设置全局命令，如下表示设置启动用户为root<br>./sbin/nginx -g &quot;user root;&quot;<br></code></pre></td></tr></table></figure>



<h2 id="3、Nginx-架构说明"><a href="#3、Nginx-架构说明" class="headerlink" title="3、Nginx 架构说明"></a>3、Nginx 架构说明</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211004150428318.png" alt="image-20211004150428318"></p>
<p><strong>架构说明：</strong></p>
<p>1）nginx启动时，会生  不处理网络请求，主要负责调度工作进程，也就是图示的三项：加载配置、启动工作进程及非停升级。所以，nginx启动以后，查看操作系统的进程列表，我们就能看到至少有两个nginx进程。<br>2）服务器实际处理网络请求及响应的是工作进程（worker），在类unix系统上，<strong>nginx可以配置多个worker，而每个worker进程都可以同时处理数以千计的网络请求。</strong><br>3）<strong>模块化设计</strong>。nginx的worker，包括核心和功能性模块，核心模块负责维持一个运行循环（run-loop），执行网络请求处理的不同阶段的模块功能，如网络读写、存储读写、内容传输、外出过滤，以及将请求发往上游服务器等。而其代码的模块化设计，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器。<br>4）<strong>事件驱动、异步及非阻塞，可以说是nginx得以获得高并发、高性能的关键因素</strong>，同时也得益于对Linux、Solaris及类BSD等操作系统内核中事件通知及I/O性能增强功能的采用，如kqueue、<strong>epoll</strong>及event ports。</p>
<h2 id="4、Nginx-配置与使用"><a href="#4、Nginx-配置与使用" class="headerlink" title="4、Nginx 配置与使用"></a>4、Nginx 配置与使用</h2><h3 id="1、配置文件语法格式"><a href="#1、配置文件语法格式" class="headerlink" title="1、配置文件语法格式"></a>1、配置文件语法格式</h3><p>先来看一个简单的nginx 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs conf">worker_processes  1;<br>events &#123;<br>    worker_connections  1024;<br>&#125;<br>http &#123;<br>    include       mime.types;<br>    default_type  application&#x2F;octet-stream;<br>    sendfile        on;<br>    keepalive_timeout  65;<br>    server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        location &#x2F; &#123;<br>            root   html;<br>            index  index.html index.htm;<br>        &#125;<br>        location &#x2F;nginx_status &#123;<br>    	   stub_status on;<br>    	   access_log   off;<br>  	    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上述配置中的events、http、server、location、upstream等属于配置项块。而worker_processes 、worker_connections、include、listen  属于配置项块中的属性。   /nginx_status   属于配置块的特定参数参数。其中server块嵌套于http块，其可以直接继承访问Http块当中的参数。</p>
<table>
<thead>
<tr>
<th align="left">**配置块 **</th>
<th align="left">名称开头用大括号包裹其对应属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>属性</strong></td>
<td align="left">基于空格切分属性名与属性值，属性值可能有多个项 都以空格进行切分 如：  access_log logs/host.access.log main</td>
</tr>
<tr>
<td align="left"><strong>参数</strong></td>
<td align="left">其配置在块名称与大括号间，其值如果有多个也是通过空格进行拆</td>
</tr>
</tbody></table>
<p>​    注意 如果配置项值中包括语法符号，比如空格符，那么需要使用单引号或双引号括住配置项值，否则Nginx会报语法错误。例如：<br>​    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>​                     ‘$status $body_bytes_sent “$http_referer” ‘<br>​                     ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<h3 id="2、配置第一个静态WEB服务"><a href="#2、配置第一个静态WEB服务" class="headerlink" title="2、配置第一个静态WEB服务"></a>2、配置第一个静态WEB服务</h3><ul>
<li>基础站点演示：</li>
<li>创建站点目录 mkdir -p /usr/www/luban </li>
<li>编写静态文件</li>
<li>配置 nginx.conf<ul>
<li>配置server</li>
<li>配置location</li>
</ul>
</li>
</ul>
<p>基本配置介绍说明：<br>（1）监听端口</p>
<p>​    语法：listen address：<br>​    默认：listen 80;<br>​    配置块：server</p>
<p>（2）主机名称</p>
<p>​    语法：server_name name[……];<br>​    默认：server_name “”;<br>​    配置块：server<br>​    server_name后可以跟多个主机名称，如server_name <a href="http://www.testweb.com/">www.testweb.com</a>、download.testweb.com;。 支持通配符与正则</p>
<p>（3）location</p>
<p>​    语法：location[=|～|～*|^～|@]/uri/{……}<br>​    配置块：server</p>
<ol>
<li>=表示把URI作为字符串，以便与参数中的uri做完全匹配。</li>
<li>/ 基于uri目录匹配</li>
<li>～表示正则匹配URI时是字母大小写敏感的。</li>
<li>～*表示正则匹配URI时忽略字母大小写问题。</li>
<li>^～表示正则匹配URI时只需要其前半部分与uri参数匹配即可。</li>
</ol>
<h3 id="3、匹配优先规则："><a href="#3、匹配优先规则：" class="headerlink" title="3、匹配优先规则："></a><strong>3、匹配优先规则：</strong></h3><ol>
<li>    精确匹配优先 =</li>
<li>    正则匹配优先 ^~</li>
<li>    前缀最大匹配优先。</li>
<li>    配置靠前优化</li>
</ol>
<p>（4）root 指定站点根目录</p>
<p>​    <strong>可配置在 server与location中，基于ROOT路径+URL中路径去寻找指定文件。</strong></p>
<p>（5）alias 指定站点别名</p>
<p>​    <strong>只能配置location 中。基于alias 路径+ URL移除location  前缀后的路径来寻找文件。</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211004160702044.png" alt="image-20211004160702044"></p>
<p><strong>如下示例：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">location /V1 &#123;<br>      alias  <span class="hljs-regexp">/www/</span>old_site;<br>      index  index.html index.htm;<br>&#125;<br><span class="hljs-comment">#访问规则如下</span><br>URL：http:<span class="hljs-regexp">//</span>xxx:xx<span class="hljs-regexp">/V1/</span>a.html<br>最终寻址：<span class="hljs-regexp">/www/</span>old_site/a.thml<br></code></pre></td></tr></table></figure>



<h3 id="4、动静分离演示："><a href="#4、动静分离演示：" class="headerlink" title="4、动静分离演示："></a><strong>4、动静分离演示：</strong></h3><p>​    创建静态站点</p>
<p>​    配置 location /static</p>
<p>​    配置 ~* .(gif|png|css|js)$ </p>
<p><strong>分离2种方式可以实现资源动静分离</strong></p>
<p>1、基于目录动静资源分离</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx">   <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-regexp">*.luban.com</span>;<br>        <span class="hljs-attribute">root</span> /usr/www/luban;<br>        <span class="hljs-attribute">location</span> / &#123;<br>                <span class="hljs-attribute">index</span> luban.html;<br>        &#125;<br>        <span class="hljs-attribute">location</span> /static &#123;<br>         <span class="hljs-attribute">alias</span> /usr/www/static;<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、基于正则动静分离</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs conf">location ~* \.(gif|jpg|png|css|js)$ &#123;  <br>      root &#x2F;usr&#x2F;www&#x2F;static;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5、防盗链配置演示："><a href="#5、防盗链配置演示：" class="headerlink" title="5、防盗链配置演示："></a><strong>5、防盗链配置演示：</strong></h3><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 加入至指定location 即可实现</span><br><span class="hljs-attribute">valid_referers</span> <span class="hljs-literal">none</span> <span class="hljs-literal">blocked</span> <span class="hljs-regexp">*.luban.com</span>;<br> <span class="hljs-attribute">if</span> ($invalid_referer) &#123;<br>       <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、下载限速："><a href="#6、下载限速：" class="headerlink" title="6、下载限速："></a><strong>6、下载限速：</strong></h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">location /download &#123;<br>    limit_rate <span class="hljs-number">1</span>m; <span class="hljs-regexp">//</span>限制每S下载速度<br>    limit_rate_after <span class="hljs-number">30</span>m; <span class="hljs-regexp">//</span> 超过<span class="hljs-number">30</span>m之后再限速<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="7、创建IP黑名单"><a href="#7、创建IP黑名单" class="headerlink" title="7、创建IP黑名单"></a><strong>7、创建IP黑名单</strong></h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#封禁指定IP</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">192.168.0.1</span>;<br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">192.168.0.1</span>;<br><span class="hljs-comment">#开放指定IP 段</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">24</span>;<br><span class="hljs-comment">#封禁所有</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span>    <span class="hljs-literal">all</span>;<br><span class="hljs-comment">#开放所有</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span>    <span class="hljs-literal">all</span>;<br><span class="hljs-comment"># 创建黑名单文件</span><br><span class="hljs-attribute">echo</span> &#x27;<span class="hljs-literal">deny</span> <span class="hljs-number">192.168.0.132</span>;&#x27; &gt;&gt; balck.ip<br><span class="hljs-comment">#http 配置块中引入 黑名单文件</span><br><span class="hljs-attribute">include</span>       black.ip;<br></code></pre></td></tr></table></figure>

<h2 id="5、日志配置"><a href="#5、日志配置" class="headerlink" title="5、日志配置"></a>5、日志配置</h2><p><strong>日志格式：</strong></p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis">log_format  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>]   &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                     <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                  <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span><span class="hljs-comment">;</span><br>access_log  logs/access.log  main<span class="hljs-comment">;</span><br><span class="hljs-comment">#基于域名打印日志</span><br>access_log logs/<span class="hljs-variable">$host</span>.access.log main<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>error日志的设置</strong><br>语法：error_log /path/file level;<br>默认：error_log logs/error.log error;<br>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，<br><strong>针对指定的客户端输出debug级别的日志</strong><br>语法：debug_connection[IP|CIDR]<br>events {<br>debug_connection 192.168.0.147; <br>debug_connection 10.224.57.0/200;<br>}<br>注意：debug 日志开启 必须在安装时 添加  –with-debug (允许debug)</p>
<h2 id="6、正向代理与反向代理"><a href="#6、正向代理与反向代理" class="headerlink" title="6、正向代理与反向代理"></a>6、正向代理与反向代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​    正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。这个过程当中客户端需要知道代理服务器地址，并配置连接。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211227222908381.png" alt="image-20211227222908381"></p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​    反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。</p>
<p>​    技术实现与正向代理没有区别，最大的区别是应用场景，主要目的是屏蔽服务端的内部实现 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211227223047489.png" alt="image-20211227223047489"></p>
<p>反向代理：技术实现与正向代理没有区别，最大的区别是应用场景，主要目的是屏蔽服务端的内部实现</p>
<p>正向代理：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>正向代理</strong></th>
<th align="left"><strong>反向代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">代理服务器位置</td>
<td align="left">客户端与服务都能连接的们位置</td>
<td align="left">目标服务器内部</td>
</tr>
<tr>
<td align="left">主要作用</td>
<td align="left">屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。</td>
<td align="left">屏蔽服务端内部实现、负载均衡、缓存。</td>
</tr>
<tr>
<td align="left">应用场景</td>
<td align="left">爬虫、翻墙、maven 的nexus 服务</td>
<td align="left">Nginx 、Apache负载均衡应用</td>
</tr>
</tbody></table>
<h3 id="Nginx代理基本配置"><a href="#Nginx代理基本配置" class="headerlink" title="Nginx代理基本配置"></a>Nginx代理基本配置</h3><p>​    Nginx 代理只需要配置 location 中配置proxy_pass 属性即可。其指向代理的服务器地址。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 正向代理到baidu 服务</span><br><span class="hljs-attr">location</span> = <span class="hljs-string">/baidu.html &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">       proxy_pass http://www.baidu.com;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"># 反向代理至 本机的8010服务</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/luban/ &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">   proxy_pass http://127.0.0.1:8010;  </span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"># 代理相关参数：</span><br><span class="hljs-meta">proxy_pass          </span> <span class="hljs-string"># 代理服务</span><br><span class="hljs-attr">proxy_redirect</span> <span class="hljs-string">off;   # 是否允许重定向</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">Host $host; # 传 header 参数至后端服务</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For $remote_addr; # 设置request header 即客户端IP 地址</span><br><span class="hljs-attr">proxy_connect_timeout</span> <span class="hljs-string">90; # 连接代理服务超时时间</span><br><span class="hljs-attr">proxy_send_timeout</span> <span class="hljs-string">90; # 请求发送最大时间</span><br><span class="hljs-attr">proxy_read_timeout</span> <span class="hljs-string">90;  # 读取最大时间</span><br><span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k; </span><br><span class="hljs-attr">proxy_buffers</span> <span class="hljs-string">4 32k;</span><br><span class="hljs-attr">proxy_busy_buffers_size</span> <span class="hljs-string">64k; </span><br><span class="hljs-attr">proxy_temp_file_write_size</span> <span class="hljs-string">64k;</span><br></code></pre></td></tr></table></figure>

<h2 id="7、负载均衡"><a href="#7、负载均衡" class="headerlink" title="7、负载均衡"></a>7、负载均衡</h2><p>​    通过proxy_pass 可以把请求代理至后端服务，但是为了实现更高的负载及性能， 我们的后端服务通常是多个， 这个是时候可以通过upstream 模块实现负载均衡。</p>
<h4 id="upstream示例"><a href="#upstream示例" class="headerlink" title="upstream示例"></a>upstream示例</h4><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">backend &#123;     </span><br>   <span class="hljs-attr">server</span> <span class="hljs-string">127.0.0.1:8010 weight=1;</span><br><span class="hljs-meta"> </span> <span class="hljs-string"> server 127.0.0.1:8080 weight=2;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">127.0.0.1:8030 weight=1 backup;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">  proxy_pass http://backend;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-comment"># upstream 相关参数:</span><br><span class="hljs-attr">server</span>	<span class="hljs-string">反向服务地址 加端口</span><br><span class="hljs-attr">weight</span>	 <span class="hljs-string">权重</span><br><span class="hljs-attr">max_fails</span>	<span class="hljs-string">失败多少次 认为主机已挂掉则，踢出</span><br><span class="hljs-attr">fail_timeout</span>	<span class="hljs-string">踢出后重新探测时间</span><br><span class="hljs-attr">backup</span>	<span class="hljs-string">备用服务</span><br><span class="hljs-attr">max_conns</span>	<span class="hljs-string">允许最大连接数</span><br><span class="hljs-attr">slow_start</span>	<span class="hljs-string">当节点恢复，不立即加入,而是等待 slow_start	后加入服务对列。</span><br></code></pre></td></tr></table></figure>

<h4 id="upstream-负载均衡算法介绍"><a href="#upstream-负载均衡算法介绍" class="headerlink" title="upstream 负载均衡算法介绍"></a>upstream 负载均衡算法介绍</h4><ul>
<li>**ll+weight： **轮询加权重 (默认)</li>
<li>**ip_hash : **基于Hash 计算 ,用于保持session 一至性</li>
<li><strong>url_hash:</strong> 静态资源缓存,节约存储，加快速度（第三方）</li>
<li>**least_conn **：最少链接（第三方）</li>
<li>**least_time  **：最小的响应时间,计算节点平均响应时间，然后取响应最快的那个，分配更高权重（第三方）</li>
</ul>
<h2 id="8、Nginx-高速缓存"><a href="#8、Nginx-高速缓存" class="headerlink" title="8、Nginx 高速缓存"></a>8、Nginx 高速缓存</h2><p><strong>1、案例分析</strong></p>
<p>​    某电商平台商品详情页需要实现 700+ QPS，如何着手去做？</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228205614945.png" alt="image-20211228205614945"></p>
<p>⾸先为分析⼀下⼀个商品详情⻚有哪些信息</p>
<p>**对于商品详情页涉及了如下主要服务： **</p>
<ul>
<li><p>商品详情页HTML页面渲染</p>
</li>
<li><p>价格服务</p>
</li>
<li><p>促销服务</p>
</li>
<li><p>库存状态/配送至服务</p>
</li>
<li><p>广告词服务</p>
</li>
<li><p>预售/秒杀服务</p>
</li>
<li><p>评价服务</p>
</li>
<li><p>试用服务</p>
</li>
<li><p>推荐服务</p>
</li>
<li><p>商品介绍服务</p>
</li>
<li><p>各品类相关的一些特殊服务</p>
</li>
<li><p><em>解决方案：</em>*</p>
</li>
</ul>
<ol>
<li>采用Ajax 动态加载 价格、广告、库存等服务</li>
<li>采用key value 缓存详情页主体html。</li>
</ol>
<h3 id="1、后台采用缓存"><a href="#1、后台采用缓存" class="headerlink" title="1、后台采用缓存"></a>1、后台采用缓存</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228210221149.png" alt="image-20211228210221149"></p>
<p><strong>问题：</strong><br>    当达到500QPS 的时候很难继续压测上去。<br><strong>分析原因</strong>：</p>
<p>​    一个详情页html  主体达平均150 kb  那么在500QPS 已接近千M局域网宽带极限。必须减少内网通信。</p>
<h3 id="2、基于Nginx-静态缓存"><a href="#2、基于Nginx-静态缓存" class="headerlink" title="2、基于Nginx 静态缓存"></a>2、基于Nginx 静态缓存</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228210706401.png" alt="image-20211228210706401"></p>
<p><strong>Nginx 静态缓存基本配置</strong></p>
<p>一、在http元素下添加缓存区声明</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#proxy_cache_path 缓存路径</span><br><span class="hljs-comment">#levels 缓存层级及目录位数</span><br><span class="hljs-comment">#keys_zone 缓存区内存大小</span><br><span class="hljs-comment">#inactive 有效期</span><br><span class="hljs-comment">#max_size 硬盘大小</span><br><span class="hljs-attr">proxy_cache_path</span> <span class="hljs-string">/data/nginx/cache_luban levels=1:2 keys_zone=cache_luban:500m inactive=20d max_size=1g;</span><br></code></pre></td></tr></table></figure>

<p>⼆、为指定location设定缓存策略</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定缓存区</span><br><span class="hljs-attr">proxy_cache</span> <span class="hljs-string">cache_luban;</span><br><span class="hljs-comment">#以全路径md5值做做为Key </span><br><span class="hljs-attr">proxy_cache_key</span> <span class="hljs-string">$host$uri$is_args$args;</span><br><span class="hljs-comment">#对不同的HTTP状态码设置不同的缓存时间</span><br><span class="hljs-attr">proxy_cache_valid</span> <span class="hljs-string">200 304 12h;</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">父元素</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">http</td>
<td align="left">proxy_cache_path</td>
<td align="left">指定缓存区的根路径</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">levels</td>
<td align="left">缓存目录层级最高三层，每层1~2个字符表示。如1:1:2 表示三层。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">keys_zone</td>
<td align="left">缓存块名称 及内存块大小。如 cache_item:500m 。表示声明一个名为cache_item 大小为500m。超出大小后最早的数据将会被清除。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">inactive</td>
<td align="left">最长闲置时间 如:10d 如果一个数据被闲置10天将会被清除</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">max_size</td>
<td align="left">缓存区硬盘最大值。超出闲置数据将会被清除</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">proxy_cache</td>
<td align="left">指定缓存区，对应keys_zone 中设置的值</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">proxy_cache_key</td>
<td align="left">通过参数拼装缓存key 如：$host$uri$is_args$args 则会以全路径md5值做做为Key</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">proxy_cache_valid</td>
<td align="left">为不同的状态码设置缓存有效期</td>
</tr>
</tbody></table>
<p>三、缓存的清除</p>
<p>该功能可以采用第三方模块 ngx_cache_purge 实现。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">location</span> <span class="hljs-string">~ /clear(/.*) &#123;</span><br><span class="hljs-comment">  #允许访问的IP</span><br><span class="hljs-meta">  </span> <span class="hljs-string">allow           127.0.0.1;</span><br><span class="hljs-comment">   #禁止访问的IP</span><br><span class="hljs-meta">  </span> <span class="hljs-string">deny            all;</span><br><span class="hljs-comment">   #配置清除指定缓存区和路径(与proxy_cache_key一至)</span><br><span class="hljs-meta">  </span> <span class="hljs-string">proxy_cache_purge    cache_luban $host$1$is_args$args;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-comment"># 访问生成缓存文件</span><br><span class="hljs-attr">http</span>:<span class="hljs-string">//www.luban.com/?a=1</span><br><span class="hljs-comment"># 清除生成的缓存,如果指定缓存不存在 则会报404 错误。</span><br><span class="hljs-attr">http</span>:<span class="hljs-string">//www.luban.com/clear/?a=1</span><br></code></pre></td></tr></table></figure>

<h2 id="9、Nginx-性能参数调优"><a href="#9、Nginx-性能参数调优" class="headerlink" title="9、Nginx 性能参数调优"></a>9、Nginx 性能参数调优</h2><p><strong>worker_processes number;</strong></p>
<blockquote>
<p>每个worker进程都是单线程的进程<br>它们会调用各个模块以实现多种多样的功能。如果这些模块确认不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程；反之，如果有可能出现阻塞式调用，那么需要配置稍多一些的worker进程。例如，如果业务方面会致使用户请求大量读取本地磁盘上的静态资源文件，而且服务器上的内存较小，以至于大部分的请求访问静态资源文件时都必须读取磁盘（磁头的寻址是缓慢的），而不是内存中的磁盘缓存，那么磁盘I/O调用可能会阻塞住worker进程少量时间，进而导致服务整体性能下降。</p>
</blockquote>
<p><strong>worker_connections number;</strong></p>
<blockquote>
<p>每个worker 进程的最大连接数<br>语法：worker_connections number;<br>默认：worker_connections 1024</p>
</blockquote>
<p><strong>worker_cpu_affinity cpumask[cpumask……]</strong></p>
<blockquote>
<p>绑定Nginx worker进程到指定的CPU内核<br>为什么要绑定worker进程到指定的CPU内核呢？假定每一个worker进程都是非常繁忙的，如果多个worker进程都在抢同一个CPU，那么这就会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。<br>例如，如果有4颗CPU内核，就可以进行如下配置：<br>worker_processes 4;<br>worker_cpu_affinity 1000 0100 0010 0001;<br>注意 worker_cpu_affinity配置仅对Linux操作系统有效。</p>
</blockquote>
<p><strong>Nginx worker 进程优先级设置</strong></p>
<blockquote>
<p>语法：worker_priority nice;<br>默认：worker_priority 0;<br>优先级由静态优先级和内核根据进程执行情况所做的动态调整（目前只有±5的调整）共同决定。nice值是进程的静态优先级，它的取值范围是–20～+19，–20是最高优先级，+19是最低优先级。因此，如果用户希望Nginx占有更多的系统资源，那么可以把nice值配置得更小一些，但不建议比内核进程的nice值（通常为–5）还要小</p>
</blockquote>
<p><strong>Nginx worker进程可以打开的最大句柄描述符个数</strong></p>
<blockquote>
<p>语法： worker_rlimit_nofile limit;<br>默认：空<br>更改worker进程的最大打开文件数限制。如果没设置的话，这个值为操作系统的限制。设置后你的操作系统和Nginx可以处理比“ulimit -a”更多的文件，所以把这个值设高，这样nginx就不会有“too many open files”问题了。</p>
</blockquote>
<p><strong>是否打开accept锁</strong></p>
<blockquote>
<p>语法：accept_mutex[on|off]<br>默认：accept_mutext on;<br>accept_mutex是Nginx的负载均衡锁，当某一个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，accept锁默认是打开的，如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡，因此不建议关闭它。</p>
</blockquote>
<p><strong>使用accept锁后到真正建立连接之间的延迟时间</strong></p>
<blockquote>
<p>语法：accept_mutex_delay Nms; <br>默认：accept_mutex_delay 500ms; <br>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个accept锁不是堵塞锁，如果取不到会立刻返回。如果只有一个worker进程试图取锁而没有取到，他至少要等待accept_mutex_delay定义的时间才能再次试图取锁。</p>
</blockquote>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>组件：</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211005141533525.png" alt="image-20211005141533525"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211005141558603.png" alt="image-20211005141558603"></p>
<p>server</p>
<p>connector</p>
<p>​    service</p>
<p>​        connector</p>
<p>​        engine</p>
<p>​            host    </p>
<p>​                context</p>
<p>网络模型 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211005142850381.png" alt="image-20211005142850381"></p>
<h2 id="Tomcat-支持四种线程模型"><a href="#Tomcat-支持四种线程模型" class="headerlink" title="Tomcat 支持四种线程模型"></a>Tomcat 支持四种线程模型</h2><h3 id="在高并发场景下BIO与NIO的线程数的变化"><a href="#在高并发场景下BIO与NIO的线程数的变化" class="headerlink" title="在高并发场景下BIO与NIO的线程数的变化"></a>在高并发场景下BIO与NIO的线程数的变化</h3><p><strong>演示数据：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>每秒提交数</strong></th>
<th><strong>BIO执行线程</strong></th>
<th><strong>NIO执行线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td>预测</td>
<td>200</td>
<td>200线程</td>
<td>20线程</td>
</tr>
<tr>
<td>实验实际</td>
<td>200</td>
<td>55 wait个线程</td>
<td>23个线程</td>
</tr>
<tr>
<td>模拟生产环境</td>
<td>200</td>
<td>229个run线程</td>
<td>20个wait 线程</td>
</tr>
</tbody></table>
<p>BIO的线程数量的影响因素：网络IO情况（客户端建立连接请求时间/服务端响应时间） ，服务端程序执行业务用时，客户端响应情况</p>
<p>NIO的线程影响因素：服务端执行业务用时</p>
<p>1、网络IO时间</p>
<p>2、程序执行业务用时</p>
<p><strong>BIO 线程模型讲解</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/wps2A97.tmp.jpg" alt="img"></p>
<p>类加载-java双亲委派机制</p>
<p>类加载器在加载类时，会依据 Application ClassLoader -&gt; Extension ClassLoader -&gt; Boostrap ClassLoader的顺序向上递归查找，最顶层没加载到，则第二层查找以此类推。所以<br>    <strong>默认情况下，</strong></p>
<p>​    <strong>一个限定名称的类只会被一个类加载器加载</strong></p>
<p>   <strong>不同的类加载器，除了读取二进制流的动作和范围不一样，后续的加载逻辑是一样的（final 方法修饰defineClass进行后续处理）</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211006121920999.png" alt="image-20211006121920999"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211006130446839.png" alt="image-20211006130446839"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/04/26/Maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><h3 id="第1章-maven概述"><a href="#第1章-maven概述" class="headerlink" title="第1章 maven概述"></a>第1章 maven概述</h3><blockquote>
<p>maven是一个自动化构建的项目管理工具</p>
<p>1、背景</p>
<p>（1）jar包的导入需要手动</p>
<p>（2）jar包的依赖需要清楚</p>
<p>（3）jar包重复导入（jar包版本问题）</p>
<p>（4）项目划分只能使用package</p>
<p>（5）项目打包文件大小小，节省磁盘空间</p>
<p>（与传统web项目不同，maven会将所有jar包放在镜像仓库，部署上线的项目会自动到仓库下载jar包）</p>
<p>2、解决</p>
<p>（1）自动导入jar包及其依赖jar包</p>
<p>（2）可以使用mudule划分大型项目</p>
</blockquote>
<h3 id="第2章-仓库类型"><a href="#第2章-仓库类型" class="headerlink" title="第2章 仓库类型"></a>第2章 仓库类型</h3><blockquote>
<p>1、maven仓库分为3种</p>
<p>（1）本地仓库、远程仓库【企业搭建的私服、中央仓库】</p>
<p>2、maven下载jar包流程</p>
<p>（1）本地仓库 -&gt; 远程仓库 -&gt; 中央仓库-&gt;镜像仓库</p>
<p><img src="images/Maven%E5%9F%BA%E7%A1%80/160b27fd1730a299" alt="image.png"></p>
<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>一般来说，在Maven项目目录下，没有诸如lib/这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p>
<p>默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2/repository/的仓库目录。 如果你想自定义本地仓库目录地址。你可以编辑文件~/.m2/settings.xml，设置localRepository元素的值为想要的仓库地址，例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\repository\<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样，该用户的本地仓库地址就被设置成了 D:\java\repository\。 需要注意的是，默认情况下，~/.m2/settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME/conf/settings.xml文件再进行编辑。</p>
<h4 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h4><p>由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。</p>
<p>中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。</p>
<h4 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h4><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。 私服的好处：</p>
<ul>
<li>节省自己的外网速度</li>
<li>加速Maven构建</li>
<li>部署第三方构建</li>
<li>提高稳定性，增强控制</li>
<li>降低中央仓库的负荷</li>
</ul>
<h4 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h4><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置远程仓库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jboss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>JBoss Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>daily<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>**repository:**在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li>
<li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li>
<li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li>
<li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li>
<li><strong>releases和snapshots：</strong>用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是<strong>enabled</strong>子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li>
<li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li>
<li><strong>其他：</strong>对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。<br> 1：元素<strong>updatePolicy</strong>用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br> 2：元素<strong>checksumPolicy</strong>用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</li>
</ul>
<h4 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h4><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。 配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br> 2     ...<br> 3     <span class="hljs-comment">&lt;!--配置远程仓库认证信息--&gt;</span><br> 4     <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br> 5         <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br> 6             <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br> 7             <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br> 8             <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br> 9         <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>10     <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br>11     ...<br>12 <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p>
<h4 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h4><p>我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。 Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>public<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/releases<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>看代码，从命名上就看的出来区别，repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。</p>
<p>配置好了就运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。 当前项目是快照还是发布版本是通过 true 这个来区分的。忘记的同学在看看上面的## 远程仓库的配置。</p>
<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。用过Maven的都知道，国外的中央仓库用起来太慢了，所以选择一个国内的镜像就很有必要，我推荐国内的阿里云镜像。 阿里云镜像：配置很简单，修改conf文件夹下的settings.xml文件，添加如下镜像配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上例子中，的值为central,表示该配置为中央库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以用同样的方法配置其他仓库的镜像</p>
<p>这里介绍下``配置的各种选项</p>
<ul>
<li><code>*</code>:匹配所有远程仓库。</li>
<li><code>external:*</code>:匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。</li>
<li><code>repo1,repo2</code>:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。</li>
<li><code>*,!repo1</code>:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</li>
</ul>
<p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。</p>
<h2 id="仓库服务搜索"><a href="#仓库服务搜索" class="headerlink" title="仓库服务搜索"></a>仓库服务搜索</h2><p>这里介绍2个提供仓库服务搜索的地址：</p>
<ul>
<li>Sonatype Nexus：<a href="https://repository.sonatype.org/">repository.sonatype.org/</a></li>
<li>MVNrepository：<a href="http://mvnrepository.com/">mvnrepository.com/</a></li>
</ul>
</blockquote>
<h3 id="第3章-目录结构"><a href="#第3章-目录结构" class="headerlink" title="第3章 目录结构"></a>第3章 目录结构</h3><blockquote>
<p>maven提供了一个标准</p>
<p>1、核心代码目录：src/main/java</p>
<p>2、核心配置目录：src/main/resources</p>
<p>3、测试代码目录：src/test/java</p>
<p>4、测试配置目录：src/test/resources</p>
<p>5、其他目录：根据模板不同，会有对应的目录</p>
</blockquote>
<h3 id="第4章-常用命令"><a href="#第4章-常用命令" class="headerlink" title="第4章 常用命令"></a>第4章 常用命令</h3><blockquote>
<p>maven有一套管理项目结构的命令，每一个命令都是一个插件</p>
<ul>
<li><strong>mvn clean</strong>：表示运行清理操作（会默认把target文件夹中的数据清理）。</li>
<li><strong>mvn clean compile</strong>：表示先运行清理之后运行编译，会将代码编译到target文件夹中。</li>
<li><strong>mvn clean test</strong>：运行清理和测试。</li>
<li><strong>mvn clean package</strong>：运行清理和打包。</li>
<li><strong>mvn clean install</strong>：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。</li>
<li><strong>mvn clean deploy</strong>：运行清理和发布（发布到私服上面）。</li>
</ul>
</blockquote>
<h3 id="第5章-生命周期"><a href="#第5章-生命周期" class="headerlink" title="第5章 生命周期"></a>第5章 生命周期</h3><blockquote>
<p>maven有三套生命周期</p>
<p>1、“清理生命周期”：<strong>clean</strong>【项目运行之前需要清除项目之前编译的代码】</p>
<p>2、“默认生命周期”：<strong>编译compile、测试test、打包package、安装install、发布deploy</strong>【一个项目编译到发布的过程】</p>
<p>3、“站点生命周期”：【使用较少，暂不介绍】</p>
</blockquote>
<h3 id="第6章-依赖范围"><a href="#第6章-依赖范围" class="headerlink" title="第6章 依赖范围"></a>第6章 依赖范围</h3><h4 id="1、依赖范围"><a href="#1、依赖范围" class="headerlink" title="1、依赖范围"></a>1、依赖范围</h4><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p>
<ul>
<li>**compile:**编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li>
<li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。<ul>
<li>如junit</li>
</ul>
</li>
<li>**provided:**已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。<ul>
<li>如servlet-api</li>
</ul>
</li>
<li>**runtime:**运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。<ul>
<li>JDBC驱动实现</li>
</ul>
</li>
<li>**system(一般不用):**系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;dependency&gt;</span><br>    <span class="hljs-params">&lt;groupId&gt;</span>javax.sql<span class="hljs-params">&lt;/groupId&gt;</span><br>    <span class="hljs-params">&lt;artifactId&gt;</span>jdbc-stdext<span class="hljs-params">&lt;/artifactId&gt;</span><br>    <span class="hljs-params">&lt;Version&gt;</span><span class="hljs-number">2.0</span><span class="hljs-params">&lt;/Version&gt;</span><br>    <span class="hljs-params">&lt;scope&gt;</span>system<span class="hljs-params">&lt;/scope&gt;</span><br>    <span class="hljs-params">&lt;systemPath&gt;</span>$&#123;java.home&#125;<span class="hljs-meta-keyword">/lib/</span>rt.jar<span class="hljs-params">&lt;/systemPath&gt;</span><br><span class="hljs-params">&lt;/dependency&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>**import:**导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。 上述除import以外的各种依赖范围与三种classpath的关系如下:</li>
</ul>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fceaaf09e1" alt="image.png"></p>
<h4 id="2、传递性依赖"><a href="#2、传递性依赖" class="headerlink" title="2、传递性依赖"></a>2、传递性依赖</h4><p>比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</p>
<p><img src="images/Maven%E5%9F%BA%E7%A1%80/160b27fcea58b801" alt="image.png"></p>
<p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p>
<h4 id="3、依赖范围"><a href="#3、依赖范围" class="headerlink" title="3、依赖范围"></a>3、依赖范围</h4><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fceba81e2b" alt="image.png"></p>
<p>从上图中，我们可以发现这样的规律：</p>
<ul>
<li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li>
<li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li>
<li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li>
<li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li>
</ul>
<p>## 依赖调解 有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： 1. 路径最近者优先 比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用 2. 第一声明者优先 如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。</p>
<p>## 可选依赖</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fcf227ae4b" alt="image.png"></p>
<p>如图，项目中A依赖B，B依赖于X和Y，如果所有这三个的范围都是compile的话，那么X和Y就是A的compile范围的传递性依赖，但是如果我想X,Y不作为A的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>project-b<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4-701.jdbc3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>  <br>复制代码<br></code></pre></td></tr></table></figure>

<p>配置也简单，在依赖里面添加</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf">&lt;<span class="hljs-keyword">optional</span>&gt;<span class="hljs-literal">true</span>&lt;/<span class="hljs-keyword">optional</span>&gt;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>就表示可选依赖了，这样A如果想用X,Y就要直接显示的添加依赖了。</p>
<h4 id="4、排除依赖"><a href="#4、排除依赖" class="headerlink" title="4、排除依赖"></a>4、排除依赖</h4><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fd18cdd481-1619446521207" alt="image.png"></p>
<p>排除依赖代码结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里注意：声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p>
<h4 id="5、归类依赖"><a href="#5、归类依赖" class="headerlink" title="5、归类依赖"></a>5、归类依赖</h4><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.juven.mvnbook.account<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>accout-email<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">springframework.version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">springframework.version</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;springframework.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;springframework.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>         </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>  </span><br><span class="xml">复制代码</span><br></code></pre></td></tr></table></figure>

<p>如图所示，先通过</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    这里定义你先要的版本<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>来定义，然后在下面依赖使用${}来引入你的属性。</p>
<h3 id="第7章-概念模型"><a href="#第7章-概念模型" class="headerlink" title="第7章 概念模型"></a>第7章 概念模型</h3><blockquote>
<p>主要体现了maven的两个核心功能：依赖管理和一键构建</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466410783-299b3b90-ad1b-4fdc-a1b6-07cd6b29ed3c.png" alt="image.png"></p>
<h3 id="第八章-操作与配置"><a href="#第八章-操作与配置" class="headerlink" title="第八章 操作与配置"></a>第八章 操作与配置</h3><h4 id="1、maven安装"><a href="#1、maven安装" class="headerlink" title="1、maven安装"></a>1、maven安装</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462182612-6397eebc-d9fc-453a-83f6-008e9591283c.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462225732-31ad500f-fb32-42cd-801c-b0e02d2cf144.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462268785-a923fa75-c203-4e3d-a22f-a2386f91bcb6.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462285129-e3ed8555-b980-4cd7-8599-947485113265.png" alt="image.png"></p>
<h4 id="2、仓库配置-amp-setting-xml文件"><a href="#2、仓库配置-amp-setting-xml文件" class="headerlink" title="2、仓库配置 &amp; setting.xml文件"></a>2、仓库配置 &amp; setting.xml文件</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462361920-266edf79-89fc-4e33-aacc-b1b5be2da8ba.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/xml/750382/1609464260726-beb0d377-68de-4ffc-ab3a-2c3a52ab5949.xml">📎settings.xml</a></p>
<h4 id="3、IDEA配置"><a href="#3、IDEA配置" class="headerlink" title="3、IDEA配置"></a>3、IDEA配置</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466705287-1af47c0b-5708-40da-85be-874cc512cec7.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466912056-d8d0b3ae-b232-4084-8d39-72347b650975.png" alt="image.png"></p>
<blockquote>
<p>-DarchetypeCatalog=internal</p>
</blockquote>
<h4 id="4、使用骨架"><a href="#4、使用骨架" class="headerlink" title="4、使用骨架"></a>4、使用骨架</h4><p><strong>java项目</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467443774-5e9900d5-e637-41db-94be-aab3bdbdc914.png" alt="image.png"><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467486838-0d400c17-c277-4fc9-9841-7d7ce9ee2a5e.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467542090-ece21f56-3f99-47a6-b2a3-bdb7d2b9f320.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467654697-b00b971a-d8a6-44b8-a114-2bd498b00abe.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467871986-d0fe715c-cf2a-426a-bc5f-3fff93bac6f6.png" alt="image.png"></p>
<p><strong>web项目</strong></p>
<p><strong><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590468187810-f81dbde9-08ef-4f79-997a-d305e7890d9b.png" alt="image.png"></strong></p>
<p><strong><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590468358025-bb3a1c33-260f-4c0c-b2fd-873fddb324c9.png" alt="image.png"></strong></p>
<h4 id="5、不用骨架"><a href="#5、不用骨架" class="headerlink" title="5、不用骨架"></a>5、不用骨架</h4><blockquote>
<p>开发中推荐不使用骨架创建maven项目</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467973315-85ef6c32-c7ab-47a3-94b0-27a0dd27dd53.png" alt="image.png"></p>
<h4 id="6、多模块管理：方式1"><a href="#6、多模块管理：方式1" class="headerlink" title="6、多模块管理：方式1"></a>6、多模块管理：方式1</h4><blockquote>
<p>大型项目project需要分模块mudule管理。以下是maven多模块管理的测试案例一。</p>
</blockquote>
<p><strong>（1）创建空项目（project）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744621039-2e8fd5e2-70d9-4880-a290-6ca4652297b5.png" alt="image.png"></p>
<p><strong>（2）创建paren****t模块（module）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744752201-fe09ddcc-67e1-4e16-aaae-fa3440702e63.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744850509-037a4ba6-f30b-4467-96ba-933b8437ee2f.png" alt="image.png"></p>
<p><strong>（3）创建ch****ild模块（mudule）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744893708-6e3bed66-ebe4-4138-9789-bdf4271c7277.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744918528-93624370-9c21-42cf-9293-7e4050775cef.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745061897-63a2b568-73ce-4ab3-adbe-e2504a38cc14.png" alt="image.png"></p>
<p><strong>（4）统一管****理依赖</strong></p>
<blockquote>
<p>1、父类中的依赖子类会无条件继承</p>
<p>2、使用dependencyManagement标签强制管理依赖</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745134361-ecda36e4-4528-4e17-8815-04c8d37fc078.png" alt="image.png"></p>
<p><strong>（5）获取指****定依赖</strong></p>
<blockquote>
<p>子模块声明需要继承的依赖，不用写version</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745283460-b8ab6dfc-23ba-4235-9687-1fb36aeba9ee.png" alt="image.png"></p>
<p><strong>（6）管理版本号</strong></p>
<blockquote>
<p>maven管理依赖最终的目的就是管理版本号，parent一改全部跟着改</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745187888-4f933ec9-48b9-4a77-b2cb-1855a3e529f2.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2020/xml/750382/1590745410720-dc2842ca-6b78-4c46-b156-591d6119cac4.xml">📎pom.xml</a>（parent的pom.xml文件）</p>
<p><strong>（7）项目结构</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746288219-b3ab1a2a-8adc-4b47-8223-81f2cfdeb5a5.png" alt="image.png"></p>
<h4 id="7、多模块管理：方式2"><a href="#7、多模块管理：方式2" class="headerlink" title="7、多模块管理：方式2"></a>7、多模块管理：方式2</h4><p><strong>（1）创建parent工程</strong></p>
<p>创建好之后同样需要删除src目录，添加packing标签，标签值为pom</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746056958-f17afa18-86db-4684-b6d2-44f98a76e4f4.png" alt="image.png"></p>
<p><strong>（2）创建child工程</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746185786-17c31fc8-2821-4648-9f72-0d47a5496cb7.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746228805-df6561db-9e86-4446-ae94-2527760dfa8b.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746715532-3023502e-2a4f-4948-9af2-21e34fd90ba7.png" alt="image.png"></p>
<p><strong>其他操作，如管理依赖、管理版本号、继承指定版本号这些和方式1一致</strong></p>
<h4 id="8、调整java编译器版本"><a href="#8、调整java编译器版本" class="headerlink" title="8、调整java编译器版本"></a>8、调整java编译器版本</h4><blockquote>
<p>方式1：IDEA设置；当pom文件变化时，jdk版本还是会变成1.5</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590747249475-9d775676-a758-42d6-b546-0c2fafd84c4a.png" alt="image.png"></p>
<blockquote>
<p>方式2：在pom文件配置jdk编译插件的版本，这样，当pom文件引入新的依赖，也不会改变jdk的版本</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- jdk1.8编译插件 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>方案3：和方案2一样的效果</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="第九章-转载：Maven中的profile标签"><a href="#第九章-转载：Maven中的profile标签" class="headerlink" title="第九章 转载：Maven中的profile标签"></a>第九章 转载：Maven中的profile标签</h3><p>原文连接：<a href="https://juejin.cn/post/6844903653782863879#heading-0">Maven根据pom文件中的Profile标签动态配置编译选项</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  在实际项目开发中，我们需要<strong>根据不同的使用场景，构建不同的程序包</strong>。当使用Maven编译时，我们可以通过Maven的profile标签来配置编译选项，从而达到生成不同构建产物的目的。例如，在开发环境下，我们有一套适用于本机的调试配置；而在生产环境下，又需要关闭调试环境时的大量调试日志，或变更日志保存路径等。这些需求都可以通过Maven的Profile标签配置来解决。</p>
<p>  profile可以让我们定义一系列的配置信息，然后指定其激活条件。由此，我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到<strong>不同环境使用不同配置信息</strong>的效果。比如说，我们可以通过profile定义在jdk1.5以上使用一套配置信息，在jdk1.5以下使用另外一套配置信息；或者有时候我们可以通过操作系统的不同来使用不同的配置信息，比如windows下是一套信息，linux下又是另外一套信息，等等。</p>
<h4 id="1、profile属性的定义位置"><a href="#1、profile属性的定义位置" class="headerlink" title="1、profile属性的定义位置"></a>1、profile属性的定义位置</h4><p>  我们有多个可选位置来定义profile。定义的地方不同，它的作用范围也不同。</p>
<ul>
<li><strong>针对于特定项目的profile配置</strong>我们可以定义在该项目的pom.xml中。</li>
<li><strong>针对于特定用户的profile配置</strong>，我们可以在用户的settings.xml文件中定义profile。该文件在用户家目录下的“.m2”目录下。</li>
<li><strong>全局的profile配置</strong>。全局的profile是定义在Maven安装目录下的“conf/settings.xml”文件中的。</li>
</ul>
<h4 id="2、profile中能定义的信息"><a href="#2、profile中能定义的信息" class="headerlink" title="2、profile中能定义的信息"></a>2、profile中能定义的信息</h4><p>  profile中能够定义的配置信息跟profile所处的位置是相关的。以下就分两种情况来讨论，一种是定义在<strong>settings.xml</strong>中，另一种是定义在<strong>pom.xml</strong>中。</p>
<h4 id="3、profile定义在settings-xml中"><a href="#3、profile定义在settings-xml中" class="headerlink" title="3、profile定义在settings.xml中"></a>3、profile定义在settings.xml中</h4><p>  当profile定义在settings.xml中时意味着该profile是全局的，它会对所有项目或者某一用户的所有项目都产生作用。也正因为它是全局的，<strong>所以在settings.xml中只能定义一些相对而言范围宽泛一点的配置信息</strong>，<strong>比如远程仓库等</strong>。而一些比较细致一点的需要根据项目的不同来定义的就需要定义在项目的pom.xml中。具体而言，能够定义在settings.xml中的信息有：</p>
<ul>
<li><hr>
</li>
<li><hr>
</li>
<li><hr>
</li>
<li><p>定义在<properties>里面的键值对可以在pom.xml中使用。</properties></p>
</li>
</ul>
<h4 id="4、profile定义在pom-xml中"><a href="#4、profile定义在pom-xml中" class="headerlink" title="4、profile定义在pom.xml中"></a>4、profile定义在pom.xml中</h4><p>定义在pom.xml中的profile可以定义更多的信息。主要有以下这些：</p>
<ul>
<li><repositories></repositories></li>
<li><pluginRepositories></pluginRepositories></li>
<li><dependencies></dependencies></li>
<li><plugins></plugins></li>
<li><properties></properties></li>
<li><dependencyManagement></dependencyManagement></li>
<li><distributionManagement></distributionManagement></li>
</ul>
<p>还有build元素下面的子元素，主要包括：</p>
<ul>
<li><defaultGoal></defaultGoal></li>
<li><resources></resources></li>
<li><testResources></testResources></li>
<li><finalName></finalName></li>
</ul>
<h4 id="5、profile标签配置的激活方式"><a href="#5、profile标签配置的激活方式" class="headerlink" title="5、profile标签配置的激活方式"></a>5、profile标签配置的激活方式</h4><p>  Maven给我们提供了多种不同的profile激活方式。比如我们可以使用-P参数在编译时，显示的激活一个profile，也可以根据环境条件的设置让它自动激活等。</p>
<h4 id="6、使用activeByDefault设置默认激活（定义在pom文件中）"><a href="#6、使用activeByDefault设置默认激活（定义在pom文件中）" class="headerlink" title="6、使用activeByDefault设置默认激活（定义在pom文件中）"></a>6、使用activeByDefault设置默认激活（定义在pom文件中）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以在profile下的activation标签中，通过activeByDefault标签配置激活状态，当没有在编译命令中配置任何激活条件时，activeByDefault标签在哪个profile下配置为true的时候，就表示<strong>该profile在编译时默认会被激活</strong>。</p>
<h4 id="7、在settings-xml中使用activeProfiles指定处于激活状态的profile"><a href="#7、在settings-xml中使用activeProfiles指定处于激活状态的profile" class="headerlink" title="7、在settings.xml中使用activeProfiles指定处于激活状态的profile"></a>7、在settings.xml中使用activeProfiles指定处于激活状态的profile</h4><p>  我们可以在settings.xml中使用activeProfiles来指定需要激活的profile，这种方式激活的profile将所有情况下都处于激活状态。比如现在我们定义了如下两个profile：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里的profile可以是定义在settings.xml中的，也可以是定义在pom.xml中的。当这时需要指定dev为激活状态，那么我们就可以在settings.xml中定义activeProfiles,如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span> <br></code></pre></td></tr></table></figure>

<p>考虑这样一种情况，我们在activeProfiles下同时定义了多个需要激活的profile。这里还拿上面的profile定义来举例，我们定义了同时激活dev和release。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么这个时候我在pom.xml中使用属性properties.active的时候，它是根据profile定义的先后顺序来进行覆盖取值的，即<strong>后面定义的会覆盖前面定义的（定义仓库的时候也是如此）</strong>。</p>
<h4 id="8、使用-P参数显示的激活一个profile"><a href="#8、使用-P参数显示的激活一个profile" class="headerlink" title="8、使用-P参数显示的激活一个profile"></a>8、使用-P参数显示的激活一个profile</h4><p>  我们在进行Maven操作时可以使用-P参数显示的指定当前激活的是哪一个profile。比如我们需要在对项目进行打包的时候使用id为dev的profile，我们就可以这样做：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">-P dev</span><br></code></pre></td></tr></table></figure>

<p>  假如我们使用activeByDefault或settings.xml中定义了处于激活的profile，但是当我们在进行某些操作的时候又不想它处于激活状态，这个时候我们可以这样做：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">–P !dev </span><br></code></pre></td></tr></table></figure>

<p>  这里假设dev是在settings.xml中使用activeProfile标记的处于激活状态的profile，那么当我们使用“-P !dev”的时候就表示在当前操作中该profile将不处于激活状态。</p>
<h4 id="9、根据编译环境来激活profile"><a href="#9、根据编译环境来激活profile" class="headerlink" title="9、根据编译环境来激活profile"></a>9、根据编译环境来激活profile</h4><p>  profile一个非常重要的特性就是它可以根据不同的编译环境来激活，比如说根据操作系统的不同激活不同的profile，也可以根据jdk版本的不同激活不同的profile，等等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>profileTest1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="第十章-举例-基于Springboot下的log4j2实践配置步骤"><a href="#第十章-举例-基于Springboot下的log4j2实践配置步骤" class="headerlink" title="第十章 举例-基于Springboot下的log4j2实践配置步骤"></a>第十章 举例-基于Springboot下的log4j2实践配置步骤</h3><p>我们以配置log4j2为例来说一说开发环境和生产环境的不同设置。</p>
<h4 id="一、在src-main-resources-下新建config目录，并在其中创建dev和release文件夹"><a href="#一、在src-main-resources-下新建config目录，并在其中创建dev和release文件夹" class="headerlink" title="一、在src/main/resources/下新建config目录，并在其中创建dev和release文件夹"></a>一、在src/main/resources/下新建config目录，并在其中创建dev和release文件夹</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a77d684d8ca9" alt="image"></p>
<h4 id="二、分别编写两个不同环境下的log4j2配置文件"><a href="#二、分别编写两个不同环境下的log4j2配置文件" class="headerlink" title="二、分别编写两个不同环境下的log4j2配置文件"></a>二、分别编写两个不同环境下的log4j2配置文件</h4><p>这两个配置文件的主要区别在于，其中的日志保存路径是不同的。（此处只是为了演示区别，随意对路径进行了配置，可自己配置所需路径） 调试用的log4j2-spring.xml:</p>
<p><img src="images/Maven%E5%9F%BA%E7%A1%80/1651a78a8e845989" alt="image">正式环境下的log4j2-spring.xml:<img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a78d9964ae46" alt="image">并分别将刚才的两个文件放置到对应的目录中。</p>
<h4 id="三、配置POM文件"><a href="#三、配置POM文件" class="headerlink" title="三、配置POM文件"></a>三、配置POM文件</h4><p>在项目的pom.xml文件中，在其根节点project下，增加profiles标签：</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a79ba34cccb9" alt="image"></p>
<p>其中：</p>
<ul>
<li><profile>标签表明当前为一个profile描述体</profile></li>
<li><id>标签表明当前profile的id，用来区分不同的profile</id></li>
<li><properties>标签中，可以自定义K、V值，这里的标签名任意，在项目的properties或xml等配置文件中可以使用${profiles.active}可以取出”dev”或“release”这个值</properties></li>
</ul>
<p>在项目的pom.xml文件中，在其build节点下，增加resource标签：</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a79f2eccddf6-1619449703012" alt="image"></p>
<p>其中：</p>
<ul>
<li><directory>表示编译所需的资源目录</directory></li>
<li><excludes>标签表示排除掉资源目录下的某文件或文件夹</excludes></li>
<li><targetPath>表示该资源标签下的资源打包编译后的保存路径，“.”表示当前路径 由此可见，我们将路径src/main/resources/config/${profiles.active}配置上了我们在profile中定义的Key值，这样，当我们通过-P参数来激活配置时，就可以引入对应的配置文件了。</targetPath></li>
</ul>
<h4 id="四、编译"><a href="#四、编译" class="headerlink" title="四、编译"></a>四、编译</h4><p>通过执行下面的命令进行编译：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">-P dev</span><br></code></pre></td></tr></table></figure>

<p>激活了dev编译条件。编译生成war或jar文件后，可以解压构建包，确认配置文件被打包到构建包的根目录下。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring02-扫描bean定义的过程</title>
    <url>/2021/06/16/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>一、讲前扩展</p>
<p>​    1、源码扩展之事件监听机制</p>
<p>​    2、源码扩展之BeanFactoryPostProcessor</p>
<p>二、Spring扫描bean定义的源码分析</p>
<h1 id="讲前拓展"><a href="#讲前拓展" class="headerlink" title="讲前拓展"></a>讲前拓展</h1><h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><p>概述：本质上是观察者模式程序设计的体现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;收到事件:&quot;</span>+event);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/image-20210617231054221.png" alt="image-20210617231054221"></p>
<ul>
<li>i1&gt;org.springframework.context.support.AbstractApplicationContext#refresh<ul>
<li>i2&gt;org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster（初始化事件多播器）<ul>
<li>i3&gt;org.springframework.context.support.AbstractApplicationContext#registerListeners（把事件监听器注册到多播器上去）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>i2(初始化事件多播器源码解析)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationEventMulticaster</span><span class="hljs-params">()</span> </span>&#123;<br>		ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>		/判断IOC容器中包含applicationEventMulticaster 事件多播器的Bean的name<br>		<span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;<br>		    /创建一个applicationEventMulticaster的bean放在IOC 容器中,bean的name 为applicationEventMulticaster<br>			<span class="hljs-keyword">this</span>.applicationEventMulticaster =beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);<br>			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>				logger.debug(<span class="hljs-string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>		&#125;<br>		/容器中不包含一个beanName 为applicationEventMulticaster的多播器组件<br>		<span class="hljs-keyword">else</span> &#123;<br>		    <span class="hljs-comment">//创建一个SimpleApplicationEventMulticaster 多播器</span><br>			<span class="hljs-keyword">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);<br>			<span class="hljs-comment">//注册到容器中</span><br>			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="hljs-keyword">this</span>.applicationEventMulticaster);<br>			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>				logger.debug(<span class="hljs-string">&quot;Unable to locate ApplicationEventMulticaster with name &#x27;&quot;</span> +<br>						APPLICATION_EVENT_MULTICASTER_BEAN_NAME +<br>						<span class="hljs-string">&quot;&#x27;: using default [&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>		&#125;<br>	&#125;​<br></code></pre></td></tr></table></figure>

<p><strong>i3：把容器中的监听器注册到多播器上去 源码解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListeners</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//去容器中把applicationListener 捞取出来注册到多播器上去（系统的）</span><br>		<span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;<br>			getApplicationEventMulticaster().addApplicationListener(listener);<br>		&#125;<br><br>        <span class="hljs-comment">//我们自己实现了ApplicationListener 的组件</span><br>		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>		<span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;<br>			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br>		&#125;<br><br>	    <span class="hljs-comment">//在这里之前，我们早期想发布的事件 由于没有多播器没有发布，在这里我们总算有了自己的多播器，可以在这里发布早期堆积的事件了.</span><br>		Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-keyword">this</span>.earlyApplicationEvents;<br>		<span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">if</span> (earlyEventsToProcess != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>				getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	------------------------------------如何发布事件-------------------------------------<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;<br>		ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>		<span class="hljs-comment">//获取到所有的监听器</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br>		    <span class="hljs-comment">//看spring 容器中是否支持线程池 异步发送事件</span><br>			Executor executor = getTaskExecutor();<br>			<span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>				executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>					<span class="hljs-meta">@Override</span><br>					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;	    <br>						invokeListener(listener, event);<br>					&#125;<br>				&#125;);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//同步发送事件</span><br>				invokeListener(listener, event);<br>			&#125;<br>		&#125;<br>	&#125;	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvokeListener</span><span class="hljs-params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//调用对于listener的onApplicationEvent事件</span><br>			listener.onApplicationEvent(event);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassCastException ex) &#123;<br>			String msg = ex.getMessage();<br>			<span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;<br>				<span class="hljs-comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span><br>				<span class="hljs-comment">// -&gt; let&#x27;s suppress the exception and just log a debug message.</span><br>				Log logger = LogFactory.getLog(getClass());<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					logger.debug(<span class="hljs-string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> ex;<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如何定制事件多波器并且在线程池中执行？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;applicationEventMulticaster&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationEventMulticaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleApplicationEventMulticaster</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyApplicationEventMulticaster</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(beanFactory);<br>        setTaskExecutor(<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>,<br>                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                Executors.defaultThreadFactory()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>分两种</p>
<ol>
<li>BeanFactoryPostProcessor bean定义信息加载完毕，初始化前<ol>
<li>可以对某些bean定义信息做一些特殊配置</li>
</ol>
</li>
<li>MyBeanDefinitionRegistryPostProcessor Spring内置bean定义信息加载后，初始化前<ol>
<li>可以新增、删除bean定义信息等操作</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-comment">//(spring内置BeanDefinition读取后),bean初始化前，做一些新增beanDefinition等操作</span><br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor....postProcessBeanDefinitionRegistry&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;bean 的数量&quot;</span> + registry.getBeanDefinitionCount());<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;tooth&quot;</span>,<span class="hljs-keyword">new</span> RootBeanDefinition(TestController.class));<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-comment">//BeanDefinition读取之后，bean初始化前</span><br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor postProcessBeanFactory....bean 的数量&quot;</span> + beanFactory.getBeanDefinitionCount());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>i1:org.springframework.context.support.AbstractApplicationContext#refresh<ul>
<li>i2:org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors<ul>
<li>&gt;i3:org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors<ul>
<li>&gt;i4:org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors<ul>
<li>&gt;i5:org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions<ul>
<li>&gt; i6:org.springframework.context.annotation.ConfigurationClassParser#parse<ul>
<li>&gt;i7:org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass<ul>
<li>&gt;i8:org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="i4标记处源码解析"><a href="#i4标记处源码解析" class="headerlink" title="i4标记处源码解析"></a>i4标记处源码解析</h3><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;<br><br>		<span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br>		Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>        <br>        <span class="hljs-comment">//判断IOC 容器是不是BeanDefinitionRegistry的？</span><br>		<span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;<br>		    <span class="hljs-comment">//把IOC容器 强制转为BeanDefinitionRegistry类型的</span><br>			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;<br>			<span class="hljs-comment">//创建一个普通的PostProcessors的list的组件</span><br>			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();<br>			<span class="hljs-comment">//创建一个BeanDefinitionRegistryPostProcessor类型的list</span><br>			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();<br>            <br>            <span class="hljs-comment">//处理容器硬编码(new 出来的)带入的beanFacotryPostProcessors</span><br>			<span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br>			    <span class="hljs-comment">//判断是不是BeanDefinitionRegistryPostProcessor</span><br>				<span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;<br>				    <br>					BeanDefinitionRegistryPostProcessor registryProcessor =<br>							(BeanDefinitionRegistryPostProcessor) postProcessor;<br>					<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry</span><br>					registryProcessor.postProcessBeanDefinitionRegistry(registry);<br>					<span class="hljs-comment">//加入到list集合中</span><br>					registryProcessors.add(registryProcessor);<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//判断不是BeanDefinitionRegistryPostProcessor</span><br>				    <span class="hljs-comment">//加入到集合中</span><br>					regularPostProcessors.add(postProcessor);<br>				&#125;<br>			&#125;<br><br>            <span class="hljs-comment">//创建一个当前注册的RegistryProcessors的集合</span><br>			List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();<br><br>			第一步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的<br>			String[] postProcessorNames =<br>					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>			<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			    <span class="hljs-comment">//判断是不是实现了PriorityOrdered接口的</span><br>				<span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>				    <span class="hljs-comment">//添加到currentRegistryProcessors的集合中</span><br>					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>					<span class="hljs-comment">//添加到processedBeans的集合中</span><br>					processedBeans.add(ppName);<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">//进行排序</span><br>			sortPostProcessors(currentRegistryProcessors, beanFactory);<br>			registryProcessors.addAll(currentRegistryProcessors);<br>			<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法</span><br>			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>			currentRegistryProcessors.clear();<br><br>			<span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br>			第二步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的<br>			<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			    <span class="hljs-comment">//排除被处理过的，并且实现了Ordered接口的</span><br>				<span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>					<span class="hljs-comment">//加到以处理的list中</span><br>					processedBeans.add(ppName);<br>				&#125;<br>			&#125;<br>			sortPostProcessors(currentRegistryProcessors, beanFactory);<br>			registryProcessors.addAll(currentRegistryProcessors);<br>			<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法</span><br>			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>			currentRegistryProcessors.clear();<br><br>			<span class="hljs-comment">//调用普通的BeanDefinitionRegistryPostProcessors没用实现 PriorithOrdered和Ordered接口</span><br>			<span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;<br>			<span class="hljs-keyword">while</span> (reiterate) &#123;<br>				reiterate = <span class="hljs-keyword">false</span>;<br>				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>				<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>					<span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br>						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>						processedBeans.add(ppName);<br>						reiterate = <span class="hljs-keyword">true</span>;<br>					&#125;<br>				&#125;<br>				sortPostProcessors(currentRegistryProcessors, beanFactory);<br>				registryProcessors.addAll(currentRegistryProcessors);<br>				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>				currentRegistryProcessors.clear();<br>			&#125;<br><br>			<span class="hljs-comment">//调用上诉实现了也实现了BeanFactoryPostProcessors的接口</span><br>			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br>			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>		&#125;<br><br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br>			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>		&#125;<br><br>        <span class="hljs-comment">//去IOC 容器中获取BeanFactoryPostProcessor 类型的</span><br>		String[] postProcessorNames =<br>				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">//分离实现了PriorityOrdered接口的 Ordered 接口的   普通的</span><br>		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		<br>		<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			<span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br>				<span class="hljs-comment">// skip - already processed in first phase above</span><br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>				orderedPostProcessorNames.add(ppName);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				nonOrderedPostProcessorNames.add(ppName);<br>			&#125;<br>		&#125;<br><br>		调用 PriorityOrdered.<br>		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br>		<span class="hljs-comment">//调用 Ordered.</span><br>		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		<span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br>			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>		&#125;<br>		sortPostProcessors(orderedPostProcessors, beanFactory);<br>		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br>	    <span class="hljs-comment">//调用普通的</span><br>		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		<span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br>			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>		&#125;<br>		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<br><br>		<span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br>		<span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br>		beanFactory.clearMetadataCache();<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="i5标记处源码解析"><a href="#i5标记处源码解析" class="headerlink" title="i5标记处源码解析:"></a>i5标记处源码解析:</h3><p>org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>		List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();<br>		<span class="hljs-comment">//去IOC容器中的获取Bean定义的名称</span><br>		<span class="hljs-comment">//	private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;String&gt;(256);</span><br>        <br>        <span class="hljs-comment">//没有解析之前，系统候选的bean定义配置(有自己的 有系统自带的)</span><br>		String[] candidateNames = registry.getBeanDefinitionNames();<br>        <br>        <span class="hljs-comment">//循环Bean定义的名称 找出自己的传入的主配置类的bean定义信息  configCandidates</span><br>		<span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;<br>		    <span class="hljs-comment">//去bean定义的map中获取对应的Bean定义对象</span><br>		    <span class="hljs-comment">//	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(256);</span><br>			BeanDefinition beanDef = registry.getBeanDefinition(beanName);<br>			<span class="hljs-comment">//检查该bean定义对象是不是用来描述配置类</span><br>			<span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||<br>					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Return immediately if no @Configuration classes were found</span><br>		<span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		<span class="hljs-comment">//检查配置类排序</span><br>		Collections.sort(configCandidates, <span class="hljs-keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;<br>				<span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());<br>				<span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());<br>				<span class="hljs-keyword">return</span> (i1 &lt; i2) ? -<span class="hljs-number">1</span> : (i1 &gt; i2) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;);<br><br>		<span class="hljs-comment">// bean的名称生成策略</span><br>		SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) &#123;<br>			sbr = (SingletonBeanRegistry) registry;<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;<br>				BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);<br>				<span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;<br>				<span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">/***创建一个配置类解析器</span><br><span class="hljs-comment">		1)元数据读取器工厂</span><br><span class="hljs-comment">		this.metadataReaderFactory = metadataReaderFactory;</span><br><span class="hljs-comment">		2)问题报告器</span><br><span class="hljs-comment">		this.problemReporter = problemReporter;</span><br><span class="hljs-comment">		//设置环境</span><br><span class="hljs-comment">		this.environment = environment;</span><br><span class="hljs-comment">		3)资源加载器</span><br><span class="hljs-comment">		this.resourceLoader = resourceLoader;</span><br><span class="hljs-comment">		4）创建了一个组件扫描器</span><br><span class="hljs-comment">		this.componentScanParser = new ComponentScanAnnotationParser(</span><br><span class="hljs-comment">				environment, resourceLoader, componentScanBeanNameGenerator, registry);</span><br><span class="hljs-comment">		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);</span><br><span class="hljs-comment">		****/</span><br>		<br>		ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<br>				<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,<br>				<span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);<br>        <br>        <br>        <span class="hljs-comment">//将要被解析的配置类(把自己的configCandidates加入到 候选的)</span><br>		Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);<br>		<span class="hljs-comment">//已经被解析的配置类(由于do while 那么mainclass就一定会被解析,被解析的size为1)</span><br>		Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());<br>		<span class="hljs-keyword">do</span> &#123;<br>		    <span class="hljs-comment">//通过配置解析器真正的解析配置类</span><br>			parser.parse(candidates);<br>			<br>			<span class="hljs-comment">//进行校验</span><br>			parser.validate();<br>            <br>            <span class="hljs-comment">//获取ConfigClass (把解析过的配置bean定义信息获取出来)</span><br>			Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());<br>			configClasses.removeAll(alreadyParsed);<br><br>			<span class="hljs-comment">// Read the model and create bean definitions based on its content</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(<br>						registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,<br>						<span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());<br>			&#125;<br>			<br>			<span class="hljs-comment">//@CompentScan是直接注册Bean定义信息的    但是通过获取@Import,@Bean这种的注解还没有注册的bean定义,</span><br>			<span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);<br>			<span class="hljs-comment">//把系统解析过我们自己的组件放在alreadyParsed</span><br>			alreadyParsed.addAll(configClasses);<br>            <span class="hljs-comment">//清除解析过的 配置文件 </span><br>			candidates.clear();<br>			<br>			<span class="hljs-comment">//已经注册的bean定义个数大于最新 开始系统+主配置类的(发生过解析)</span><br>			<span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;<br>			    <span class="hljs-comment">//获取系统+自己解析的+mainconfig的bean定义信息</span><br>				String[] newCandidateNames = registry.getBeanDefinitionNames();<br>				<span class="hljs-comment">//系统的+mainconfig的bean定义信息</span><br>				Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));<br>				<br>				<span class="hljs-comment">//已经解析过的自己的组件</span><br>				Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>				<span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;<br>					alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());<br>				&#125;<br>				<br>				<span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) &#123;<br>				    <span class="hljs-comment">//老的（系统+mainconfig） 不包含解析的</span><br>					<span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;<br>					    <span class="hljs-comment">//把当前bean定义获取出来</span><br>						BeanDefinition bd = registry.getBeanDefinition(candidateName);<br>						<span class="hljs-comment">//检查是否为解析过的</span><br>						<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;<br>								!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;<br>							<span class="hljs-comment">//若不是解析过且通过检查的     把当前的bean定义 加入到candidates中	    </span><br>							candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));<br>						&#125;<br>					&#125;<br>				&#125;<br>				把解析过的赋值给原来的 <br>				candidateNames = newCandidateNames;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (!candidates.isEmpty());  <span class="hljs-comment">//还存主没有解析过的  再次解析</span><br><br>		<span class="hljs-comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><br>		<span class="hljs-keyword">if</span> (sbr != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;<br>				sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.metadataReaderFactory <span class="hljs-keyword">instanceof</span> CachingMetadataReaderFactory) &#123;<br>			((CachingMetadataReaderFactory) <span class="hljs-keyword">this</span>.metadataReaderFactory).clearCache();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="i6标记处源码解析"><a href="#i6标记处源码解析" class="headerlink" title="i6标记处源码解析 :"></a>i6标记处源码解析 :</h3><p>org.springframework.context.annotation.ConfigurationClassParser#parse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.deferredImportSelectors = <span class="hljs-keyword">new</span> LinkedList&lt;DeferredImportSelectorHolder&gt;();<br><br>		<span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;<br>			BeanDefinition bd = holder.getBeanDefinition();<br>			<span class="hljs-keyword">try</span> &#123;<br>			    <span class="hljs-comment">//注解形式的bean定义信息</span><br>				<span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>				    <span class="hljs-comment">//解析配置类的bean定义</span><br>					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());<br>				&#125;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;<br>					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<br>					parse(bd.getBeanClassName(), holder.getBeanName());<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>				<span class="hljs-keyword">throw</span> ex;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>						<span class="hljs-string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>			&#125;<br>		&#125;<br><br>		processDeferredImportSelectors();<br>	&#125;​<br>	<br>	<br>org.springframework.context.annotation.ConfigurationClassParser#parse<br>	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		ConfigurationClass existingClass = <span class="hljs-keyword">this</span>.configurationClasses.get(configClass);<br>		<span class="hljs-keyword">if</span> (existingClass != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>				<span class="hljs-keyword">if</span> (existingClass.isImported()) &#123;<br>					existingClass.mergeImportedBy(configClass);<br>				&#125;<br>				<span class="hljs-comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span><br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">// Explicit bean definition found, probably replacing an import.</span><br>				<span class="hljs-comment">// Let&#x27;s remove the old one and go with the new one.</span><br>				<span class="hljs-keyword">this</span>.configurationClasses.remove(configClass);<br>				<span class="hljs-keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="hljs-keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;<br>					<span class="hljs-keyword">if</span> (configClass.equals(it.next())) &#123;<br>						it.remove();<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		递归处理配置类及其超类层次结构。<br>		SourceClass sourceClass = asSourceClass(configClass);<br>		<span class="hljs-keyword">do</span> &#123;<br>			sourceClass = doProcessConfigurationClass(configClass, sourceClass);<br>		&#125;<br>		<span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-keyword">null</span>);<br><br>		<span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);<br>	&#125;<br>	<br>	<br>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>		<span class="hljs-comment">// Recursively process any member (nested) classes first</span><br>		processMemberClasses(configClass, sourceClass);<br><br>		<span class="hljs-comment">//处理@PropertySource注解</span><br>		<span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(<br>				sourceClass.getMetadata(), PropertySources.class,<br>				org.springframework.context.annotation.PropertySource.class)) &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;<br>				processPropertySource(propertySource);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				logger.warn(<span class="hljs-string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +<br>						<span class="hljs-string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//处理@ComponentScan注解</span><br>		<br>		<span class="hljs-comment">//解析@ComponentScans注解的属性 封装成一个一个的componentscan对象</span><br>		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);<br>		<span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;<br>			<br>			<span class="hljs-comment">//循环componentScans的set</span><br>			<span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;<br>				<span class="hljs-comment">// 立即执行扫描解析</span><br>				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =<span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());<br>				<span class="hljs-comment">//检查任何其他配置类的扫描定义集，并在需要时递归解析</span><br>				<span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;<br>				    <span class="hljs-comment">//获取原始的bean定义信息</span><br>					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();<br>					<span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) &#123;<br>						bdCand = holder.getBeanDefinition();<br>					&#125;<br>					<span class="hljs-comment">//检查当前的bean定义信息是不是配置类  比如MainConfig的bean定义信息</span><br>					<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>					    <span class="hljs-comment">//递归调用来解析MainConfig,解析出来配置类的中导入的bean定义信息</span><br>						parse(bdCand.getBeanClassName(), holder.getBeanName());<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//处理@Import注解   解析Import 注解的ImportSelector  ImportBeanDefinitionRegister,@Bean这种</span><br>		<span class="hljs-comment">//存放在ConfigClass中</span><br>		processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);<br><br>		<span class="hljs-comment">//处理 @ImportResource annotations</span><br>		<span class="hljs-keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;<br>			AnnotationAttributes importResource =<br>					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);<br>			String[] resources = importResource.getStringArray(<span class="hljs-string">&quot;locations&quot;</span>);<br>			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="hljs-string">&quot;reader&quot;</span>);<br>			<span class="hljs-keyword">for</span> (String resource : resources) &#123;<br>				String resolvedResource = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(resource);<br>				configClass.addImportedResource(resolvedResource, readerClass);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// 处理  @Bean methods</span><br>		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);<br>		<span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;<br>			configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));<br>		&#125;<br><br>		<span class="hljs-comment">//处理接口</span><br>		processInterfaces(configClass, sourceClass);<br><br>		<span class="hljs-comment">// 处理超类的</span><br>		<span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;<br>			String superclass = sourceClass.getMetadata().getSuperClassName();<br>			<span class="hljs-keyword">if</span> (!superclass.startsWith(<span class="hljs-string">&quot;java&quot;</span>) &amp;&amp; !<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;<br>				<span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);<br>				<span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span><br>				<span class="hljs-keyword">return</span> sourceClass.getSuperClass();<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// No superclass -&gt; processing is complete</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>	<br><span class="hljs-comment">//通过组件扫描器进行真正的解析	</span><br>org.springframework.context.annotation.ComponentScanAnnotationParser#parse<br>Set&lt;BeanDefinitionHolder&gt;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationAttributes componentScan, <span class="hljs-keyword">final</span> String declaringClass)</span> </span>&#123;<br>		Assert.state(<span class="hljs-keyword">this</span>.environment != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Environment must not be null&quot;</span>);<br>		Assert.state(<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;ResourceLoader must not be null&quot;</span>);<br>        <br>        <span class="hljs-comment">//创建一个类路径下的bean定义扫描器</span><br>		ClassPathBeanDefinitionScanner scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>.registry,<br>				componentScan.getBoolean(<span class="hljs-string">&quot;useDefaultFilters&quot;</span>), <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader);<br>        <br>        <span class="hljs-comment">//为扫描器设置一个bean 名称的生成器</span><br>		Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(<span class="hljs-string">&quot;nameGenerator&quot;</span>);<br>		<span class="hljs-keyword">boolean</span> useInheritedGenerator = (BeanNameGenerator.class == generatorClass);<br>		scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="hljs-keyword">this</span>.beanNameGenerator :<br>				BeanUtils.instantiateClass(generatorClass));<br>        <br>        <br>		ScopedProxyMode scopedProxyMode = componentScan.getEnum(<span class="hljs-string">&quot;scopedProxy&quot;</span>);<br>		<span class="hljs-keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;<br>			scanner.setScopedProxyMode(scopedProxyMode);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(<span class="hljs-string">&quot;scopeResolver&quot;</span>);<br>			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));<br>		&#125;<br><br>		scanner.setResourcePattern(componentScan.getString(<span class="hljs-string">&quot;resourcePattern&quot;</span>));<br><br>		<span class="hljs-keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="hljs-string">&quot;includeFilters&quot;</span>)) &#123;<br>			<span class="hljs-keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;<br>				scanner.addIncludeFilter(typeFilter);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="hljs-string">&quot;excludeFilters&quot;</span>)) &#123;<br>			<span class="hljs-keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;<br>				scanner.addExcludeFilter(typeFilter);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">boolean</span> lazyInit = componentScan.getBoolean(<span class="hljs-string">&quot;lazyInit&quot;</span>);<br>		<span class="hljs-keyword">if</span> (lazyInit) &#123;<br>			scanner.getBeanDefinitionDefaults().setLazyInit(<span class="hljs-keyword">true</span>);<br>		&#125;<br><br>		Set&lt;String&gt; basePackages = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();<br>		String[] basePackagesArray = componentScan.getStringArray(<span class="hljs-string">&quot;basePackages&quot;</span>);<br>		<span class="hljs-keyword">for</span> (String pkg : basePackagesArray) &#123;<br>			String[] tokenized = StringUtils.tokenizeToStringArray(<span class="hljs-keyword">this</span>.environment.resolvePlaceholders(pkg),<br>					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);<br>			basePackages.addAll(Arrays.asList(tokenized));<br>		&#125;<br>		<span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)) &#123;<br>			basePackages.add(ClassUtils.getPackageName(clazz));<br>		&#125;<br>		<span class="hljs-keyword">if</span> (basePackages.isEmpty()) &#123;<br>			basePackages.add(ClassUtils.getPackageName(declaringClass));<br>		&#125;<br><br>		scanner.addExcludeFilter(<span class="hljs-keyword">new</span> AbstractTypeHierarchyTraversingFilter(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>) &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matchClassName</span><span class="hljs-params">(String className)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> declaringClass.equals(className);<br>			&#125;<br>		&#125;);<br>		<span class="hljs-comment">//真正扫描器扫描指定路径</span><br>		<span class="hljs-keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));<br>	&#125;<br><br><br><span class="hljs-comment">//创建类路径下的bean定义扫描器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-keyword">boolean</span> useDefaultFilters,</span></span><br><span class="hljs-function"><span class="hljs-params">			Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;<br><br>		Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>		<span class="hljs-keyword">this</span>.registry = registry;<br>        <br>        <span class="hljs-comment">//使用默认的扫描规则</span><br>		<span class="hljs-keyword">if</span> (useDefaultFilters) &#123;<br>			registerDefaultFilters();<br>		&#125;<br>		<span class="hljs-comment">//设置环境变量</span><br>		setEnvironment(environment);<br>		<span class="hljs-comment">//设置资源加载器</span><br>		setResourceLoader(resourceLoader);<br>	&#125;<br>	<br>	<span class="hljs-comment">//默认的扫描规则</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDefaultFilters</span><span class="hljs-params">()</span> </span>&#123;<br>	    <span class="hljs-comment">//添加了Componet的解析，这就是我们为啥@Componet @Respository @Service @Controller的  @AspectJ</span><br>		<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(Component.class));<br>		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//添加Jsr 250规范的注解</span><br>			<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>			logger.debug(<span class="hljs-string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>			<span class="hljs-comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br>		&#125;<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//JSR330的注解</span><br>			<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>			logger.debug(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>			<span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>		&#125;<br>	&#125;<br>	<br>	使用扫描器去真正的扫描类,返回Set&lt;BeanDefinitionHolder&gt;<br>	org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;<br>		Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>		<span class="hljs-comment">//创建一个Bean定义 holder的 set</span><br>		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();<br>		<span class="hljs-comment">//循环扫描路径</span><br>		<span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br>		    <span class="hljs-comment">//找到候选的组件集合</span><br>			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br>			<span class="hljs-comment">//循环候选组件集合</span><br>			<span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>				ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br>				candidate.setScope(scopeMetadata.getScopeName());<br>				<span class="hljs-comment">//生成bean的名称</span><br>				String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<br>				<span class="hljs-comment">//判断是不是抽象的beand定义</span><br>				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>				&#125;<br>				<span class="hljs-comment">//注解的bean定义西悉尼</span><br>				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>				&#125;<br>				<br>				<span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123; <span class="hljs-comment">//检查当前的和存主的bean定义是否有冲突</span><br>				    <span class="hljs-comment">//把候选的组件封装成BeanDefinitionHolder</span><br>					BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<br>					definitionHolder =AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>					<span class="hljs-comment">//加入到bean定义的集合中</span><br>					beanDefinitions.add(definitionHolder);<br>					<span class="hljs-comment">//注册当前的bean定义信息</span><br>					registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> beanDefinitions;<br>	&#125;<br><br>    <br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents <br>    找到候选的组件 返回Set&lt;BeanDefinition&gt;的集合<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">findCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>&#123;<br>		<span class="hljs-comment">//候选的bean定义信息</span><br>		Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//拼接需要扫描包下面的类的路径   classpath*:com/tuling/testapplicationlistener/**/*.class</span><br>			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<br>					resolveBasePackage(basePackage) + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-keyword">this</span>.resourcePattern;<br>			<span class="hljs-comment">//把路径解析成一个个.class文件		</span><br>			Resource[] resources = <span class="hljs-keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);<br>			<span class="hljs-keyword">boolean</span> traceEnabled = logger.isTraceEnabled();<br>			<span class="hljs-keyword">boolean</span> debugEnabled = logger.isDebugEnabled();<br>			<br>			<span class="hljs-comment">//循环.class文件的resource对象</span><br>			<span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>				<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>					logger.trace(<span class="hljs-string">&quot;Scanning &quot;</span> + resource);<br>				&#125;<br>				<span class="hljs-comment">//判断class文件是否可读</span><br>				<span class="hljs-keyword">if</span> (resource.isReadable()) &#123;<br>					<span class="hljs-keyword">try</span> &#123;<br>					    <span class="hljs-comment">//把resource对象 变为一个类的原信息读取器</span><br>						MetadataReader metadataReader = <span class="hljs-keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);<br>						<span class="hljs-comment">//判断类的源信息读取器是否为候选的组件</span><br>						<span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;  <span class="hljs-comment">//是候选的组件</span><br>						    <span class="hljs-comment">//把类元信息读取器封装成一个ScannedGenericBeanDefinition</span><br>							ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);<br>							sbd.setResource(resource);<br>							sbd.setSource(resource);<br>							<span class="hljs-comment">//是候选的组件</span><br>							<span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<br>								<span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>									logger.debug(<span class="hljs-string">&quot;Identified candidate component class: &quot;</span> + resource);<br>								&#125;<br>								<span class="hljs-comment">//把当前解析出来的定义的加入到 BeanDefinition的集合中</span><br>								candidates.add(sbd);<br>							&#125;<br>							<span class="hljs-keyword">else</span> &#123;<br>								<span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>									logger.debug(<span class="hljs-string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);<br>								&#125;<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">else</span> &#123;<br>							<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>								logger.trace(<span class="hljs-string">&quot;Ignored because not matching any filter: &quot;</span> + resource);<br>							&#125;<br>						&#125;<br>					&#125;<br>					<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>								<span class="hljs-string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>						logger.trace(<span class="hljs-string">&quot;Ignored because not readable: &quot;</span> + resource);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">&quot;I/O failure during classpath scanning&quot;</span>, ex);<br>		&#125;<br>		<span class="hljs-keyword">return</span> candidates;<br>	&#125;	<br><br>是不是需要扫描的组件	<br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCandidateComponent</span><span class="hljs-params">(MetadataReader metadataReader)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-comment">//是不是被排除的</span><br>		<span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.excludeFilters) &#123;<br>			<span class="hljs-keyword">if</span> (tf.match(metadataReader, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//在被包含的组件</span><br>		<span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.includeFilters) &#123;<br>			<span class="hljs-keyword">if</span> (tf.match(metadataReader, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				<span class="hljs-keyword">return</span> isConditionMatch(metadataReader);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;	<br>	<br>	是否能够进行<span class="hljs-meta">@Conditional</span>判断<br>    org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isConditionMatch<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConditionMatch</span><span class="hljs-params">(MetadataReader metadataReader)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator == <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">this</span>.conditionEvaluator = <span class="hljs-keyword">new</span> ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());<br>		&#125;<br>		<span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());<br>	&#125;	<br>	<br></code></pre></td></tr></table></figure>

<h1 id="BeanDefinition加载过程"><a href="#BeanDefinition加载过程" class="headerlink" title="BeanDefinition加载过程"></a>BeanDefinition加载过程</h1><p>概述：</p>
<p>1、new AnnotationConfigApplicationContext时注入了实现priority接口的BeanDefinitionRegistryPostProcessor的工厂bean定义注册后置处理器：ConfigurationClassPostProcessor</p>
<p>2、invokeBeanFactoryPostProcessors(beanFactory); 执行时扫描到ConfigurationClassPostProcessor</p>
<p>且调用执行</p>
<p>3、ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry的作用是</p>
<ol>
<li>识别我们传入的标有@Configuration的类</li>
<li>创建ConfigurationClassParser</li>
<li>解析配置类<ol>
<li>@ComponentScan</li>
<li>@Import</li>
<li>Bean</li>
<li>@PropertySource</li>
<li>@ImportResource</li>
<li>处理其他的</li>
</ol>
</li>
</ol>
<p><img src="/images/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/BeanDefinition%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">  </p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>bean定义信息</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC核心流程解析</title>
    <url>/2021/06/01/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>课程概要</strong></p>
<ol>
<li>spring mvc 设计思想与体系结构组成</li>
<li>mvc 执行流程解析</li>
<li>自定义MVC的框架实现</li>
</ol>
<h1 id="spring-mvc-功能特性"><a href="#spring-mvc-功能特性" class="headerlink" title="spring mvc 功能特性"></a>spring mvc 功能特性</h1><h2 id="回顾servlet-与jsp-执行过程"><a href="#回顾servlet-与jsp-执行过程" class="headerlink" title="回顾servlet 与jsp 执行过程"></a>回顾servlet 与jsp 执行过程</h2><p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image2.png" alt="image2"></p>
<p><strong>流程说明：</strong></p>
<ol>
<li>请求Servlet</li>
<li>处理业务逻辑</li>
<li>设置业务Model</li>
<li>forward jsp Servlet</li>
<li>jsp Servlet 解析封装html 返回</li>
</ol>
<h2 id="spring-mvc-功能特性："><a href="#spring-mvc-功能特性：" class="headerlink" title="spring mvc 功能特性："></a>spring mvc 功能特性：</h2><p>spring mvc本质上还是在使用Servlet处理，并在其基础上进行了封装简化了开发流程，提高易用性、并使用程序逻辑结构变得更清晰</p>
<ol>
<li><strong>基于注解的URL映射</strong></li>
<li><strong>表单参数映射，参数接受</strong></li>
<li><strong>全局统一异常拦截处理</strong></li>
<li><strong>文件上传与下载</strong></li>
<li><strong>MVC拦截器 HandlerInterceptor</strong></li>
</ol>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a><strong>请求处理流程</strong></h2><p>![image2 (1)](/images/SpringMVC核心流程解析/image2 (1).png)</p>
<ol>
<li>Web 发起request请求</li>
<li>dispatchServlet通过HandlerMapping映射关系查找到对应的Handler</li>
<li>HandlerAdapter适配handler并且执行handler逻辑</li>
<li>handler设置业务model</li>
<li>handler设置返回页面</li>
<li>dispatchServlet接受到模型视图对象</li>
<li>dispatchServlet通过viewAdapter找到view</li>
<li>view基于模板与模型将mv渲染成写成html</li>
<li>渲染结果通过response返回Web前端</li>
</ol>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210601213936301.png" alt="image-20210601213936301"></p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;study.springmvc.controller.MyController&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;study.springmvc.controller.MyRequestHandler&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;study.springmvc&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 视图仓库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;userView&quot;</span>);<br>        modelAndView.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;24kHandsome&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="userView-jsp"><a href="#userView-jsp" class="headerlink" title="userView.jsp"></a>userView.jsp</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;<br>	pageEncoding=&quot;UTF-8&quot;%&gt;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>	the man is<br>	$&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="mvc-体系结构详解"><a href="#mvc-体系结构详解" class="headerlink" title="mvc 体系结构详解"></a>mvc 体系结构详解</h1><h2 id="spring-mvc-框架解决的问题"><a href="#spring-mvc-框架解决的问题" class="headerlink" title="spring mvc 框架解决的问题"></a>spring mvc 框架解决的问题</h2><p>从技术角度去思考 任何一个现存的框架都有其存在理由，而这个理由就是解决实际的问题。或者提供更好的解决问题的方案。spring mvc 它解决了什么问题呢？ </p>
<ol>
<li>URL映射</li>
<li>表单参数映射</li>
<li>调用目标Control</li>
<li>数据模型映射视图解析</li>
<li>异常处理</li>
</ol>
<p>上术解决在spring mvc 中都体现在如下组件当中</p>
<ul>
<li><strong>HandlerMapping</strong> ‘hændlə  ‘mæpɪŋ<ul>
<li>url与控制器的映谢</li>
</ul>
</li>
<li><strong>HandlerAdapter</strong>  ‘hændlə ə’dæptə<ul>
<li>控制器执行适配器</li>
</ul>
</li>
<li><strong>ViewResolver</strong> vjuː  riː’zɒlvə <ul>
<li>视图仓库</li>
</ul>
</li>
<li><strong>view</strong><ul>
<li>具体解析视图</li>
</ul>
</li>
<li><strong>HandlerExceptionResolver</strong>  ‘hændlə  ɪk’sepʃ(ə)n  riː’zɒlvə<ul>
<li>异常捕捕捉器</li>
</ul>
</li>
<li><strong>HandlerInterceptor</strong>  ‘hændlə  ɪntə’septə<ul>
<li>拦截器</li>
</ul>
</li>
</ul>
<p>其对应具体uml如下 图：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image3.png" alt="image3"></p>
<p>mvc 各组件执行流程<br><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image4.png" alt="image4"></p>
<h2 id="SpringMVC默认引入组件"><a href="#SpringMVC默认引入组件" class="headerlink" title="SpringMVC默认引入组件"></a>SpringMVC默认引入组件</h2><p>根据 org/springframework/web/servlet/DispatcherServlet.propertiesDispatcherServlet.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Default implementation classes for DispatcherServlet&#x27;s strategy interfaces.</span><br><span class="hljs-comment"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="hljs-comment"># Not meant to be customized by application developers.</span><br><br><span class="hljs-meta">org.springframework.web.servlet.LocaleResolver</span>=<span class="hljs-string">org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.ThemeResolver</span>=<span class="hljs-string">org.springframework.web.servlet.theme.FixedThemeResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="hljs-string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br>   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\<br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br>   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\<br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="hljs-string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><br><span class="hljs-meta">org.springframework.web.servlet.ViewResolver</span>=<span class="hljs-string">org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.FlashMapManager</span>=<span class="hljs-string">org.springframework.web.servlet.support.SessionFlashMapManager</span><br></code></pre></td></tr></table></figure>

<h2 id="HandlerMapping-详解"><a href="#HandlerMapping-详解" class="headerlink" title="HandlerMapping 详解"></a>HandlerMapping 详解</h2><p>其为mvc 中url路径与Control对像的映射，DispatcherServlet 就是基于此组件来寻找对应的Control，如果找不到就会报 No mapping found for HTTP request with URI的异常。</p>
<p>HandlerMapping 接口结构分析：</p>
<p>HandlerMapping  作用是通过url找到对应的Handler ，但其HandlerMapping.getHandler()方法并不会直接返回Handler 对像，而是返回 HandlerExecutionChain 对像在通过  HandlerExecutionChain.getHandler() 返回最终的handler</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210601235555218.png" alt="image-20210601235555218"></p>
<p>目前主流的三种mapping 如下：</p>
<ol>
<li><strong>SimpleUrlHandlerMapping：基于手动配置 url 与control 映谢</strong></li>
<li><strong>BeanNameUrlHandlerMapping: 基于ioc name 中已 “/“ 开头的Bean时行 注册至映谢.</strong></li>
<li><strong>RequestMappingHandlerMapping：基于@RequestMapping注解配置对应映谢</strong></li>
</ol>
<h3 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h3><p>SimpleUrlHandlerMapping体系结构：</p>
<img src="/images/SpringMVC核心流程解析/image-20210602000051935.png" alt="image-20210602000051935" style="zoom: 80%;">



<p> 初始化SimpleUrlHandlerMapping流程关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#setUrlMap<br>  &gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#initApplicationContext<br>    &gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#registerHandlers <br>    <span class="hljs-comment">// /表示根路径 /* 表示默认路径	</span><br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler()<br><br></code></pre></td></tr></table></figure>

<p>获取 Handler流程关键源码:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.DispatcherServlet#doService&gt;org.springframework.web.servlet.DispatcherServlet#doDispatch<br>  &gt;org.springframework.web.servlet.DispatcherServlet#getHandler&gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler<br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal <br>    <span class="hljs-comment">// 获取URL路径 </span><br>    &gt;org.springframework.web.util.UrlPathHelper#getPathWithinApplication <br>    <span class="hljs-comment">// 查找handler</span><br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#lookupHandler <br>    <span class="hljs-comment">// 封装执行链</span><br>	  &gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain<br></code></pre></td></tr></table></figure>

<h3 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h3><p>BeanNameUrlHandlerMapping 实现上与 SimpleUrlHandlerMapping 一至，唯一区别在于 继承自AbstractDetectingUrlHandlerMapping ，通过对应detectHandlers 可以在无配置的情况下发现url 与handler 映射。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602231512508.png"></p>
<h3 id="RequestMappingHandlerMapping（后续补充）"><a href="#RequestMappingHandlerMapping（后续补充）" class="headerlink" title="RequestMappingHandlerMapping（后续补充）"></a><strong>RequestMappingHandlerMapping</strong>（后续补充）</h3><p>其基于注解实现，在后续章节讲解注解映谢的时候在详细讲</p>
<h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>在 AbstractUrlHandlerMapping 我们可以看到存储handler 的Map 值类型是Object ，是否意味着所有的类都可以做来Handler 来使用？</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image10.png" alt="image10"></p>
<p>Handler  对应类型如下如图：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image11.png" alt="image11"></p>
<ol>
<li><strong>Controller</strong></li>
<li><strong>HttpRequestHandler</strong></li>
<li><strong>HttpServlet</strong></li>
<li><strong>@RequestMapping</strong></li>
</ol>
<p>可以看出 Handler 没有统一的接口，当dispatchServlet获取当对应的Handler之后如何调用呢？调用其哪个方法？这里有两种解决办法，</p>
<p><strong>一是用instanceof 判断Handler 类型然后调用相关方法 。</strong></p>
<p><strong>二是通过引入适配器实现，每个适配器实现对指定Handler的调用。</strong></p>
<p>spring 采用后者。</p>
<p><strong>HandlerAdapter详解</strong></p>
<p>这里spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter,其Handler与 HandlerAdapter 对应关系如下:</p>
<table>
<thead>
<tr>
<th>Handler类别</th>
<th>对应适配器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>SimpleControllerHandlerAdapter</td>
<td>标准控制器，返回ModelAndView</td>
</tr>
<tr>
<td>HttpRequestHandler</td>
<td>HttpRequestHandlerAdapter</td>
<td>业务自行处理 请求，不需要通过modelAndView 转到视图</td>
</tr>
<tr>
<td>Servlet</td>
<td>SimpleServletHandlerAdapter</td>
<td>基于标准的servlet 处理</td>
</tr>
<tr>
<td>HandlerMethod</td>
<td>RequestMappingHandlerAdapter</td>
<td>基于@requestMapping对应方法处理</td>
</tr>
</tbody></table>
<p>HandlerAdapter  接口方法</p>
<img src="/images/SpringMVC核心流程解析/image-20210602232832491.png" alt="image-20210602232832491">

<p>HandlerAdapter  接口结构图</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602232931062.png" alt="image-20210602232931062"></p>
<p>上述例子中当IOC 中实例化这些类之后 DispatcherServlet 就会通过org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter() 方法查找对应handler的适配器 ，如果找不到就会报 如下异常 。</p>
<blockquote>
<p>javax.servlet.ServletException: No adapter for handler [com.tuling.control.SimpleControl@3c06b5d5]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handlerorg.springframework.web.servlet.DispatcherServlet.getHandlerAdapter(DispatcherServlet.java:1198)org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)</p>
</blockquote>
<h2 id="ViewResolver-与View"><a href="#ViewResolver-与View" class="headerlink" title="ViewResolver 与View"></a>ViewResolver 与View</h2><p>找到应的Adapter 之后就会基于适配器调用业务处理，处理完之后业务方会返回一个ModelAndView ，在去查找对应的视图进行处理。</p>
<p>其在<strong>org.springframework.web.servlet.DispatcherServlet#resolveViewName()</strong> 中遍历 viewResolvers 列表查找，如果找不到就会报一个 Could not resolve view with name 异常。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602233734756.png" alt="image-20210602233734756"></p>
<p>BeanNameViewREsolver示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">添加自定义视图:<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, ?&gt; model, HttpServletRequest </span></span><br><span class="hljs-function"><span class="hljs-params">            request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;hello luban good man.&quot;</span>);<br>    &#125;<br>&#125;<br><br>修改视图跳转方法 ：<br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;myView&quot;</span>);<br>    mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;24kHandsome is good man&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">配置视图解析器：<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myView&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tuling.control.MyView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--资源解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在下一步就是基于ViewResolver**.**resolveViewName() 获取对应View来解析生成Html并返回 。</p>
<p>对应VIEW结构如下：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602234106079.png" alt="image-20210602234106079"></p>
<h2 id="MVC异常拦截处理HandlerExceptionResolver"><a href="#MVC异常拦截处理HandlerExceptionResolver" class="headerlink" title="MVC异常拦截处理HandlerExceptionResolver"></a>MVC异常拦截处理HandlerExceptionResolver</h2><p>HandlerExceptionResolver的类关系图</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605144323346.png" alt="image-20210605144323346"></p>
<ul>
<li>ResponseStatuExceptionResolver<ul>
<li>用于解析带@ResponseStatus的自定义异常</li>
</ul>
</li>
<li>DefaultHandlerExceptionResolver<ul>
<li>spring mvc 默认异常处理</li>
</ul>
</li>
<li>SimpleMappingExceptionResolver<ul>
<li>异常映射，将指定异常与错误页面相对应</li>
</ul>
</li>
</ul>
<p>该组件用于指示 当出现异常时 mvc 该如何处理。 dispatcherServlet 会调用org.springframework.web.servlet.DispatcherServlet#processHandlerException() 方法，遍历 handlerExceptionResolvers 处理异常，处理完成之后返回errorView 跳转到异常视图。</p>
<p>自定义异常解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                         HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                                         Object handler, Exception ex)</span> </span>&#123;<br><br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;argumentError&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;stack&quot;</span>,ex);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>SimpleMappingExceptionResolver 示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultErrorView&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatusCode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;500&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.RuntimeException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.IllegalArgumentException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;argumentError&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><p>IllegalArgumentException 是 RuntimeException子类，如果IllegalArgumentException  异常同时满足映射的两个条件，这时会怎么选择跳转的视图？</p>
<p>答案是会选择IllegalArgumentException 这个子类，而不是根据先后顺序</p>
<h2 id="HandlerInterceptor-调用拦截"><a href="#HandlerInterceptor-调用拦截" class="headerlink" title="HandlerInterceptor  调用拦截"></a>HandlerInterceptor  调用拦截</h2><p>HandlerInterceptor  用于对请求拦截，</p>
<p>HandlerInterceptor  常常用于对某些路径进行特殊配置，可用于</p>
<ul>
<li>参数打印 业务处理前 后</li>
<li>登陆/权限拦截 业务处理前</li>
<li>数字验签 业务处理前</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>preHandle ：业务处理前执行</p>
<p>postHandle：业务处理后（异常则不执行）</p>
<p>afterCompletion：视图处理后</p>
<h3 id="Filter与Interceptor联系与区别"><a href="#Filter与Interceptor联系与区别" class="headerlink" title="Filter与Interceptor联系与区别"></a>Filter与Interceptor联系与区别</h3><ul>
<li>拦截器不依赖servlet容器，过滤器依赖于servlet容器。</li>
<li>拦截器只能对action（handler）起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。</li>
<li>拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。</li>
<li>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</li>
<li><strong>细粒度的不同</strong>拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，<strong>也可以在渲染视图呈现给用户之后调用</strong></li>
<li><strong>中断链执行的难易程度不同</strong>拦截器可以 preHandle方法内返回 false 进行中断，过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面</li>
</ul>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605230700202.png" alt="image-20210605230700202"></p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605231527804.png" alt="image-20210605231527804"></p>
<h3 id="三者使用场景"><a href="#三者使用场景" class="headerlink" title="三者使用场景"></a>三者使用场景</h3><p>三者功能类似，但各有优势，从过滤器–》拦截器–》切面，拦截规则越来越细致，执行顺序依次是过滤器、拦截器、切面。</p>
<p><strong>一般情况下数据被过滤的时机越早对服务的性能影响越小</strong>，因此我们在编写相对比较公用的代码时，优先考虑过滤器，然后是拦截器，最后是aop。</p>
<p>比如权限校验，一般情况下（经供参考）</p>
<p>所有的请求都需要做登陆校验，此时就应该使用过滤器在最顶层做校验</p>
<p>日志记录，一般日志只会针对部分逻辑做日志记录，而且牵扯到业务逻辑完成前后的日志记录，因此使用过滤器不能细致地划分模块，此时应该考虑拦截器，然而拦截器也是依据URL做规则匹配，因此相对来说不够细致，因此我们会考虑到使用AOP实现，AOP可以针对代码的方法级别做拦截，很适合日志功能。</p>
<h2 id="RequestMapping的使用与原理"><a href="#RequestMapping的使用与原理" class="headerlink" title="@RequestMapping的使用与原理"></a>@RequestMapping的使用与原理</h2><p>演示基于注解配置mvc mapping </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;study.springmvc&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 视图仓库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRequestHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        request.getRequestDispatcher(<span class="hljs-string">&quot;userView&quot;</span>).forward(request,response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>提问</strong> </p>
<p>​    为什么基于&lt;mvc:annotation-driven /&gt; 配置就能实现mvc 的整个配置了</p>
<p>之前所提到的 handlerMapping 、与handlerAdapter 组件都不适用了？只要查看以类的源就可以知晓其中原因：认识 NamespaceHandler 接口查看 MvcNamespaceHandler查看AnnotationDrivenBeanDefinitionParser</p>
<p><strong>结论</strong>：</p>
<p>​    在&lt;mvc:annotation-driven /&gt; 对应的解析器，自动向ioc 里面注册了两个BeanDefinition。</p>
<p>​    分别是：<strong>RequestMappingHandlerMapping</strong>与<strong>BeanNameUrlHandlerMapping</strong></p>
<p>![image2 (2)](/images/SpringMVC核心流程解析/image2 (2).png)</p>
<ul>
<li>RequestMappingHandlerMapping :URL 映射器</li>
<li>RequestMappingHandlerAdapter：执行适配器</li>
<li>InvocableHandlerMethod：Control目标对象，包含了control Bean 及对应的method 对像，及调用方法 <ul>
<li>HandlerMethodArgumentResolverComposite：参数处理器 </li>
<li>ParameterNameDiscoverer：参数名称处理器 </li>
<li>HandlerMethodReturnValueHandlerComposite：返回结构处理器</li>
</ul>
</li>
</ul>
<p>查找mapping源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 基于注解查找 mapping</span><br>org.springframework.web.servlet.DispatcherServlet#getHandler<br>&gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler<br> &gt;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod<br> &gt;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#getMappingsByUrl<br></code></pre></td></tr></table></figure>

<p>调用执行过程源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle<br> &gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal <br> &gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod<br>   &gt;org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest<br>    &gt;org.springframework.web.method.support.InvocableHandlerMethod#doInvoke<br></code></pre></td></tr></table></figure>

<h1 id="自定义MVC的框架实现"><a href="#自定义MVC的框架实现" class="headerlink" title="自定义MVC的框架实现"></a>自定义MVC的框架实现</h1><h2 id="框架需求与目标"><a href="#框架需求与目标" class="headerlink" title="框架需求与目标"></a>框架需求与目标</h2><h3 id="框架需求："><a href="#框架需求：" class="headerlink" title="框架需求："></a>框架需求：</h3><p>​    框架的需求包含<strong>功能性需求</strong> 和<strong>非功能性需求</strong>，功能性需求框架本身所提供的功能，而非功能性需求通常也指定体验性需求，即该框架对于开发者而言，是否易上手，是否需要较多的学习成本，以及在开发时需要过多的配置。</p>
<p>​    有个时候两者是互相矛盾冲突的，比如当我们想让框架支持更的功能时，那么它的结构设计将会更复杂，抽像的层次将会越多，带来的负面影响时对框架使用者的学习成本增加了。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210606174425301.png" alt="image-20210606174425301"></p>
<p>到底该选择更多的功能，还是更好的体验？这就需要框架作者要作出准确的定位与范围。</p>
<p>定位是该框架要完成什么目标？范围是实现该目标需实现哪些功能？两者清晰之后 自然知道哪些是必须做的，哪些是可以做的。而体验则是在保证必须功能的情况越高越好，甚至可以为了提供体验可以牺牲部分功能的完整性。</p>
<p><strong>功能性需求用例图：</strong></p>
<img src="/images/SpringMVC核心流程解析/image-20210606175802297.png" alt="image-20210606175802297" style="zoom:80%;">

<ul>
<li>URL映射<ul>
<li>基于注解自动匹配调用方法</li>
</ul>
</li>
<li>参数自动解析<ul>
<li>Form表单参数自动转换成一般对像和复杂对像</li>
</ul>
</li>
<li>请求调用<ul>
<li>基于反射调用目标方法</li>
</ul>
</li>
<li>视图支持<ul>
<li>基于返回的结果跳转至视图处理</li>
<li>支持的有jsp 视图，freemarke视图，Json视图</li>
</ul>
</li>
<li>统一异常处理<ul>
<li>出现异常统一处理，并跳转到异常页面</li>
</ul>
</li>
</ul>
<p><strong>非功能性需求与目标：</strong></p>
<ul>
<li>接近于零的配置</li>
<li>更少的学习成本<ul>
<li>尽可能使用用户之前习惯</li>
<li>概念性的东西要少一些</li>
</ul>
</li>
<li>支持动态装载</li>
</ul>
<h2 id="框架设计与编码实现"><a href="#框架设计与编码实现" class="headerlink" title="框架设计与编码实现"></a>框架设计与编码实现</h2><p>框架环境依赖：</p>
<p>​    框架名称：study-myspringMVC</p>
<p>​    jdk:1.8</p>
<p>​    依赖包：spring、freemarker、java-servlet-api</p>
<p><strong>框架流程分解：</strong></p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210606221522334.png" alt="image-20210606221522334"></p>
<p><strong>实现组件：</strong></p>
<ul>
<li><strong>FreemakerView</strong><ul>
<li>freemarke视图</li>
</ul>
</li>
<li><strong>HandlerServlet</strong>（原DispatchServlet）<ul>
<li>请求参数封装，请求转发</li>
</ul>
</li>
<li><strong>MvcBeanFactory</strong>（类似HandlerMapping 持有 url对应handler的map）<ul>
<li>Mvc bean 工厂 ，从spring ioc 中扫描类装载MVC Bean</li>
</ul>
</li>
<li><strong>MvcBean</strong>（原HandlerMethod，因为只有一种handler，所以无需HandlerAdaptor）<ul>
<li>MVC 业务执行</li>
</ul>
</li>
<li><strong>MvcMaping</strong>（原@RequestMapping）<ul>
<li>MVC注解，用于注解MVC Bean，并配置url 路径</li>
</ul>
</li>
</ul>
<p>代码：</p>
<p>1、模拟DispatchServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">//IOC父容器</span><br>    <span class="hljs-keyword">private</span> WebApplicationContext context;<br>    <span class="hljs-comment">//MVC子容器</span><br>    <span class="hljs-keyword">private</span> MvcBeanFactory beanFactory;<br>    <span class="hljs-comment">//asm字节码解析器，用户解析请求参数对应的key</span><br>    <span class="hljs-keyword">final</span> ParameterNameDiscoverer parameterUtil = <span class="hljs-keyword">new</span> LocalVariableTableParameterNameDiscoverer();<br>    <br>    <span class="hljs-keyword">private</span> Configuration freemarkeConfig;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>        beanFactory = <span class="hljs-keyword">new</span> MvcBeanFactory(context);<br><br>        Configuration freemarkeConfig = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            freemarkeConfig = context.getBean(Configuration.class);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (freemarkeConfig == <span class="hljs-keyword">null</span>) &#123;<br>            freemarkeConfig = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_23);<br>            freemarkeConfig.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            freemarkeConfig.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);<br>            <span class="hljs-keyword">try</span> &#123;<br>                freemarkeConfig.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> File(getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/ftl/&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.freemarkeConfig = freemarkeConfig;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doHandler(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doHandler(req, resp);<br>    &#125;<br>    <br>	<span class="hljs-comment">// TODO 处理静态文件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doHandler</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;<br>         String uri = req.getServletPath();<br>        <span class="hljs-keyword">if</span> (uri.equals(<span class="hljs-string">&quot;/favicon.ico&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//获取Hadnler</span><br>        MvcBeanFactory.MvcBean mvcBean = beanFactory.getMvcBean(uri);<br>        <span class="hljs-keyword">if</span> (mvcBean == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;not found %s mapping&quot;</span>, uri));<br>        &#125;<br>        <span class="hljs-comment">//利用asm字节码工具解析参数</span><br>    	Object[] args = buildPrams(mvcBean, req, resp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//反射运行目标对象 handlerMethod</span><br>            Object result = mvcBean.run(args);<br>            <span class="hljs-comment">//封装返回结果</span><br>            processResult(result, resp);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (TemplateException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Object[] buildPrams(MvcBeanFactory.MvcBean mvcBean, HttpServletRequest req, HttpServletResponse resp) &#123;<br>        Method method = mvcBean.getTargetMethod();<br>        List&lt;String&gt; paramNames = Arrays.asList(parameterUtil.getParameterNames(method));<br>        Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); <span class="hljs-comment">//反射</span><br>        <span class="hljs-comment">// a.b.c</span><br>        Object[] args = <span class="hljs-keyword">new</span> Object[paramTypes.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paramNames.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (paramTypes[i].isAssignableFrom(HttpServletRequest.class)) &#123;<br>                args[i] = req;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (paramTypes[i].isAssignableFrom(HttpServletResponse.class)) &#123;<br>                args[i] = resp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (req.getParameter(paramNames.get(i)) == <span class="hljs-keyword">null</span>) &#123;<br>                    args[i] = <span class="hljs-keyword">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    args[i] = convert(req.getParameter(paramNames.get(i)), paramTypes[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、模拟@RequstMapping:MvcMapping和Mvc子容器持有HandleMapping:MvcBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MvcMapping &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">contentType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;JSON&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcBeanFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MvcBeanFactory</span><span class="hljs-params">(ApplicationContext applicationContext)</span> </span>&#123;<br>        Assert.notNull(applicationContext, <span class="hljs-string">&quot;argument &#x27;applicationContext&#x27; must not be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>        loadApiFromSpringBeans();<br>    &#125;<br><br>    <span class="hljs-comment">// API 接口住的地方 </span><br>    <span class="hljs-keyword">private</span> HashMap&lt;String, MvcBean&gt; apiMap = <span class="hljs-keyword">new</span> HashMap&lt;String, MvcBean&gt;();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadApiFromSpringBeans</span><span class="hljs-params">()</span> </span>&#123;<br>        apiMap.clear();<br>        <span class="hljs-comment">// ioc 所有BEan</span><br>        <span class="hljs-comment">// spring ioc 扫描</span><br>        String[] names = applicationContext.getBeanDefinitionNames();<br>        Class&lt;?&gt; type;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            type = applicationContext.getType(name);<br>            <span class="hljs-keyword">for</span> (Method m : type.getDeclaredMethods()) &#123;<br>                <span class="hljs-comment">// 通过反射拿到HttpMapping注解</span><br>                MvcMapping MvcMapping = m.getAnnotation(MvcMapping.class);<br>                <span class="hljs-keyword">if</span> (MvcMapping != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 封装成一个 MVC bean</span><br>                    addApiItem(MvcMapping, name, m);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MvcBean <span class="hljs-title">getMvcBean</span><span class="hljs-params">(String apiName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> apiMap.get(apiName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加api &lt;br/&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> MvcMapping api配置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName   beanq在spring context中的名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addApiItem</span><span class="hljs-params">(MvcMapping MvcMapping, String beanName, Method method)</span> </span>&#123;<br>        MvcBean apiRun = <span class="hljs-keyword">new</span> MvcBean();<br>        apiRun.apiName = MvcMapping.value();<br>        apiRun.targetMethod = method;<br>        apiRun.targetName = beanName;<br>        apiRun.context = <span class="hljs-keyword">this</span>.applicationContext;<br>        apiMap.put(MvcMapping.value(), apiRun);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsApi</span><span class="hljs-params">(String apiName, String version)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> apiMap.containsKey(apiName + <span class="hljs-string">&quot;_&quot;</span> + version);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ApplicationContext <span class="hljs-title">getApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> applicationContext;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 用于执行对应的API方法，</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcBean</span> </span>&#123;<br>        String apiName;  <span class="hljs-comment">//bit.api.user.getUser</span><br><br>        String targetName; <span class="hljs-comment">//ioc bean 名称</span><br><br>        Object target; <span class="hljs-comment">// UserServiceImpl 实例</span><br>        Method targetMethod; <span class="hljs-comment">// 目标方法 getUser</span><br>        ApplicationContext context;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;<br>            <span class="hljs-comment">// 懒加载</span><br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// spring ioc 容器里面去服务Bean 比如GoodsServiceImpl</span><br>                target = context.getBean(targetName);<br>            &#125;<br>            <span class="hljs-keyword">return</span> targetMethod.invoke(target, args);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;<br>            <span class="hljs-keyword">return</span> targetMethod.getParameterTypes();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getApiName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> apiName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTargetName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> targetName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getTargetMethod</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> targetMethod;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、FreeMaker试图接续器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkeView</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String ftlPath;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; models = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreemarkeView</span><span class="hljs-params">(String ftlPath)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreemarkeView</span><span class="hljs-params">(String ftlPath, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>        <span class="hljs-keyword">this</span>.models = model;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setModel</span><span class="hljs-params">(String key, Object model)</span> </span>&#123;<br>        models.put(key, model);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeModel</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        models.remove(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFtlPath</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFtlPath</span><span class="hljs-params">(String ftlPath)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getModels</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> models;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setModels</span><span class="hljs-params">(Map&lt;String, Object&gt; models)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.models = models;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xmlns:web</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;WebApp_ID&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- root ioc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>my spring mvc <span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>spring监听器<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.study.mvc.HandlerServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>/index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程07-Executor线程池原理与源码分析</title>
    <url>/2021/11/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>​    <strong>线程池</strong>:“线程池”，顾名思义就是一个线程缓存，线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控</p>
<p>​    在web开发中，服务器需要接受并处理请求，所以会==<strong>为一个请求来分配一个线程来进行处理</strong>==。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题： 如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p>
<p>​    那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<pre><code> 这就是线程池了。线程池为线程生命周期的开销和资源不足问题提供了解决方 案。**通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上**。
</code></pre>
<h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>什么时候使用线程池？</p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大 </li>
</ul>
<p><strong>线程池优势</strong>    </p>
<p>1、重复使用已创建的线程，减少线程创建、销毁的性能开销，提高性能<br>2、提高响应速度，无需等待线程创建即可立即执行<br>3、提高线程的可管理性。线程是稀缺资源，如果无限制创建，会消耗系统资源，提高线程切换时间，进而减低系统稳定性。<strong>使用线程池可以对线程资源统一调度，调优和监控</strong></p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><ol>
<li><strong>Runnable</strong></li>
<li><strong>Tread</strong></li>
<li><strong>Callable</strong> </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Runnable接口的类将被Thread执行，表示一个基本的任务 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123; <br>    <span class="hljs-comment">// run方法就是它所有的内容，就是实际执行的任务 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>; </span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-comment">//Callable同样是任务，与Runnable接口的区别在于它接收泛型，同时它执行任务后带 有返回内容 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> interface Callable&lt;V&gt; </span>&#123; <br>    <span class="hljs-comment">// 相对于run方法的带有返回值的call方法 </span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception; </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方 法。</p>
<p>下图为它的继承与实现</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211114234452760.png" alt="image-20211114234452760"></p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>​    Executor下的一个重要子接口ExecutorService，其中定义了线程池的具体行为</p>
<p><strong>1、excute（Runnable command）：执行Runnable任务</strong></p>
<p><strong>2、submit（Task）：提交Callable或者Runnable任务，并返回任务对应的FutureTask对象</strong></p>
<p><strong>3、shutdown()：在完成已提交的任务后封闭办事，不再接管新任务</strong></p>
<p><strong>4、shutdownNow()：停止所有正在履行的任务并封闭办事。</strong></p>
<p><strong>5、isTerminated()：测试是否所有任务都履行完毕</strong></p>
<p><strong>6、isShutdown：测试是否该ExecutorService已被关闭</strong></p>
<h3 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h3><p>1、<strong>ThreadPoolExecutor 默认线程池</strong> </p>
<p>2、<strong>ScheduledThreadPoolExecutor 定时线程池</strong> </p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h3><h4 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h4><p>​    ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两 部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这 里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存 workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常 量表示workerCount的上限值，大约是5亿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>; <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><strong>ctl相关方法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取运行状态； </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <br><span class="hljs-comment">//获取活动线程数；</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <br><span class="hljs-comment">//获取运行状态和活动线程数的值。 </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;	<br><br><span class="hljs-comment">//线程池存在5种状态 </span><br>RUNNING = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为111 </span><br>SHUTDOWN = <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为000 </span><br>STOP = <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为001 </span><br>TIDYING = <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为010 </span><br>TERMINATED = <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为011</span><br></code></pre></td></tr></table></figure>

<p><strong>1、RUNNING</strong> </p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。<br>(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！ </p>
<p><strong>2、 SHUTDOWN</strong><br>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 </p>
<p><strong>3、STOP</strong><br>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。<br>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p><strong>4、TIDYING</strong><br>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。<br>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。 </p>
<p><strong>5、 TERMINATED</strong><br>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。<br>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程池的创建</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, </span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, </span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, </span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//任务提交 </span></span><br><span class="hljs-function">1、<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-comment">//提交任务无返回值 </span></span><br><span class="hljs-function">2、<span class="hljs-keyword">public</span> Future&lt;?&gt; <span class="hljs-title">submit</span><span class="hljs-params">()</span> <span class="hljs-comment">//任务执行完成后有返回值</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>参数解释</strong> </p>
<p><strong>corePoolSize</strong> </p>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到 阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会 提前创建并启动所有核心线程。 </p>
<p><strong>maximumPoolSize</strong> </p>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize； </p>
<p><strong>keepAliveTime</strong> </p>
<p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待 的时间超过了keepAliveTime； </p>
<p><strong>unit</strong></p>
<p>keepAliveTime的单位； </p>
<p><strong>workQueue</strong> </p>
<p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列： </p>
<p>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务； </p>
<p>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</p>
<p>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene； </p>
<p>4、priorityBlockingQuene：具有优先级的无界阻塞队列； </p>
<p><strong>threadFactory</strong> </p>
<p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程 时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设 置了线程的名称。 </p>
<p><strong>handler</strong> </p>
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： </p>
<p>1、AbortPolicy：直接抛出异常，默认策略； </p>
<p>2、CallerRunsPolicy：用调用者所在的线程来执行任务； </p>
<p>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； </p>
<p>4、DiscardPolicy：直接丢弃任务； </p>
<p>上面的4种策略都是ThreadPoolExecutor的内部类。 当然也可以根据应用场景实RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
</blockquote>
<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a><strong>任务提交</strong></h3><p>1、<strong>public void</strong> execute() //提交任务无返回值 </p>
<p>2、<strong>public</strong> Future&lt;?&gt; submit() //任务执行完成后有返回值 </p>
<h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolicySample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                <span class="hljs-number">3</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">3</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                Executors.defaultThreadFactory(),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<br>        Future&lt;String&gt; future = <span class="hljs-keyword">null</span>;<br>        List&lt;Future&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            list.add(pool.submit(<span class="hljs-keyword">new</span> CallTask(i+<span class="hljs-number">1</span>)));<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;提交顺序&quot;</span>+i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;callTask 方法输出&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTaskCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池已执行与未执行的任务总数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCompletedTaskCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//已完成的任务数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPoolSize</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池当前的线程数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getActiveCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池中正在执行任务的线程数量</span></span><br></code></pre></td></tr></table></figure>

<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211118233809035.png" alt="image-20211118233809035"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//正在执行的线程数小于核心线程数，则启动一个新线程，且把该任务当做第一个任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//入队成功，正在执行的线程数大于核心线程数且小于最大线程数，启动一个新线程执行新提交的任务</span><br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//入队失败，队列已满且正在执行的线程数小于于最大线程数，则启动线程执行该任务，否则执行拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121174123772.png" alt="image-20211121174123772"></p>
<h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>        retry:<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = ctl.get();<br>            <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>                ! (rs == SHUTDOWN &amp;&amp;<br>                   firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>                   ! workQueue.isEmpty()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                    wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                    <span class="hljs-keyword">break</span> retry;<br>                c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                    <span class="hljs-keyword">continue</span> retry;<br>                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>        Worker w = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>            <span class="hljs-keyword">final</span> Thread t = w.thread;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>                mainLock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck while holding lock.</span><br>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                    <span class="hljs-comment">// shut down before lock acquired.</span><br>                    <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                        workers.add(w);<br>                        <span class="hljs-keyword">int</span> s = workers.size();<br>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                            largestPoolSize = s;<br>                        workerAdded = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mainLock.unlock();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                    t.start();<br>                    workerStarted = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (! workerStarted)<br>                addWorkerFailed(w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>​    线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，请参见JDK源码。</p>
<p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li>如果正在执行任务，则不应该中断线程；</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？</p>
<p>​    是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123; <br>    <span class="hljs-comment">//cas修改state，不可重入 </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <br>        setExclusiveOwnerThread(Thread.currentThread()); <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>&#125; <br></code></pre></td></tr></table></figure>

<p>​    tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是 为了禁止在执行任务前对线程进行中断。 正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为 0。</p>
<h4 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>        Thread wt = Thread.currentThread();<br>        Runnable task = w.firstTask;<br>        w.firstTask = <span class="hljs-keyword">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>                w.lock();<br>                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>                <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    wt.interrupt();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforeExecute(wt, task);<br>                    Throwable thrown = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里说明一下第一个if判断，目的是：</p>
<p>​    如果线程池正在停止，那么要保证当前线程是中断状态；</p>
<p>​    如果不是的话，则要保证当前线程不是中断状态；</p>
<p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p>
<p>​    不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</p>
<p>​    在线程池处于RUNNING或SHUTDOWN状态时，调用shutdownNow()方法会使线程池进入到该状态。</p>
<p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p>
<p>总结一下runWorker方法的执行过程：</p>
<p>​    1.while循环不断地通过getTask()方法获取任务；</p>
<p>​    2.getTask()方法从阻塞队列中取任务；</p>
<p>​    3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</p>
<p>​    4.调用task.run()执行任务；</p>
<p>​    5.如果task为null则跳出循环，执行processWorkerExit()方法；</p>
<p>​    6.runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</p>
<p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p>
<h4 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>       <span class="hljs-comment">/** 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断： </span><br><span class="hljs-comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span><br><span class="hljs-comment">         * 2. 阻塞队列是否为空。</span><br><span class="hljs-comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span><br><span class="hljs-comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加 任务。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>      	<span class="hljs-comment">// Are workers subject to culling? </span><br>        <span class="hljs-comment">// timed变量用于判断是否需要进行超时控制。 </span><br>        <span class="hljs-comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超 时； </span><br>        <span class="hljs-comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量； </span><br>        <span class="hljs-comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">/** 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控 制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span><br><span class="hljs-comment">            * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。 </span><br><span class="hljs-comment">            **/</span><br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>
<p>​    什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p>​    getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h4 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>   	 <span class="hljs-comment">/** </span><br><span class="hljs-comment">   	  * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接 addWorker；</span><br><span class="hljs-comment">      * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个 worker；</span><br><span class="hljs-comment">      * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生 命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程， runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入 processWorkerExit方法，整个线程结束，如图所示：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121174031239.png" alt="image-20211121174031239"></p>
<h4 id="work实现AQS不继承ReentrantLock的原因"><a href="#work实现AQS不继承ReentrantLock的原因" class="headerlink" title="work实现AQS不继承ReentrantLock的原因"></a>work实现AQS不继承ReentrantLock的原因</h4><p>可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的</p>
<p>Worker线程具有以下特性：</p>
<p>1、 lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</p>
<p>2、如果正在执行任务，则不应该中断线程； </p>
<p>3、如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</p>
<p>4、线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程是否拥有锁来判断线程是否是空闲状态； </p>
<p>5、之所以使用不可重入锁，是为了避免正在执行的任务调用像setCorePoolSize这样的线程池控制方法时重新获取锁从而中断正在运行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>    <span class="hljs-comment">//cas修改state，不可重入 </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        setExclusiveOwnerThread(Thread.currentThread()); <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; &#125;<br></code></pre></td></tr></table></figure>



<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>MyExecutor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyExecutor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MyThreadPoolExecutor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyExecutor</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认队列大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> defaultQueueSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认池的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> defaultPoolSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> defaultAliveTime = <span class="hljs-number">60l</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池最大的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxPoolSize = <span class="hljs-number">50</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> poolsize;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> completedTaskCount;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拒绝策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectPolicy handler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否已经中断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isShutDown = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * active当前激活线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="hljs-title">getWorkQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> workQueue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Lock</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否允许超时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> allowThreadTimeOut;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> keepAliveTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(defaultPoolSize,defaultQueueSize,defaultAliveTime,<span class="hljs-keyword">new</span> DefaultRejectPolicy());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolsize)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(poolsize,defaultQueueSize,defaultAliveTime,<span class="hljs-keyword">new</span> DefaultRejectPolicy());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolsize, <span class="hljs-keyword">int</span> queueSize, <span class="hljs-keyword">long</span> keepAliveTime, RejectPolicy handler)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(poolsize &lt;= <span class="hljs-number">0</span> || poolsize &gt; maxPoolSize )<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;线程池大小不能&lt;=0&quot;</span>);<br>        <span class="hljs-keyword">this</span>.poolsize = poolsize;<br>        <span class="hljs-keyword">this</span>.handler = handler;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = keepAliveTime;<br>        <span class="hljs-keyword">if</span>(keepAliveTime &gt; <span class="hljs-number">0</span>)<br>            allowThreadTimeOut = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.workQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;任务不能为空&quot;</span>);<br>        <span class="hljs-keyword">if</span>(isShutDown)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;线程池已销毁,禁止提交任务...&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//任务数小于</span><br>        <span class="hljs-keyword">if</span>(c &lt; poolsize)&#123;<br>            <span class="hljs-keyword">if</span>(addWorker(task,<span class="hljs-keyword">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(workQueue.offer(task))&#123;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            handler.rejected(task,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//任务拒绝策略</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            isShutDown = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)&#123;<br>                Thread t = w.thread;<br>                <span class="hljs-keyword">if</span>(!t.isInterrupted() &amp;&amp; w.tryLock())&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        t.interrupt();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-comment">//e.printStackTrace();</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        w.unlock();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取出任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> allowThreadTimeOut ? workQueue.poll(keepAliveTime, TimeUnit.SECONDS) : workQueue.take();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isShutDown;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker worker)</span></span>&#123;<br>        Thread wt = Thread.currentThread();<br>        Runnable task = worker.firstTask;<br>        worker.firstTask = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task=getTask())!=<span class="hljs-keyword">null</span>)&#123;<br>                worker.lock();<br>                <span class="hljs-keyword">if</span> (isShutDown &amp;&amp; !wt.isInterrupted())&#123;<br>                    wt.interrupt();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                    worker.completedTask++; <span class="hljs-comment">//当前线程完成的任务数</span><br>                    worker.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(worker,completedAbruptly);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker worker, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(completedAbruptly)<br>            ctl.decrementAndGet();<br><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            completedTaskCount += worker.completedTask;<br>            workers.remove(worker);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(completedAbruptly &amp;&amp; !workQueue.isEmpty())&#123;<br>            addWorker(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否启动线程执行任务 or 放入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startNew</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable r,<span class="hljs-keyword">boolean</span> startNew)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startNew)&#123;<br>            ctl.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br><br>        Worker w = <span class="hljs-keyword">new</span> Worker(r);<br>        Thread t = w.thread;<br>        <span class="hljs-keyword">if</span>(t != <span class="hljs-keyword">null</span>)&#123;<br>            ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(!isShutDown)&#123; <span class="hljs-comment">// 线程池未关闭</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// 检查线程是否已经处于运行状态，start方法不能重复调用执行</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded)&#123;<br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger atomic = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTask;<br>        <span class="hljs-keyword">final</span> Thread thread;<br>        Runnable firstTask;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable r)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.firstTask = r;<br>            <span class="hljs-keyword">this</span>.thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;thread-name-&quot;</span>+atomic.incrementAndGet());<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            runWorker(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>RejectPolicy 线程池满拒绝策略相关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拒绝策略</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> executor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestRejectPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestRejectPolicy</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!executor.isShutdown())&#123;<br>            executor.getWorkQueue().poll();<br>            executor.execute(task);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolicyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PolicyException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PolicyException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultRejectPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultRejectPolicy</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;任务已经满了&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PolicyException(<span class="hljs-string">&quot;任务已经满了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThreadPoolExecutor pool = <span class="hljs-keyword">new</span> MyThreadPoolExecutor(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">60</span>,<span class="hljs-keyword">new</span> DiscardOldestRejectPolicy());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            pool.execute(<span class="hljs-keyword">new</span> MyTask(i));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121222630602.png" alt="image-20211121222630602"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Executor</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day01</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day01/</url>
    <content><![CDATA[<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p>
<p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p>
<h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，<strong>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。==它描==述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p>
<h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<p>正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><p>用于描述“怎样创建对象”，它的主要特点是“==将对象的创建与使用分离==”。GoF（四人组）书中提供了<strong>单例、原型、工厂方法、抽象工厂、建造者</strong>等 5 种创建型模式。</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>用于描述如何==将类或对象按某种布局组成更大的结构==，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>用于描述==类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务==，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
<h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>
<h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul>
<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>
<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>
</ul>
<h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p>
<p><img src="/images/design-model-day01/Employee.jpg"></p>
<p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p>
<ul>
<li><p><strong>+：表示public</strong></p>
</li>
<li><p><strong>-：表示private</strong></p>
</li>
<li><p><strong>#：表示protected</strong></p>
</li>
</ul>
<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong>  </p>
<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>
<blockquote>
<p>注意：</p>
<p>​    1，中括号中的内容表示是可选的</p>
<p>​    2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>
</blockquote>
<p><strong>举个栗子：</strong></p>
<p><img src="/images/design-model-day01/demo.png"></p>
<p>上图Demo类定义了三个方法：</p>
<ul>
<li>method()方法：修饰符为public，没有参数，没有返回值。</li>
<li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li>
<li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li>
</ul>
<h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p><strong>关联关系是对象之间的一种引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联又可以分为单向关联，双向关联，自关联。</p>
<h5 id="1，单向关联"><a href="#1，单向关联" class="headerlink" title="1，单向关联"></a><strong>1，单向关联</strong></h5><p><img src="/images/design-model-day01/customer_address.png"></p>
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<h5 id="2，双向关联"><a href="#2，双向关联" class="headerlink" title="2，双向关联"></a><strong>2，双向关联</strong></h5><p><img src="/images/design-model-day01/customer_product.png"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>
<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<h5 id="3，自关联"><a href="#3，自关联" class="headerlink" title="3，自关联"></a><strong>3，自关联</strong></h5><p><img src="/images/design-model-day01/node.png"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>
<h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p><strong>聚合关系是关联关系的一种</strong>，是强关联关系，是==整体和部分之间的关系==。</p>
<p>聚合关系也是通过成员对象来实现的，<strong>其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。</strong>例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src="/images/design-model-day01/image-20191229173422328.png"></p>
<h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种<strong>更强烈的聚合关系</strong>。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，<strong>一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。</strong>例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src="/images/design-model-day01/image-20191229173455149.png"></p>
<h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，<strong>某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类</strong>（被依赖类）中的某些方法来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>
<p><img src="/images/design-model-day01/image-20191229173518926.png"></p>
<h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>
<p><img src="/images/design-model-day01/image-20191229173539838.png"></p>
<h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>
<p><img src="/images/design-model-day01/image-20191229173554296.png"></p>
<h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p>
<p>【例】<code>搜狗输入法</code> 的皮肤设计。</p>
<p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>
<p><img src="/images/design-model-day01/open-close.png"></p>
<h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p>
<p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>下面看一个里氏替换原则中经典的一个例子</p>
<p>【例】正方形不是长方形。</p>
<p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p>
<p><img src="/images/design-model-day01/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png"></p>
<p>代码如下：</p>
<p><strong>长方形类（Rectangle）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>正方形（Square）：</strong></p>
<p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(width);<br>        <span class="hljs-keyword">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(length);<br>        <span class="hljs-keyword">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectangleDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        Rectangle rectangle1 = <span class="hljs-keyword">new</span> Square();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p>
<p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p>
<img src="/images/design-model-day01/正方形不是长方形改进.png" style="zoom:80%;">



<h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>下面看一个例子来理解依赖倒转原则</p>
<p>【例】组装电脑</p>
<p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p>
<p><strong>类图如下：</strong></p>
<img src="/images/design-model-day01/依赖倒转原则.png" style="zoom:80%;">

<p>代码如下：</p>
<p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiJieHardDisk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HardDisk</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷硬盘存储数据&quot;</span> + data);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷希捷硬盘取数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Intel处理器（IntelCpu）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cpu</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用Intel处理器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>金士顿内存条（KingstonMemory）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KingstonMemory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用金士顿作为内存条&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> XiJieHardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> IntelCpu cpu;<br>    <span class="hljs-keyword">private</span> KingstonMemory memory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IntelCpu <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(IntelCpu cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> KingstonMemory <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(KingstonMemory memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XiJieHardDisk <span class="hljs-title">getHardDisk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHardDisk</span><span class="hljs-params">(XiJieHardDisk hardDisk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>        cpu.run();<br>        memory.save();<br>        String data = hardDisk.get();<br>        System.out.println(<span class="hljs-string">&quot;从硬盘中获取的数据为：&quot;</span> + data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试类（TestComputer）：</strong></p>
<p>测试类用来组装电脑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestComputer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        computer.setHardDisk(<span class="hljs-keyword">new</span> XiJieHardDisk());<br>        computer.setCpu(<span class="hljs-keyword">new</span> IntelCpu());<br>        computer.setMemory(<span class="hljs-keyword">new</span> KingstonMemory());<br><br>        computer.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p>
<p>根据依赖倒转原则进行改进：</p>
<p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p>
<p><strong>类图如下：</strong></p>
<img src="/images/design-model-day01/依赖倒转原则改进.png" alt="image-20191229173554296" style="zoom:70%;">

<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> HardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> Cpu cpu;<br>    <span class="hljs-keyword">private</span> Memory memory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HardDisk <span class="hljs-title">getHardDisk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHardDisk</span><span class="hljs-params">(HardDisk hardDisk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cpu <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(Cpu cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memory <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Memory memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p>
<h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>下面看一个例子来理解接口隔离原则</p>
<p>【例】安全门案例</p>
<p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p>
<p><img src="/images/design-model-day01/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png"></p>
<p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p>
<p><img src="/images/design-model-day01/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png"></p>
<p>代码如下：</p>
<p><strong>AntiTheft（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AntiTheft</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Fireproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fireproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Waterproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Waterproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waterproof</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>HeiMaSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeiMaSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AntiTheft</span>,<span class="hljs-title">Fireproof</span>,<span class="hljs-title">Waterproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waterproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ItcastSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItcastSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AntiTheft</span>,<span class="hljs-title">Fireproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p><strong>迪米特法则又叫最少知识原则。</strong></p>
<p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p>
<p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>下面看一个例子来理解迪米特法则</p>
<p>【例】明星与经纪人的关系实例</p>
<p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p>类图如下：</p>
<img src="/images/design-model-day01/迪米特法则.png" alt="image-20191229173554296" style="zoom:80%;">

<p>代码如下：</p>
<p><strong>明星类（Star）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Star</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>粉丝类（Fans）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fans</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fans</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>媒体公司类（Company）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Company</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>经纪人类（Agent）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStar</span><span class="hljs-params">(Star star)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFans</span><span class="hljs-params">(Fans fans)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompany</span><span class="hljs-params">(Company company)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">meeting</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。</p>
<p>通常类的复用分为<strong>继承复用</strong>和<strong>合成复用</strong>两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在类的成员位置声明抽象。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
<p>下面看一个例子来理解合成复用原则</p>
<p>【例】汽车分类管理程序</p>
<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p>
<img src="/images/design-model-day01/合成复用原则.png" alt="image-20191229173554296" style="zoom:80%;">

<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>
<img src="/images/design-model-day01/合成复用原则1.png" alt="image-20191229173554296" style="zoom:80%;">



<h1 id="4，创建者模式"><a href="#4，创建者模式" class="headerlink" title="4，创建者模式"></a>4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>
<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>
<p>创建型模式分为：</p>
<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工程模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p>
<ul>
<li>单例类。只能创建一个实例的类</li>
<li>访问类。使用单例类</li>
</ul>
<h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote>
<p>单例设计模式分类两种：</p>
<p>​    饿汉式：类加载就会导致该单实例对象被创建    </p>
<p>​    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<ol>
<li><p>饿汉式-方式1（静态变量方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p>
</li>
<li><p>饿汉式-方式2（静态代码块方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p>
</li>
<li><p>懒汉式-方式1（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p>
</li>
<li><p>懒汉式-方式2（线程安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p>
</li>
<li><p>懒汉式-方式3（双重检查锁）</p>
<p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p>
<p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">小结：</font></p>
<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
</li>
</ol>
<ol start="6">
<li><p>懒汉式-方式4（静态内部类方式）</p>
<p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p>
<p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p>
<p><font color="red">小结：</font></p>
<p>​    静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
</li>
<li><p>枚举方式</p>
<p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    枚举方式属于恶汉式方式。</p>
</li>
</ol>
<h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p>
<p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是克隆、序列化和反射。</p>
<ul>
<li><p>序列化反序列化</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        Singleton s1 = readObjectFromFile();<br>        Singleton s2 = readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        Singleton instance = (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        Singleton instance = Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p>
</blockquote>
</li>
<li><p>反射</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>              <span class="hljs-comment">//通过getInstance()获取</span><br>        Singleton singleton = Singleton.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;singleton的hashCode:&quot;</span>+singleton.hashCode());<br>        <span class="hljs-comment">//通过克隆获取</span><br>        Singleton clob = (Singleton) Singleton.getInstance().clone();<br>        System.out.println(<span class="hljs-string">&quot;clob的hashCode:&quot;</span>+clob.hashCode());<br>        <span class="hljs-comment">//通过序列化，反序列化获取</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(Singleton.getInstance());<br>        ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>        Singleton serialize = (Singleton) ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;serialize的hashCode:&quot;</span>+serialize.hashCode());<br>        <span class="hljs-comment">//通过反射获取</span><br>        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>      Singleton reflex = constructor.newInstance();<br>        System.out.println(<span class="hljs-string">&quot;reflex的hashCode:&quot;</span>+reflex.hashCode());<br>        <span class="hljs-keyword">if</span>(ois != <span class="hljs-keyword">null</span>)&#123;<br>            ois.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bis != <span class="hljs-keyword">null</span>)&#123;<br>            bis.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(oos != <span class="hljs-keyword">null</span>)&#123;<br>            oos.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bos != <span class="hljs-keyword">null</span>)&#123;<br>            bos.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p>
</blockquote>
<h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul>
<li><p>序列化、反序列方式破坏单例模式的解决方法</p>
<p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>,<span class="hljs-title">Cloneable</span> </span>&#123;<br><br>      <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> Singleton.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>源码解析：</strong></p>
<p>ObjectInputStream类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException</span>&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-keyword">int</span> outerHandle = passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object obj = readObject0(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readObject0</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>	...<br>    <span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-keyword">switch</span> (tc) &#123;<br>			...<br>			<span class="hljs-keyword">case</span> TC_OBJECT:<br>				<span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>			...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>	...<br>	<span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-keyword">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-keyword">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    	<span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    	<span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    	Object rep = desc.invokeReadResolve(obj);<br>     	...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-1-4-JDK源码解析-Runtime类"><a href="#4-1-4-JDK源码解析-Runtime类" class="headerlink" title="4.1.4 JDK源码解析-Runtime类"></a>4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p>
<ol>
<li><p>通过源代码查看使用的是哪儿种单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p>
</li>
<li><p>使用Runtime类中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        Runtime runtime = Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        Process process = runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        InputStream inputStream = process.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> b = inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day02</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/</url>
    <content><![CDATA[<h1 id="4，创建型模式"><a href="#4，创建型模式" class="headerlink" title="4，创建型模式"></a>4，创建型模式</h1><h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。  </p>
<p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>具体类的设计如下：</p>
<img src="/images/设计模式-day02/工厂设计模式引入.png" style="zoom:80%;">

<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>
<p>在本教程中会介绍三种工厂的使用</p>
<ul>
<li>简单工厂模式（不属于GOF的23种经典设计模式）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="4-2-2-简单工厂模式"><a href="#4-2-2-简单工厂模式" class="headerlink" title="4.2.2 简单工厂模式"></a>4.2.2 简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>
<h4 id="4-2-2-1-结构"><a href="#4-2-2-1-结构" class="headerlink" title="4.2.2.1 结构"></a>4.2.2.1 结构</h4><p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<h4 id="4-2-2-2-实现"><a href="#4-2-2-2-实现" class="headerlink" title="4.2.2.2 实现"></a>4.2.2.2 实现</h4><p>现在使用简单工厂对上面案例进行改进，类图如下：</p>
<img src="/images/设计模式-day02/简单工厂模式.png" style="zoom:70%;">

<p>工厂类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p>
<h4 id="4-2-2-4-优缺点"><a href="#4-2-2-4-优缺点" class="headerlink" title="4.2.2.4 优缺点"></a>4.2.2.4 优缺点</h4><p><strong>优点：</strong></p>
<p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p>
<p><strong>缺点：</strong></p>
<p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p>
<h4 id="4-2-2-3-扩展"><a href="#4-2-2-3-扩展" class="headerlink" title="4.2.2.3 扩展"></a>4.2.2.3 扩展</h4><p><strong>静态工厂</strong></p>
<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-2-3-工厂方法模式"><a href="#4-2-3-工厂方法模式" class="headerlink" title="4.2.3 工厂方法模式"></a>4.2.3 工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<h4 id="4-2-3-1-概念"><a href="#4-2-3-1-概念" class="headerlink" title="4.2.3.1 概念"></a>4.2.3.1 概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<h4 id="4-2-3-2-结构"><a href="#4-2-3-2-结构" class="headerlink" title="4.2.3.2 结构"></a>4.2.3.2 结构</h4><p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h4 id="4-2-3-3-实现"><a href="#4-2-3-3-实现" class="headerlink" title="4.2.3.3 实现"></a>4.2.3.3 实现</h4><p>使用工厂方法模式对上例进行改进，类图如下：</p>
<img src="/images/设计模式-day02/工厂方法模式.png" style="zoom:70%;">

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LatteCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>咖啡店类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeStore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CoffeeFactory factory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeStore</span><span class="hljs-params">(CoffeeFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.factory = factory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">orderCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = factory.createCoffee();<br>        coffee.addMilk();<br>        coffee.addsugar();<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<h4 id="4-2-3-4-优缺点"><a href="#4-2-3-4-优缺点" class="headerlink" title="4.2.3.4 优缺点"></a>4.2.3.4 优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
<h3 id="4-2-4-抽象工厂模式"><a href="#4-2-4-抽象工厂模式" class="headerlink" title="4.2.4 抽象工厂模式"></a>4.2.4 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>
<img src="/images/设计模式-day02/image-20200401214509176.png" style="zoom:67%;">

<img src="/images/设计模式-day02/image-20200401222951963.png" style="zoom:67%;">

<h4 id="4-2-4-1-概念"><a href="#4-2-4-1-概念" class="headerlink" title="4.2.4.1 概念"></a>4.2.4.1 概念</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h4 id="4-2-4-2-结构"><a href="#4-2-4-2-结构" class="headerlink" title="4.2.4.2 结构"></a>4.2.4.2 结构</h4><p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<h4 id="4-2-4-2-实现"><a href="#4-2-4-2-实现" class="headerlink" title="4.2.4.2 实现"></a>4.2.4.2 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<img src="/images/设计模式-day02/抽象工厂模式.png" style="zoom:67%;">

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//美式甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MatchaMousse();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//意大利风味甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItalyDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tiramisu();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<h4 id="4-2-4-3-优缺点"><a href="#4-2-4-3-优缺点" class="headerlink" title="4.2.4.3 优缺点"></a>4.2.4.3 优缺点</h4><p><strong>优点：</strong></p>
<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong></p>
<p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h4 id="4-2-4-4-使用场景"><a href="#4-2-4-4-使用场景" class="headerlink" title="4.2.4.4 使用场景"></a>4.2.4.4 使用场景</h4><ul>
<li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p>
</li>
<li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p>
</li>
<li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p>
</li>
</ul>
<p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p>
<h3 id="4-2-5-模式扩展"><a href="#4-2-5-模式扩展" class="headerlink" title="4.2.5 模式扩展"></a>4.2.5 模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p>
<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>
<p>第一步：定义配置文件</p>
<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">american</span>=<span class="hljs-string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span><br><span class="hljs-attr">latte</span>=<span class="hljs-string">com.itheima.pattern.factory.config_factory.LatteCoffee</span><br></code></pre></td></tr></table></figure>

<p>第二步：改进工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Properties p = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;bean.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            p.load(is);<br>            <span class="hljs-comment">//遍历Properties集合对象</span><br>            Set&lt;Object&gt; keys = p.keySet();<br>            <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>                <span class="hljs-comment">//根据键获取值（全类名）</span><br>                String className = p.getProperty((String) key);<br>                <span class="hljs-comment">//获取字节码对象</span><br>                Class clazz = Class.forName(className);<br>                Coffee obj = (Coffee) clazz.newInstance();<br>                map.put((String)key,obj);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> map.get(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>
<h3 id="4-2-6-JDK源码解析-Collection-iterator方法"><a href="#4-2-6-JDK源码解析-Collection-iterator方法" class="headerlink" title="4.2.6 JDK源码解析-Collection.iterator方法"></a>4.2.6 JDK源码解析-Collection.iterator方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;风清扬&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;任我行&quot;</span>);<br><br>        <span class="hljs-comment">//获取迭代器对象</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-comment">//使用迭代器遍历</span><br>        <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>            String ele = it.next();<br>            System.out.println(ele);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p>
<img src="/images/设计模式-day02/JDK源码解析.png" style="zoom:75%;">

<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p>
<blockquote>
<p>另：</p>
<p>​    1,DateForamt类中的getInstance()方法使用的是工厂模式；</p>
<p>​    2,Calendar类中的getInstance()方法使用的是工厂模式；</p>
</blockquote>
<h2 id="4-3-原型模式"><a href="#4-3-原型模式" class="headerlink" title="4.3 原型模式"></a>4.3 原型模式</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<h3 id="4-3-2-结构"><a href="#4-3-2-结构" class="headerlink" title="4.3.2 结构"></a>4.3.2 结构</h3><p>原型模式包含如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ul>
<p>接口类图如下：</p>
<p><img src="/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/img%5C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="4-3-3-实现"><a href="#4-3-3-实现" class="headerlink" title="4.3.3 实现"></a>4.3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p>
<blockquote>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>
<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>
</blockquote>
<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p>
<p><strong>Realizetype（具体的原型类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Realizetype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Realizetype</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体的原型对象创建完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Realizetype <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体原型复制成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> (Realizetype) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PrototypeTest（测试访问类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Realizetype r1 = <span class="hljs-keyword">new</span> Realizetype();<br>        Realizetype r2 = r1.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-4-案例"><a href="#4-3-4-案例" class="headerlink" title="4.3.4 案例"></a>4.3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p>
<p>类图如下：</p>
<img src="/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/原型模式1.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试访问类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        c1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//将奖状的名字修改李四</span><br>        c2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-5-使用场景"><a href="#4-3-5-使用场景" class="headerlink" title="4.3.5 使用场景"></a>4.3.5 使用场景</h3><ul>
<li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li>
<li>性能和安全要求比较高。</li>
</ul>
<h3 id="4-3-6-扩展（深克隆）"><a href="#4-3-6-扩展（深克隆）" class="headerlink" title="4.3.6 扩展（深克隆）"></a>4.3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student stu;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getStu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStu</span><span class="hljs-params">(Student stu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stu = stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(stu.getName() + <span class="hljs-string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/原型模式2.png" style="zoom:80%;">

<p><font color="red">说明：</font></p>
<p>​    stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//创建对象输出流对象</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//将c1对象写出到文件中</span><br>        oos.writeObject(c1);<br>        oos.close();<br><br>        <span class="hljs-comment">//创建对象出入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//读取对象</span><br>        Citation c2 = (Citation) ois.readObject();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/原型模式3.png" style="zoom:80%;">

<blockquote>
<p>注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</p>
</blockquote>
<h2 id="4-5-建造者模式"><a href="#4-5-建造者模式" class="headerlink" title="4.5 建造者模式"></a>4.5 建造者模式</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<img src="/images/设计模式-day02/image-20200413225341516.png" style="zoom:60%;">

<ul>
<li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
</ul>
<h3 id="4-4-2-结构"><a href="#4-4-2-结构" class="headerlink" title="4.4.2 结构"></a>4.4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p>
<ul>
<li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p>
</li>
<li><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p>
</li>
<li><p>产品类（Product）：要创建的复杂对象。</p>
</li>
<li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </p>
</li>
</ul>
<p>类图如下：</p>
<img src="/images/设计模式-day02/建造者模式.png" style="zoom:80%;">



<h3 id="4-4-3-实例"><a href="#4-4-3-实例" class="headerlink" title="4.4.3 实例"></a>4.4.3 实例</h3><p><strong>创建共享单车</strong></p>
<p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p>
<p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p>
<img src="/images/设计模式-day02/建造者模式1.png" style="zoom:80%;">

<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自行车类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String frame;<br>    <span class="hljs-keyword">private</span> String seat;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(String frame)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.frame = frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> seat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSeat</span><span class="hljs-params">(String seat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.seat = seat;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike mBike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//摩拜单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobikeBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setFrame(<span class="hljs-string">&quot;铝合金车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setSeat(<span class="hljs-string">&quot;真皮车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ofo单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OfoBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setFrame(<span class="hljs-string">&quot;碳纤维车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setSeat(<span class="hljs-string">&quot;橡胶车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指挥者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder mBuilder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        mBuilder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        mBuilder.buildFrame();<br>        mBuilder.buildSeat();<br>        <span class="hljs-keyword">return</span> mBuilder.createBike();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        showBike(<span class="hljs-keyword">new</span> OfoBuilder());<br>        showBike(<span class="hljs-keyword">new</span> MobikeBuilder());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBike</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        Director director = <span class="hljs-keyword">new</span> Director(builder);<br>        Bike bike = director.construct();<br>        System.out.println(bike.getFrame());<br>        System.out.println(bike.getSeat());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike mBike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.buildFrame();<br>        <span class="hljs-keyword">this</span>.BuildSeat();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createBike();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p>
<h3 id="4-4-4-优缺点"><a href="#4-4-4-优缺点" class="headerlink" title="4.4.4 优缺点"></a>4.4.4 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<h3 id="4-4-5-使用场景"><a href="#4-4-5-使用场景" class="headerlink" title="4.4.5 使用场景"></a>4.4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h3 id="4-4-6-模式扩展"><a href="#4-4-6-模式扩展" class="headerlink" title="4.4.6 模式扩展"></a>4.4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p>
<p>重构前代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span><span class="hljs-params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(String cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScreen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScreen</span><span class="hljs-params">(String screen)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(String memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMainboard</span><span class="hljs-params">(String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构建Phone对象</span><br>        Phone phone = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&quot;intel&quot;</span>,<span class="hljs-string">&quot;三星屏幕&quot;</span>,<span class="hljs-string">&quot;金士顿&quot;</span>,<span class="hljs-string">&quot;华硕&quot;</span>);<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p>
<p>重构后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Phone</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        cpu = builder.cpu;<br>        screen = builder.screen;<br>        memory = builder.memory;<br>        mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">cpu</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            cpu = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">screen</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            screen = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">memory</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            memory = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">mainboard</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            mainboard = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Phone <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Phone(<span class="hljs-keyword">this</span>);&#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Phone phone = <span class="hljs-keyword">new</span> Phone.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>)<br>                .build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p>
<h2 id="4-6-创建者模式对比"><a href="#4-6-创建者模式对比" class="headerlink" title="4.6 创建者模式对比"></a>4.6 创建者模式对比</h2><h3 id="4-6-1-工厂方法模式VS建造者模式"><a href="#4-6-1-工厂方法模式VS建造者模式" class="headerlink" title="4.6.1 工厂方法模式VS建造者模式"></a>4.6.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p>
<p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p>
<h3 id="4-6-2-抽象工厂模式VS建造者模式"><a href="#4-6-2-抽象工厂模式VS建造者模式" class="headerlink" title="4.6.2 抽象工厂模式VS建造者模式"></a>4.6.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p>
<p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day03</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/</url>
    <content><![CDATA[<h1 id="5，结构型模式"><a href="#5，结构型模式" class="headerlink" title="5，结构型模式"></a>5，结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为<strong>静态代理</strong>和<strong>动态代理</strong>。**==静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。==**</p>
<h3 id="5-1-2-结构"><a href="#5-1-2-结构" class="headerlink" title="5.1.2 结构"></a>5.1.2 结构</h3><p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h3 id="5-1-3-静态代理"><a href="#5-1-3-静态代理" class="headerlink" title="5.1.3 静态代理"></a>5.1.3 静态代理</h3><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>
<img src="/images/设计模式-day03/静态代理.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代售点</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用&quot;</span>);<br>        station.sell();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ProxyPoint pp = <span class="hljs-keyword">new</span> ProxyPoint();<br>        pp.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<h3 id="5-1-4-JDK动态代理"><a href="#5-1-4-JDK动态代理" class="headerlink" title="5.1.4 JDK动态代理"></a>5.1.4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂，用来创建代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SellTickets <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用Proxy获取代理对象</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            newProxyInstance()方法参数说明：</span><br><span class="hljs-comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span><br><span class="hljs-comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span><br><span class="hljs-comment">                InvocationHandler h ： 代理对象的调用处理程序</span><br><span class="hljs-comment">         */</span><br>        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        InvocationHandler中invoke方法参数说明：</span><br><span class="hljs-comment">                            proxy ： 代理对象</span><br><span class="hljs-comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span><br><span class="hljs-comment">                            args ： 代理对象调用接口方法时传递的实际参数</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);<br>                        <span class="hljs-comment">//执行真实对象</span><br>                        Object result = method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        <br>        SellTickets proxyObject = factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p>ProxyFactory是代理类吗？</p>
<p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sun.proxy;<br><br><span class="hljs-keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-keyword">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;object&#125;);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
</li>
<li><p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//程序运行过程中动态生成的代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-keyword">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        m3 = Class.forName(<span class="hljs-string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Java提供的动态代理相关类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-keyword">protected</span> InvocationHandler h;<br>	 <br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.h = h;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SellTickets <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);<br>                        Object result = method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//测试访问类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        SellTickets proxyObject = factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>执行流程如下：</p>
<ol>
<li><strong>在测试类中通过代理对象调用sell()方法</strong></li>
<li><strong>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</strong></li>
<li><strong>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</strong></li>
<li><strong>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</strong></li>
</ol>
<h3 id="5-1-5-CGLIB动态代理"><a href="#5-1-5-CGLIB动态代理" class="headerlink" title="5.1.5 CGLIB动态代理"></a>5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//火车站</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<br><br><br>    <span class="hljs-keyword">public</span> &lt;T extends Object&gt; <span class="hljs-function">T <span class="hljs-title">getProxyObject</span><span class="hljs-params">(T sellTicket)</span></span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        enhancer.setSuperclass(sellTicket.getClass());<br>        enhancer.setCallback(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> (T)enhancer.create();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o,Method method,Object[] objects,MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(CGLIB动态代理方式))&quot;</span>);<br>        method.invoke(o,objects);<br>        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o,objects);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        TrainStation proxyObject = proxyFactory.getProxyObject(<span class="hljs-keyword">new</span> TrainStation());<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-1-6-三种代理的对比"><a href="#5-1-6-三种代理的对比" class="headerlink" title="5.1.6 三种代理的对比"></a>5.1.6 三种代理的对比</h3><ul>
<li><p>jdk代理和CGLIB代理</p>
<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>
</li>
<li><p>动态代理和静态代理</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>
</li>
</ul>
<h3 id="5-1-7-优缺点"><a href="#5-1-7-优缺点" class="headerlink" title="5.1.7 优缺点"></a>5.1.7 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统的复杂度；</li>
</ul>
<h3 id="5-1-8-使用场景"><a href="#5-1-8-使用场景" class="headerlink" title="5.1.8 使用场景"></a>5.1.8 使用场景</h3><h4 id="1、远程（Remote）代理"><a href="#1、远程（Remote）代理" class="headerlink" title="==1、远程（Remote）代理=="></a><strong>==1、远程（Remote）代理==</strong></h4><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p>
<h4 id="2、防火墙（Firewall）代理（vpn）"><a href="#2、防火墙（Firewall）代理（vpn）" class="headerlink" title="==2、防火墙（Firewall）代理（vpn）=="></a><strong>==2、防火墙（Firewall）代理（vpn）==</strong></h4><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
<p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
<h4 id="3、保护（Protect-or-Access）代理（网关）"><a href="#3、保护（Protect-or-Access）代理（网关）" class="headerlink" title="==3、保护（Protect or Access）代理（网关）=="></a><strong>==3、保护（Protect or Access）代理（网关）==</strong></h4><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p>
<h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E8%BD%AC%E6%8E%A5%E5%A4%B4.png"></p>
<p><strong>定义：</strong></p>
<p>​    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>​    适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2 结构"></a>5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h3 id="5-2-3-类适配器模式"><a href="#5-2-3-类适配器模式" class="headerlink" title="5.2.3 类适配器模式"></a>5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03/适配器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SD卡的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取SD卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readSD</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入SD卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//SD卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg = <span class="hljs-string">&quot;sd card read a msg :hello word SD&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sd card write msg : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">(SDCard sdCard)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sdCard == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;sd card null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sdCard.readSD();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//TF卡接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TFCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取TF卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readTF</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入TF卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//TF卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TFCard</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readTF</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg =<span class="hljs-string">&quot;tf card read msg : hello word tf card&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;tf card write a msg : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义适配器类（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter read tf card &quot;</span>);<br>        <span class="hljs-keyword">return</span> readTF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter write tf card&quot;</span>);<br>        writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>        SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF();<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h3 id="5-2-4-对象适配器模式"><a href="#5-2-4-对象适配器模式" class="headerlink" title="5.2.4 对象适配器模式"></a>5.2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<img src="/images/设计模式-day03/对象适配器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建适配器对象（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TFCard tfCard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SDAdapterTF</span><span class="hljs-params">(TFCard tfCard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tfCard = tfCard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter read tf card &quot;</span>);<br>        <span class="hljs-keyword">return</span> tfCard.readTF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter write tf card&quot;</span>);<br>        tfCard.writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>        TFCard tfCard = <span class="hljs-keyword">new</span> TFCardImpl();<br>        SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF(tfCard);<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：当不需要<strong>全部实现</strong>接口提供的方法时，可先设计一个<strong>抽象类</strong>实现接口，并为该接口中每个方法提供一个<strong>默认实现</strong>（空方法），那么该抽象类的子类可<strong>有选择</strong>地覆盖父类的某些方法来实现需求，它适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</p>
</blockquote>
<p>举例：WebMvcConfigurerAdapter和WebMvcConfigurer</p>
<h3 id="5-2-5-应用场景"><a href="#5-2-5-应用场景" class="headerlink" title="5.2.5 应用场景"></a>5.2.5 应用场景</h3><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h3 id="5-2-6-JDK源码解析"><a href="#5-2-6-JDK源码解析" class="headerlink" title="5.2.6 JDK源码解析"></a>5.2.6 JDK源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p>
<p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read(cbuf, offset, length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p>
<p>从上图可以看出：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li>
</ul>
<p><font color="red">结论：</font></p>
<p>​    从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>
<h2 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3 装饰者模式"></a>5.3 装饰者模式</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<img src="/images/设计模式-day03/装饰者模式-使用前.png" style="zoom:80%;">

<p>使用继承的方式存在的问题：</p>
<ul>
<li><p>扩展性不好</p>
<p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p>
</li>
<li><p>产生过多的子类</p>
</li>
</ul>
<p><strong>定义：</strong></p>
<p>​    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h3 id="5-3-2-结构"><a href="#5-3-2-结构" class="headerlink" title="5.3.2 结构"></a>5.3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h3 id="5-3-3-案例"><a href="#5-3-3-案例" class="headerlink" title="5.3.3 案例"></a>5.3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03//装饰者模式.png" style="zoom:75%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快餐接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFood</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> price;<br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取价格</span><br>&#125;<br><br><span class="hljs-comment">//炒饭</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedRice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedRice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;炒饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//炒面</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedNoodles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedNoodles</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;炒面&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//配料类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Garnish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> FastFood fastFood;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FastFood <span class="hljs-title">getFastFood</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFastFood</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Garnish</span><span class="hljs-params">(FastFood fastFood, <span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(price,desc);<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//鸡蛋配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;鸡蛋&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//培根配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bacon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bacon</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br><br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;培根&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//点一份炒饭</span><br>        FastFood food = <span class="hljs-keyword">new</span> FriedRice();<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加鸡蛋的炒饭</span><br>        FastFood food1 = <span class="hljs-keyword">new</span> FriedRice();<br><br>        food1 = <span class="hljs-keyword">new</span> Egg(food1);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food1.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food1.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加培根的炒面</span><br>        FastFood food2 = <span class="hljs-keyword">new</span> FriedNoodles();<br>        food2 = <span class="hljs-keyword">new</span> Bacon(food2);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food2.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food2.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>
</li>
<li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</li>
</ul>
<h3 id="5-3-4-使用场景"><a href="#5-3-4-使用场景" class="headerlink" title="5.3.4 使用场景"></a>5.3.4 使用场景</h3><ul>
<li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>不能采用继承的情况主要有两类：</p>
<ul>
<li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li>
<li>第二类是因为类定义不能继承（如final类）</li>
</ul>
</li>
<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
</li>
<li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
</li>
</ul>
<h3 id="5-3-5-JDK源码解析"><a href="#5-3-5-JDK源码解析" class="headerlink" title="5.3.5 JDK源码解析"></a>5.3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建BufferedWriter对象</span><br>        <span class="hljs-comment">//创建FileWriter对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(fw);<br><br>        <span class="hljs-comment">//写数据</span><br>        bw.write(<span class="hljs-string">&quot;hello Buffered&quot;</span>);<br><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p>
<img src="/images/设计模式-day03/装饰者模式-jdk源码.png" style="zoom:80%;">

<blockquote>
<p><font color="red">小结：</font></p>
<p>​    BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p>
</blockquote>
<h3 id="5-3-6-代理和装饰者的区别"><a href="#5-3-6-代理和装饰者的区别" class="headerlink" title="5.3.6 代理和装饰者的区别"></a>5.3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p>
<ul>
<li>相同点：<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
</li>
<li>不同点：<ul>
<li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li>
<li>本质区别：<ul>
<li>1、代理模式是**==控制访问==**</li>
<li>2、装饰者模式是**==动态增强行为==**</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4 桥接模式"></a>5.4 桥接模式</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/image-20200207194617620.png"></p>
<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>
<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p><strong>定义：</strong></p>
<p>​    <strong>将抽象与实现分离，使它们可以独立变化</strong>。**==它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。==**</p>
<h3 id="5-4-2-结构"><a href="#5-4-2-结构" class="headerlink" title="5.4.2 结构"></a>5.4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<h3 id="5-4-3-案例"><a href="#5-4-3-案例" class="headerlink" title="5.4.3 案例"></a>5.4.3 案例</h3><p>【例】视频播放器</p>
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03/桥接模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//视频文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//avi文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVIFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;avi视频文件：&quot;</span>+ fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//rmvb文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">REVBBFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;rmvb文件：&quot;</span> + fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//操作系统版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> VideoFile videoFile;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperatingSystemVersion</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.videoFile = videoFile;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//Windows版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Windows</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystem</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Windows</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//mac版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mac</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mac</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>		videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OperatingSystem os = <span class="hljs-keyword">new</span> Windows(<span class="hljs-keyword">new</span> AVIFile());<br>        os.play(<span class="hljs-string">&quot;战狼3&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>
</li>
<li><p>实现细节对客户透明</p>
</li>
</ul>
<h3 id="5-4-4-使用场景"><a href="#5-4-4-使用场景" class="headerlink" title="5.4.4 使用场景"></a>5.4.4 使用场景</h3><ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h2 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5 外观模式"></a>5.5 外观模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>
<p><strong>定义：</strong></p>
<p>​    又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>​    <strong>外观（Facade）模式是“迪米特法则”的典型应用</strong></p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%BC%95%E5%85%A5.jpg"></p>
<h3 id="5-5-2-结构"><a href="#5-5-2-结构" class="headerlink" title="5.5.2 结构"></a>5.5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<h3 id="5-5-3-案例"><a href="#5-5-3-案例" class="headerlink" title="5.5.3 案例"></a>5.5.3 案例</h3><p>【例】智能家电控制</p>
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>
<img src="/images/设计模式-day03/外观模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//灯类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了灯....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了灯....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电视类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了电视....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了电视....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//控制类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了空调....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了空调....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//智能音箱</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartAppliancesFacade</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Light light;<br>    <span class="hljs-keyword">private</span> TV tv;<br>    <span class="hljs-keyword">private</span> AirCondition airCondition;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmartAppliancesFacade</span><span class="hljs-params">()</span> </span>&#123;<br>        light = <span class="hljs-keyword">new</span> Light();<br>        tv = <span class="hljs-keyword">new</span> TV();<br>        airCondition = <span class="hljs-keyword">new</span> AirCondition();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;打开&quot;</span>)) &#123;<br>            on();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;关闭&quot;</span>)) &#123;<br>            off();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我还听不懂你说的！！！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//起床后一键开电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;起床了&quot;</span>);<br>        light.on();<br>        tv.on();<br>        airCondition.on();<br>    &#125;<br><br>    <span class="hljs-comment">//睡觉一键关电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉了&quot;</span>);<br>        light.off();<br>        tv.off();<br>        airCondition.off();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建外观对象</span><br>        SmartAppliancesFacade facade = <span class="hljs-keyword">new</span> SmartAppliancesFacade();<br>        <span class="hljs-comment">//客户端直接与外观对象进行交互</span><br>        facade.say(<span class="hljs-string">&quot;打开家电&quot;</span>);<br>        facade.say(<span class="hljs-string">&quot;关闭家电&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h3 id="5-5-4-使用场景"><a href="#5-5-4-使用场景" class="headerlink" title="5.5.4 使用场景"></a>5.5.4 使用场景</h3><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ul>
<h3 id="5-5-5-源码解析"><a href="#5-5-5-源码解析" class="headerlink" title="5.5.5 源码解析"></a>5.5.5 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p>
<img src="/images/设计模式-day03/image-20200207234545691.png" style="zoom:60%;">

<p>RequestFacade类就使用了外观模式。先看结构图：</p>
<img src="/images/设计模式-day03/外观模式-jdk源码解析.png" style="zoom:70%;">

<p><strong>为什么在此处使用外观模式呢？</strong></p>
<p><a href="https://www.jianshu.com/p/b52db22657f3">https://www.jianshu.com/p/b52db22657f3</a>    </p>
<p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p>
<blockquote>
<p><code>Request</code>对象中的很多方法都是内部组件之间相互交互时使用的，例如<code>setComet</code>、<code>setRequestedSessionId</code>等方法(这里不一一列举)。这些方法并不对外部公开，但是又必须设置为<code>public</code>因为还需要跟内部组件之间交互使用。最好的解决方法就是通过使用一个<code>Facade</code>类，将与内部组件之间交互使用的方法屏蔽掉，只提供给外部程序感兴趣的方法。</p>
<p>如果不使用<code>Facade</code>类，直接传递的是<code>Request</code>对象与<code>Response</code>对象，那么熟悉容器内部运作的程序员可以分别把<code>ServletRequest</code>和<code>ServletResponse</code>对象向下转换为<code>Request</code>和<code>Response</code>，并调用它们的公共方法，比如拥有<code>Request</code>对象，就可以调用<code>setComet</code>、<code>setRequestedSessionId</code>等方法，这样会危害安全性。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day06</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day06/</url>
    <content><![CDATA[<h1 id="6-行为型模式"><a href="#6-行为型模式" class="headerlink" title="6 , 行为型模式"></a>6 , 行为型模式</h1><h2 id="6-11-解释器模式"><a href="#6-11-解释器模式" class="headerlink" title="6.11 解释器模式"></a>6.11 解释器模式</h2><h3 id="6-11-1-概述"><a href="#6-11-1-概述" class="headerlink" title="6.11.1 概述"></a>6.11.1 概述</h3><img src="/images/design-model-day06/image-20200215220322641.png" style="zoom:60%;">

<p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//用于n个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer ... arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Integer i : arr) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   </p>
<p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p><strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</strong></p>
</blockquote>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p>
<p><strong>文法（语法）规则：</strong></p>
<p>文法是用于描述语言的语法结构的形式规则。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">expression</span> ::= value | plus | minus<br>plus ::= <span class="hljs-keyword">expression</span> ‘+’ <span class="hljs-keyword">expression</span>   <br>minus ::= <span class="hljs-keyword">expression</span> ‘-’ <span class="hljs-keyword">expression</span>  <br>value ::= integer<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p>
</blockquote>
<p>上面规则描述为 ：</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p>
<p><strong>抽象语法树：</strong></p>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>用树形来表示符合文法规则的句子。</p>
<img src="/images/design-model-day06/image-20200215225227616.png" style="zoom:50%;">

<h3 id="6-11-2-结构"><a href="#6-11-2-结构" class="headerlink" title="6.11.2 结构"></a>6.11.2 结构</h3><p>解释器模式包含以下主要角色。</p>
<ul>
<li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p>
</li>
<li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p>
</li>
<li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p>
</li>
<li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p>
</li>
<li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p>
</li>
</ul>
<h3 id="6-11-3-案例实现"><a href="#6-11-3-案例实现" class="headerlink" title="6.11.3 案例实现"></a>6.11.3 案例实现</h3><p>【例】设计实现加减法的软件</p>
<img src="/images/design-model-day06/解释器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象角色AbstractExpression</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//终结符表达式角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(value).toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//非终结符表达式角色  加法表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Plus</span><span class="hljs-params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) + right.interpret(context);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + left.toString() + <span class="hljs-string">&quot; + &quot;</span> + right.toString() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">///非终结符表达式角色 减法表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Minus</span><span class="hljs-params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) - right.interpret(context);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + left.toString() + <span class="hljs-string">&quot; - &quot;</span> + right.toString() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//终结符表达式角色 变量表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Variable</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ctx.getValue(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Variable, Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(Variable <span class="hljs-keyword">var</span>, Integer value)</span> </span>&#123;<br>        map.put(<span class="hljs-keyword">var</span>, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(Variable <span class="hljs-keyword">var</span>)</span> </span>&#123;<br>        Integer value = map.get(<span class="hljs-keyword">var</span>);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br><br>        Variable a = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;a&quot;</span>);<br>        Variable b = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;b&quot;</span>);<br>        Variable c = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;c&quot;</span>);<br>        Variable d = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;d&quot;</span>);<br>        Variable e = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;e&quot;</span>);<br>        <span class="hljs-comment">//Value v = new Value(1);</span><br><br>        context.assign(a, <span class="hljs-number">1</span>);<br>        context.assign(b, <span class="hljs-number">2</span>);<br>        context.assign(c, <span class="hljs-number">3</span>);<br>        context.assign(d, <span class="hljs-number">4</span>);<br>        context.assign(e, <span class="hljs-number">5</span>);<br><br>        AbstractExpression expression = <span class="hljs-keyword">new</span> Minus(<span class="hljs-keyword">new</span> Plus(<span class="hljs-keyword">new</span> Plus(<span class="hljs-keyword">new</span> Plus(a, b), c), d), e);<br><br>        System.out.println(expression + <span class="hljs-string">&quot;= &quot;</span> + expression.interpret(context));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-11-4-优缺点"><a href="#6-11-4-优缺点" class="headerlink" title="6.11.4 优缺点"></a>6.11.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>易于改变和扩展文法。</p>
<p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>
</li>
<li><p>实现文法较为容易。</p>
<p>在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p>
</li>
<li><p>增加新的解释表达式较为方便。</p>
<p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对于复杂文法难以维护。</p>
<p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</p>
</li>
</ul>
<ul>
<li><p>执行效率较低。</p>
<p>由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p>
</li>
</ul>
<h3 id="6-11-5-使用场景"><a href="#6-11-5-使用场景" class="headerlink" title="6.11.5 使用场景"></a>6.11.5 使用场景</h3><ul>
<li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p>
</li>
<li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p>
</li>
<li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p>
</li>
</ul>
<h1 id="7，自定义Spring框架"><a href="#7，自定义Spring框架" class="headerlink" title="7，自定义Spring框架"></a>7，自定义Spring框架</h1><h2 id="7-1-spring使用回顾"><a href="#7-1-spring使用回顾" class="headerlink" title="7.1 spring使用回顾"></a>7.1 spring使用回顾</h2><p>自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。</p>
<ul>
<li><p>数据访问层。定义UserDao接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userDaoImpl ....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>业务逻辑层。定义UserService接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userServiceImpl ...&quot;</span>);<br>        userDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>定义UserController类，使用main方法模拟controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建spring容器对象</span><br>        ApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">//从IOC容器中获取UserService对象</span><br>        UserService userService = applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>        <span class="hljs-comment">//调用UserService对象的add方法</span><br>        userService.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">        http://www.springframework.org/schema/context</span><br><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;<br>        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br><br>    &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<p>代码运行结果如下：</p>
<img src="/images/design-model-day06/image-20200429165544151.png" style="zoom:60%;"></li>
</ul>
<p>通过上面代码及结果可以看出：</p>
<ul>
<li>userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。</li>
<li>上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。</li>
<li>UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。</li>
</ul>
<p>上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）</p>
<h2 id="7-2-spring核心功能结构"><a href="#7-2-spring核心功能结构" class="headerlink" title="7.2 spring核心功能结构"></a>7.2 spring核心功能结构</h2><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p>
<p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：</p>
<img src="/images/design-model-day06/image-20200429111324770.png" style="zoom:40%;">



<p>核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。</p>
<ul>
<li>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。</li>
<li>spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li>
<li>spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。</li>
<li>spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。</li>
<li>spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。</li>
</ul>
<h3 id="7-1-1-bean概述"><a href="#7-1-1-bean概述" class="headerlink" title="7.1.1 bean概述"></a>7.1.1 bean概述</h3><p>Spring 就是面向 <code>Bean</code> 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p>
<p>spring中bean用于对一个类进行封装。如下面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>为什么Bean如此重要呢？</p>
<ul>
<li>spring 将bean对象交由一个叫IOC容器进行管理。</li>
<li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li>
</ul>
<h2 id="7-3-Spring-IOC相关接口分析"><a href="#7-3-Spring-IOC相关接口分析" class="headerlink" title="7.3 Spring IOC相关接口分析"></a>7.3 Spring IOC相关接口分析</h2><h3 id="7-3-1-BeanFactory解析"><a href="#7-3-1-BeanFactory解析" class="headerlink" title="7.3.1 BeanFactory解析"></a>7.3.1 BeanFactory解析</h3><p>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p>
<img src="/images/design-model-day06/image-20200429185050396.png" style="zoom:60%;">

<p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p>
<p>那么为何要定义这么多层次的接口呢？</p>
<p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p>
<ul>
<li>ListableBeanFactory接口表示这些Bean可列表化。</li>
<li>HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><br>	String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>	<span class="hljs-comment">//根据bean的名称获取IOC容器中的的bean对象</span><br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<span class="hljs-comment">//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了</span><br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;<br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;<br><br>	<span class="hljs-comment">//判断容器中是否包含指定名称的bean对象</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br>	<span class="hljs-comment">//根据bean的名称判断是否是单例</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-meta">@Nullable</span><br>	Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>	String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p>
<p>BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p>
<img src="/images/design-model-day06/image-20200430220155371.png" style="zoom:60%;">

<p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p>
<ul>
<li>ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。</li>
<li>FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。</li>
<li>AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。</li>
</ul>
<h3 id="7-3-2-BeanDefinition解析"><a href="#7-3-2-BeanDefinition解析" class="headerlink" title="7.3.2 BeanDefinition解析"></a>7.3.2 BeanDefinition解析</h3><p>Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>bean标签还有很多属性：<br>	scope、init-method、destory-method等。<br></code></pre></td></tr></table></figure>

<p>其继承体系如下图所示。</p>
<img src="/images/design-model-day06/image-20200429204239868.png" style="zoom:60%;">



<h3 id="7-3-3-BeanDefinitionReader解析"><a href="#7-3-3-BeanDefinitionReader解析" class="headerlink" title="7.3.3 BeanDefinitionReader解析"></a>7.3.3 BeanDefinitionReader解析</h3><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p>
<img src="/images/design-model-day06/image-20200429204700956.png" style="zoom:60%;">

<p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>	<span class="hljs-comment">//获取BeanDefinitionRegistry注册器对象</span><br>	<span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		下面的loadBeanDefinitions都是加载bean定义，从指定的资源中</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-3-4-BeanDefinitionRegistry解析"><a href="#7-3-4-BeanDefinitionRegistry解析" class="headerlink" title="7.3.4 BeanDefinitionRegistry解析"></a>7.3.4 BeanDefinitionRegistry解析</h3><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;<br><br>	<span class="hljs-comment">//往注册表中注册bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br><br>	<span class="hljs-comment">//从注册表中删除指定名称的bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-comment">//获取注册表中指定名称的bean</span><br>	<span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <br>	<span class="hljs-comment">//判断注册表中是否已经注册了指定名称的bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;<br>    <br>	<span class="hljs-comment">//获取注册表中所有的bean的名称</span><br>	String[] getBeanDefinitionNames();<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承结构图如下：</p>
<img src="/images/design-model-day06/image-20200429211132185.png" style="zoom:60%;">

<p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p>
<ul>
<li><p>DefaultListableBeanFactory</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>SimpleBeanDefinitionRegistry</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-5-创建容器"><a href="#7-3-5-创建容器" class="headerlink" title="7.3.5 创建容器"></a>7.3.5 创建容器</h3><p>ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。</p>
<h2 id="7-4-自定义SpringIOC"><a href="#7-4-自定义SpringIOC" class="headerlink" title="7.4 自定义SpringIOC"></a>7.4 自定义SpringIOC</h2><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="7-4-1-定义bean相关的pojo类"><a href="#7-4-1-定义bean相关的pojo类" class="headerlink" title="7.4.1 定义bean相关的pojo类"></a>7.4.1 定义bean相关的pojo类</h3><h4 id="7-4-1-1-PropertyValue类"><a href="#7-4-1-1-PropertyValue类" class="headerlink" title="7.4.1.1 PropertyValue类"></a>7.4.1.1 PropertyValue类</h4><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyValue</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String ref;<br>  <span class="hljs-keyword">private</span> String value;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertyValue</span><span class="hljs-params">()</span> </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertyValue</span><span class="hljs-params">(String name, String ref,String value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.ref = ref;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ref;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRef</span><span class="hljs-params">(String ref)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.ref = ref;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-1-2-MutablePropertyValues类"><a href="#7-4-1-2-MutablePropertyValues类" class="headerlink" title="7.4.1.2 MutablePropertyValues类"></a>7.4.1.2 MutablePropertyValues类</h4><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutablePropertyValues</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">PropertyValue</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutablePropertyValues</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValueList = <span class="hljs-keyword">new</span> ArrayList&lt;PropertyValue&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutablePropertyValues</span><span class="hljs-params">(List&lt;PropertyValue&gt; propertyValueList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValueList = (propertyValueList != <span class="hljs-keyword">null</span> ? propertyValueList : <span class="hljs-keyword">new</span> ArrayList&lt;PropertyValue&gt;());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> PropertyValue[] getPropertyValues() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyValueList.toArray(<span class="hljs-keyword">new</span> PropertyValue[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValue <span class="hljs-title">getPropertyValue</span><span class="hljs-params">(String propertyName)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (PropertyValue pv : <span class="hljs-keyword">this</span>.propertyValueList) &#123;<br>            <span class="hljs-keyword">if</span> (pv.getName().equals(propertyName)) &#123;<br>                <span class="hljs-keyword">return</span> pv;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> propertyValueList.iterator();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyValueList.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MutablePropertyValues <span class="hljs-title">addPropertyValue</span><span class="hljs-params">(PropertyValue pv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.propertyValueList.size(); i++) &#123;<br>            PropertyValue currentPv = <span class="hljs-keyword">this</span>.propertyValueList.get(i);<br>            <span class="hljs-keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;<br>                <span class="hljs-keyword">this</span>.propertyValueList.set(i, <span class="hljs-keyword">new</span> PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.propertyValueList.add(pv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String propertyName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPropertyValue(propertyName) != <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-1-3-BeanDefinition类"><a href="#7-4-1-3-BeanDefinition类" class="headerlink" title="7.4.1.3 BeanDefinition类"></a>7.4.1.3 BeanDefinition类</h4><p>BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String className;<br><br>    <span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanDefinition</span><span class="hljs-params">()</span> </span>&#123;<br>        propertyValues = <span class="hljs-keyword">new</span> MutablePropertyValues();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> className;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClassName</span><span class="hljs-params">(String className)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.className = className;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyValues</span><span class="hljs-params">(MutablePropertyValues propertyValues)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValues = propertyValues;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> propertyValues;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-2-定义注册表相关类"><a href="#7-4-2-定义注册表相关类" class="headerlink" title="7.4.2 定义注册表相关类"></a>7.4.2 定义注册表相关类</h3><h4 id="7-4-2-1-BeanDefinitionRegistry接口"><a href="#7-4-2-1-BeanDefinitionRegistry接口" class="headerlink" title="7.4.2.1 BeanDefinitionRegistry接口"></a>7.4.2.1 BeanDefinitionRegistry接口</h4><p>BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：</p>
<ul>
<li>注册BeanDefinition对象到注册表中</li>
<li>从注册表中删除指定名称的BeanDefinition对象</li>
<li>根据名称从注册表中获取BeanDefinition对象</li>
<li>判断注册表中是否包含指定名称的BeanDefinition对象</li>
<li>获取注册表中BeanDefinition对象的个数</li>
<li>获取注册表中所有的BeanDefinition的名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册BeanDefinition对象到注册表中</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span>;<br><br>    <span class="hljs-comment">//从注册表中删除指定名称的BeanDefinition对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">//根据名称从注册表中获取BeanDefinition对象</span><br>    <span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;<br><br>    String[] getBeanDefinitionNames();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-2-2-SimpleBeanDefinitionRegistry类"><a href="#7-4-2-2-SimpleBeanDefinitionRegistry类" class="headerlink" title="7.4.2.2 SimpleBeanDefinitionRegistry类"></a>7.4.2.2 SimpleBeanDefinitionRegistry类</h4><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleBeanDefinitionRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;<br>        beanDefinitionMap.put(beanName,beanDefinition);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        beanDefinitionMap.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.get(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.containsKey(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] getBeanDefinitionNames() &#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-3-定义解析器相关类"><a href="#7-4-3-定义解析器相关类" class="headerlink" title="7.4.3 定义解析器相关类"></a>7.4.3 定义解析器相关类</h3><h4 id="7-4-3-1-BeanDefinitionReader接口"><a href="#7-4-3-1-BeanDefinitionReader接口" class="headerlink" title="7.4.3.1 BeanDefinitionReader接口"></a>7.4.3.1 BeanDefinitionReader接口</h4><p>BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：</p>
<ul>
<li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li>
<li>加载配置文件，并注册bean数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>	<span class="hljs-comment">//获取注册表对象</span><br>    <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-comment">//加载配置文件并在注册表中进行注册</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-3-2-XmlBeanDefinitionReader类"><a href="#7-4-3-2-XmlBeanDefinitionReader类" class="headerlink" title="7.4.3.2 XmlBeanDefinitionReader类"></a>7.4.3.2 XmlBeanDefinitionReader类</h4><p>XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanDefinitionReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BeanDefinitionRegistry registry;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.registry = <span class="hljs-keyword">new</span> SimpleBeanDefinitionRegistry();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> registry;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        InputStream is = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(configLocation);<br>        SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();<br>        Document document = reader.read(is);<br>        Element rootElement = document.getRootElement();<br>        <span class="hljs-comment">//解析bean标签</span><br>        parseBean(rootElement);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBean</span><span class="hljs-params">(Element rootElement)</span> </span>&#123;<br><br>        List&lt;Element&gt; elements = rootElement.elements();<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            String id = element.attributeValue(<span class="hljs-string">&quot;id&quot;</span>);<br>            String className = element.attributeValue(<span class="hljs-string">&quot;class&quot;</span>);<br>            BeanDefinition beanDefinition = <span class="hljs-keyword">new</span> BeanDefinition();<br>            beanDefinition.setId(id);<br>            beanDefinition.setClassName(className);<br>            List&lt;Element&gt; list = element.elements(<span class="hljs-string">&quot;property&quot;</span>);<br>            MutablePropertyValues mutablePropertyValues = <span class="hljs-keyword">new</span> MutablePropertyValues();<br>            <span class="hljs-keyword">for</span> (Element element1 : list) &#123;<br>                String name = element1.attributeValue(<span class="hljs-string">&quot;name&quot;</span>);<br>                String ref = element1.attributeValue(<span class="hljs-string">&quot;ref&quot;</span>);<br>                String value = element1.attributeValue(<span class="hljs-string">&quot;value&quot;</span>);<br>                PropertyValue propertyValue = <span class="hljs-keyword">new</span> PropertyValue(name,ref,value);<br>                mutablePropertyValues.addPropertyValue(propertyValue);<br>            &#125;<br>            beanDefinition.setPropertyValues(mutablePropertyValues);<br><br>            registry.registerBeanDefinition(id,beanDefinition);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-4-IOC容器相关类"><a href="#7-4-4-IOC容器相关类" class="headerlink" title="7.4.4 IOC容器相关类"></a>7.4.4 IOC容器相关类</h3><h4 id="7-4-4-1-BeanFactory接口"><a href="#7-4-4-1-BeanFactory接口" class="headerlink" title="7.4.4.1 BeanFactory接口"></a>7.4.4.1 BeanFactory接口</h4><p>在该接口中定义IOC容器的统一规范即获取bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>	<span class="hljs-comment">//根据bean对象的名称获取bean对象</span><br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>	<span class="hljs-comment">//根据bean对象的名称获取bean对象，并进行类型转换</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-4-2-ApplicationContext接口"><a href="#7-4-4-2-ApplicationContext接口" class="headerlink" title="7.4.4.2 ApplicationContext接口"></a>7.4.4.2 ApplicationContext接口</h4><p>该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 <code>refresh()</code> 方法，该方法主要完成以下两个功能：</p>
<ul>
<li>加载配置文件。</li>
<li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>	<span class="hljs-comment">//进行配置文件加载并进行对象创建</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException, Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-4-3-AbstractApplicationContext类"><a href="#7-4-4-3-AbstractApplicationContext类" class="headerlink" title="7.4.4.3 AbstractApplicationContext类"></a>7.4.4.3 AbstractApplicationContext类</h4><ul>
<li><p>作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p>
</li>
<li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p>
<p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> BeanDefinitionReader beanDefinitionReader;<br>    <span class="hljs-comment">//用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br><br>    <span class="hljs-comment">//存储配置文件的路径</span><br>    <span class="hljs-keyword">protected</span> String configLocation;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException, Exception </span>&#123;<br><br>        <span class="hljs-comment">//加载BeanDefinition</span><br>        beanDefinitionReader.loadBeanDefinitions(configLocation);<br><br>        <span class="hljs-comment">//初始化bean</span><br>        finishBeanInitialization();<br>    &#125;<br><br>    <span class="hljs-comment">//bean的初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();<br>        String[] beanNames = registry.getBeanDefinitionNames();<br><br>        <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);<br>            getBean(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p>
</blockquote>
<h4 id="7-4-4-4-ClassPathXmlApplicationContext类"><a href="#7-4-4-4-ClassPathXmlApplicationContext类" class="headerlink" title="7.4.4.4 ClassPathXmlApplicationContext类"></a>7.4.4.4 ClassPathXmlApplicationContext类</h4><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p>
<ul>
<li>在构造方法中，创建BeanDefinitionReader对象。</li>
<li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li>
<li>重写父接口中的getBean()方法，并实现依赖注入操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.configLocation = configLocation;<br>        <span class="hljs-comment">//构建XmlBeanDefinitionReader对象</span><br>        beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.refresh();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//根据bean的id属性值获取bean对象</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//return singletonObjects.get(name);</span><br>        Object obj = singletonObjects.get(name);<br>        <span class="hljs-keyword">if</span>(obj != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();<br>        BeanDefinition beanDefinition = registry.getBeanDefinition(name);<br>        <span class="hljs-keyword">if</span>(beanDefinition == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        String className = beanDefinition.getClassName();<br>        Class&lt;?&gt; clazz = Class.forName(className);<br>        Object beanObj = clazz.newInstance();<br>        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();<br>        <span class="hljs-keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;<br>            String propertyName = propertyValue.getName();<br>            String value = propertyValue.getValue();<br>            String ref = propertyValue.getRef();<br>            <span class="hljs-keyword">if</span>(ref != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(ref)) &#123;<br><br>                Object bean = getBean(ref);<br>                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);<br>                Method[] methods = clazz.getMethods();<br>                <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>                    <span class="hljs-keyword">if</span>(method.getName().equals(methodName)) &#123;<br>                        method.invoke(beanObj,bean);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(value != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(value)) &#123;<br>                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);<br>                Method method = clazz.getMethod(methodName, String.class);<br>                method.invoke(beanObj,value);<br>            &#125;<br>        &#125;<br>        singletonObjects.put(name,beanObj);<br>        <span class="hljs-keyword">return</span> beanObj;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Object bean = getBean(name);<br>        <span class="hljs-keyword">if</span>(bean != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> clazz.cast(bean);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-5-自定义Spring-IOC总结"><a href="#7-4-5-自定义Spring-IOC总结" class="headerlink" title="7.4.5 自定义Spring IOC总结"></a>7.4.5 自定义Spring IOC总结</h3><h4 id="7-4-5-1-使用到的设计模式"><a href="#7-4-5-1-使用到的设计模式" class="headerlink" title="7.4.5.1 使用到的设计模式"></a>7.4.5.1 使用到的设计模式</h4><ul>
<li>工厂模式。这个使用工厂模式 + 配置文件的方式。</li>
<li>单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。</li>
<li>模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。</li>
<li>迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。</li>
</ul>
<p>spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。</p>
<h4 id="7-4-5-2-符合大部分设计原则"><a href="#7-4-5-2-符合大部分设计原则" class="headerlink" title="7.4.5.2 符合大部分设计原则"></a>7.4.5.2 符合大部分设计原则</h4><h4 id="7-4-5-3-整个设计和Spring的设计还是有一定的出入"><a href="#7-4-5-3-整个设计和Spring的设计还是有一定的出入" class="headerlink" title="7.4.5.3 整个设计和Spring的设计还是有一定的出入"></a>7.4.5.3 整个设计和Spring的设计还是有一定的出入</h4><p>spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：</p>
<ul>
<li>了解Spring底层对对象的大体管理机制。</li>
<li>了解设计模式在具体的开发中的使用。</li>
<li>以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti基础</title>
    <url>/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Activiti7"><a href="#Activiti7" class="headerlink" title="Activiti7"></a>Activiti7</h1><h1 id="一、工作流介绍"><a href="#一、工作流介绍" class="headerlink" title="一、工作流介绍"></a>一、工作流介绍</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>工作流(Workflow)，就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。</p>
<h2 id="1-2-工作流系统"><a href="#1-2-工作流系统" class="headerlink" title="1.2 工作流系统"></a>1.2 工作流系统</h2><p>一个软件系统中具有工作流的功能，我们把它称为工作流系统，一个系统中工作流的功能是什么？就是对系统的业务流程进行自动化管理，所以工作流是建立在业务流程的基础上，所以一个软件的系统核心根本上还是系统的业务流程，工作流只是协助进行业务流程管理。即使没有工作流业务系统也可以开发运行，只不过有了工作流可以更好的管理业务流程，提高系统的可扩展性。</p>
<h2 id="1-3-适用行业"><a href="#1-3-适用行业" class="headerlink" title="1.3 适用行业"></a>1.3 适用行业</h2><p>消费品行业，制造业，电信服务业，银证险等金融服务业，物流服务业，物业服务业，物业管理，大中型进出口贸易公司，政府事业机构，研究院所及教育服务业等，特别是大的跨国企业和集团公司。</p>
<h2 id="1-4-具体应用"><a href="#1-4-具体应用" class="headerlink" title="1.4 具体应用"></a>1.4 具体应用</h2><p>1、关键业务流程：订单、报价处理、合同审核、客户电话处理、供应链管理等</p>
<p>2、行政管理类:出差申请、加班申请、请假申请、用车申请、各种办公用品申请、购买申请、日报周报等凡是原来手工流转处理的行政表单。</p>
<p>3、人事管理类：员工培训安排、绩效考评、职位变动处理、员工档案信息管理等。</p>
<p>4、财务相关类：付款请求、应收款处理、日常报销处理、出差报销、预算和计划申请等。</p>
<p>5、客户服务类：客户信息管理、客户投诉、请求处理、售后服务管理等。</p>
<p>6、特殊服务类：ISO系列对应流程、质量管理对应流程、产品数据信息管理、贸易公司报关处理、物流公司货物跟踪处理等各种通过表单逐步手工流转完成的任务均可应用工作流软件自动规范地实施。</p>
<h2 id="1-5-实现方式"><a href="#1-5-实现方式" class="headerlink" title="1.5 实现方式"></a>1.5 实现方式</h2><p>在没有专门的工作流引擎之前，我们之前为了实现流程控制，通常的做法就是采用状态字段的值来跟踪流程的变化情况。这样不用角色的用户，通过状态字段的取值来决定记录是否显示。</p>
<p> 针对有权限可以查看的记录，当前用户根据自己的角色来决定审批是否合格的操作。如果合格将状态字段设置一个值，来代表合格；当然如果不合格也需要设置一个值来代表不合格的情况。</p>
<p> 这是一种最为原始的方式。通过状态字段虽然做到了流程控制，但是当我们的流程发生变更的时候，这种方式所编写的代码也要进行调整。</p>
<p> 那么有没有专业的方式来实现工作流的管理呢？并且可以做到业务流程变化之后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大提升。</p>
<h1 id="二、Activiti7概述"><a href="#二、Activiti7概述" class="headerlink" title="二、Activiti7概述"></a>二、Activiti7概述</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>Alfresco软件在2010年5月17日宣布Activiti业务流程管理（BPM）开源项目的正式启动，其首席架构师由业务流程管理BPM的专家 Tom Baeyens担任，Tom Baeyens就是原来jbpm的架构师，而jbpm是一个非常有名的工作流引擎，当然activiti也是一个工作流引擎。</p>
<p>Activiti是一个工作流引擎， activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。</p>
<p>官方网站：<a href="https://www.activiti.org/">https://www.activiti.org/</a></p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894539698.jpg" alt="img"></p>
<p>经历的版本:</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894569746.jpg" alt="img"></p>
<p>目前最新版本：Activiti7.0.0.Beta</p>
<h3 id="2-1-1-BPM"><a href="#2-1-1-BPM" class="headerlink" title="2.1.1 BPM"></a>2.1.1 BPM</h3><p>BPM（Business Process Management），即业务流程管理，是一种规范化的构造端到端的业务流程，以持续的提高组织业务效率。常见商业管理教育如EMBA、MBA等均将BPM包含在内。</p>
<h3 id="2-1-2-BPM软件"><a href="#2-1-2-BPM软件" class="headerlink" title="2.1.2 BPM软件"></a>2.1.2 BPM软件</h3><p>BPM软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整合及调整的经营方法与解决方案的IT工具。</p>
<p>通过BPM软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升。</p>
<p>BPM软件在企业中应用领域广泛，凡是有业务流程的地方都可以BPM软件进行管理，比如企业人事办公管理、采购流程管理、公文审批流程管理、财务管理等。</p>
<h3 id="2-1-3-BPMN"><a href="#2-1-3-BPMN" class="headerlink" title="2.1.3 BPMN"></a>2.1.3 BPMN</h3><p>BPMN（Business Process Model AndNotation）- 业务流程模型和符号 是由BPMI（BusinessProcess Management Initiative）开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 </p>
<p>2004年5月发布了BPMN1.0规范.BPMI于2005年9月并入OMG（The Object Management Group对象管理组织)组织。OMG于2011年1月发布BPMN2.0的最终版本。</p>
<p>具体发展历史如下: </p>
<p><img src="/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894913998.jpg" alt="img"></p>
<p>BPMN 是目前被各 BPM 厂商广泛接受的 BPM 标准。Activiti 就是使用 BPMN 2.0 进行流程建模、流程执行管理，它包括很多的建模符号，比如：</p>
<p>Event </p>
<p>用一个圆圈表示，它是流程中运行过程中发生的事情。</p>
<p><img src="/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894954565.jpg" alt="img"></p>
<p>活动用圆角矩形表示，一个流程由一个活动或多个活动组成</p>
<p><img src="/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894978125.jpg" alt="img"></p>
<p>Bpmn图形其实是通过xml表示业务流程，上边的.bpmn文件使用文本编辑器打开：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">definitions</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:activiti</span>=<span class="hljs-string">&quot;http://activiti.org/bpmn&quot;</span> <span class="hljs-attr">xmlns:bpmndi</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="hljs-attr">xmlns:omgdc</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="hljs-attr">xmlns:omgdi</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="hljs-attr">typeLanguage</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">expressionLanguage</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.activiti.org/test&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myProcess&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;My process&quot;</span> <span class="hljs-attr">isExecutable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Start&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;创建请假单&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow1&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;部门经理审核&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow2&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;人事复核&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow3&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;endevent1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;End&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow4&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;endevent1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNDiagram</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNDiagram_myProcess&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNPlane</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;myProcess&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNPlane_myProcess&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_startevent1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;130.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;160.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;210.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;360.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;510.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;endevent1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_endevent1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;660.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;160.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;165.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;210.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;315.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;360.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;465.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;510.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow4&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow4&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;615.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;660.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNPlane</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNDiagram</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">definitions</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 使用步骤"></a>2.2 使用步骤</h2><h3 id="部署activiti"><a href="#部署activiti" class="headerlink" title="部署activiti"></a>部署activiti</h3><p>Activiti是一个工作流引擎（其实就是一堆jar包API），业务系统访问(操作)activiti的接口，就可以方便的操作流程相关数据，这样就可以把工作流环境与业务系统的环境集成在一起。</p>
<h3 id="流程定义"><a href="#流程定义" class="headerlink" title="流程定义"></a>流程定义</h3><p>使用activiti流程建模工具(activity-designer)定义业务流程(.bpmn文件) 。</p>
<p><strong>.bpmn文件就是业务流程定义文件</strong>，通过xml定义业务流程。</p>
<h3 id="流程定义部署"><a href="#流程定义部署" class="headerlink" title="流程定义部署"></a>流程定义部署</h3><p>activiti部署业务流程定义（.bpmn文件）。</p>
<p>使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容</p>
<p><strong>Activiti执行把流程定义内容存储在数据库中</strong></p>
<h3 id="启动一个流程实例"><a href="#启动一个流程实例" class="headerlink" title="启动一个流程实例"></a>启动一个流程实例</h3><p>流程实例也叫：ProcessInstance</p>
<p><strong>启动一个流程实例表示开始一次业务流程的运行。</strong></p>
<p>在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响。</p>
<h3 id="用户查询待办任务-Task"><a href="#用户查询待办任务-Task" class="headerlink" title="用户查询待办任务(Task)"></a>用户查询待办任务(Task)</h3><p>因为现在系统的业务流程已经交给activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写在sql语句查询。</p>
<h3 id="用户办理任务"><a href="#用户办理任务" class="headerlink" title="用户办理任务"></a>用户办理任务</h3><p>用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。</p>
<h3 id="流程结束"><a href="#流程结束" class="headerlink" title="流程结束"></a>流程结束</h3><p>当任务办理完成没有下一个任务结点了，这个流程实例就完成了。</p>
<h1 id="三、Activiti环境"><a href="#三、Activiti环境" class="headerlink" title="三、Activiti环境"></a>三、Activiti环境</h1><h2 id="3-1-开发环境"><a href="#3-1-开发环境" class="headerlink" title="3.1 开发环境"></a>3.1 开发环境</h2><p>Jdk1.8或以上版本</p>
<p>Mysql 5及以上的版本</p>
<p>Tomcat8.5</p>
<p>IDEA</p>
<p><strong>注意：activiti的流程定义工具插件可以安装在IDEA下，也可以安装在Eclipse工具下</strong></p>
<h2 id="3-2-Activiti环境"><a href="#3-2-Activiti环境" class="headerlink" title="3.2 Activiti环境"></a>3.2 Activiti环境</h2><p>我们使用：Activiti7.0.0.Beta1  默认支持spring5</p>
<h3 id="3-2-1-下载activiti7"><a href="#3-2-1-下载activiti7" class="headerlink" title="3.2.1 下载activiti7"></a>3.2.1 下载activiti7</h3><p>Activiti下载地址：<a href="http://activiti.org/download.html">http://activiti.org/download.html</a> ，Maven的依赖如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>1)</strong>      <strong>Database</strong>：</p>
<p>activiti运行需要有数据库的支持，支持的数据库有：h2, mysql, oracle, postgres, mssql, db2。</p>
<h3 id="3-2-2-流程设计器IDEA下安装"><a href="#3-2-2-流程设计器IDEA下安装" class="headerlink" title="3.2.2 流程设计器IDEA下安装"></a>3.2.2 流程设计器IDEA下安装</h3><p>在IDEA的File菜单中找到子菜单”Settings”,后面我们再选择左侧的“plugins”菜单，如下图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574856677.png"></p>
<p>此时我们就可以搜索到actiBPM插件，它就是Activiti Designer的IDEA版本，我们点击Install安装。</p>
<p>安装好后，页面如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574856972.png"></p>
<p>提示需要重启idea，点击重启。</p>
<p>重启完成后，再次打开Settings 下的 Plugins（插件列表），点击右侧的Installed（已安装的插件），在列表中看到actiBPM，就说明已经安装成功了，如下图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574857172.png"></p>
<p>后面的课程里，我们会使用这个流程设计器进行Activiti的流程设计。</p>
<h3 id="3-2-3-Eclipse-activiti-designer插件"><a href="#3-2-3-Eclipse-activiti-designer插件" class="headerlink" title="3.2.3 Eclipse activiti-designer插件"></a>3.2.3 Eclipse activiti-designer插件</h3><h2 id="3-3-Activiti的数据库支持"><a href="#3-3-Activiti的数据库支持" class="headerlink" title="3.3 Activiti的数据库支持"></a>3.3 Activiti的数据库支持</h2><p>Activiti 在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供后续使用。</p>
<h3 id="3-3-1-Activiti-支持的数据库"><a href="#3-3-1-Activiti-支持的数据库" class="headerlink" title="3.3.1 Activiti 支持的数据库"></a>3.3.1 Activiti 支持的数据库</h3><p>activiti  支持的数据库和版本如下：</p>
<table>
<thead>
<tr>
<th>数据库类型</th>
<th>版本</th>
<th>JDBC连接示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h2</td>
<td>1.3.168</td>
<td>jdbc:h2:tcp://localhost/activiti</td>
<td>默认配置的数据库</td>
</tr>
<tr>
<td>mysql</td>
<td>5.1.21</td>
<td>jdbc:mysql://localhost:3306/activiti?autoReconnect=true</td>
<td>使用 mysql-connector-java 驱动测试</td>
</tr>
<tr>
<td>oracle</td>
<td>11.2.0.1.0</td>
<td>jdbc:oracle:thin:@localhost:1521:xe</td>
<td></td>
</tr>
<tr>
<td>postgres</td>
<td>8.1</td>
<td>jdbc:postgresql://localhost:5432/activiti</td>
<td></td>
</tr>
<tr>
<td>db2</td>
<td>DB2 10.1 using db2jcc4</td>
<td>jdbc:db2://localhost:50000/activiti</td>
<td></td>
</tr>
<tr>
<td>mssql</td>
<td>2008 using sqljdbc4</td>
<td>jdbc:sqlserver://localhost:1433/activiti</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-3-2-在MySQL生成表"><a href="#3-3-2-在MySQL生成表" class="headerlink" title="3.3.2 在MySQL生成表"></a>3.3.2 在MySQL生成表</h3><h4 id="3-3-2-1-创建数据库"><a href="#3-3-2-1-创建数据库" class="headerlink" title="3.3.2.1 创建数据库"></a>3.3.2.1 创建数据库</h4><p>创建  mysql  数据库  activiti （名字任意）：</p>
<p>CREATE DATABASE activiti DEFAULT CHARACTER SET utf8;</p>
<h4 id="3-3-2-2-使用java代码生成表"><a href="#3-3-2-2-使用java代码生成表" class="headerlink" title="3.3.2.2 使用java代码生成表"></a>3.3.2.2 使用java代码生成表</h4><h5 id="1）-创建-java-工程"><a href="#1）-创建-java-工程" class="headerlink" title="1） 创建 java 工程"></a>1） 创建 java 工程</h5><p>使用idea 创建 java 的maven工程，取名：activiti01。</p>
<h5 id="2）-加入-maven-依赖的坐标（jar-包）"><a href="#2）-加入-maven-依赖的坐标（jar-包）" class="headerlink" title="2） 加入 maven 依赖的坐标（jar 包）"></a>2） 加入 maven 依赖的坐标（jar 包）</h5><p>首先需要在 java 工程中加入 ProcessEngine 所需要的 jar 包，包括：</p>
<ol>
<li><p>activiti-engine-7.0.0.beta1.jar</p>
</li>
<li><p>activiti 依赖的 jar 包： mybatis、 alf4j、 log4j 等</p>
</li>
<li><p>activiti 依赖的 spring 包</p>
</li>
<li><p>mysql数据库驱动</p>
</li>
<li><p>第三方数据连接池 dbcp</p>
</li>
<li><p>单元测试 Junit-4.12.jar</p>
</li>
</ol>
<p>我们使用 maven 来实现项目的构建，所以应当导入这些 jar 所对应的坐标到 pom.xml 文件中。</p>
<p>完整的依赖内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activiti.version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">activiti.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 模型处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 转换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn json数据转换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 布局 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- activiti 云支持 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 链接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="3）-添加log4j日志配置"><a href="#3）-添加log4j日志配置" class="headerlink" title="3） 添加log4j日志配置"></a>3） 添加log4j日志配置</h5><p>我们使用log4j日志包，可以对日志进行配置</p>
<p>在resources 下创建log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Set root category priority to INFO and its only appender to CONSOLE.</span><br><span class="hljs-comment">#log4j.rootCategory=INFO, CONSOLE debug info warn error fatal</span><br><span class="hljs-meta">log4j.rootCategory</span>=<span class="hljs-string">debug, CONSOLE, LOGFILE</span><br><span class="hljs-comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span><br><span class="hljs-meta">log4j.logger.org.apache.axis.enterprise</span>=<span class="hljs-string">FATAL, CONSOLE</span><br><span class="hljs-comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span><br><span class="hljs-meta">log4j.appender.CONSOLE</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.CONSOLE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.CONSOLE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="hljs-comment"># LOGFILE is set to be a File appender using a PatternLayout.</span><br><span class="hljs-meta">log4j.appender.LOGFILE</span>=<span class="hljs-string">org.apache.log4j.FileAppender</span><br><span class="hljs-meta">log4j.appender.LOGFILE.File</span>=<span class="hljs-string">f:\act\activiti.log</span><br><span class="hljs-meta">log4j.appender.LOGFILE.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.LOGFILE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.LOGFILE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\n</span><br></code></pre></td></tr></table></figure>

<h5 id="4）-添加activiti配置文件"><a href="#4）-添加activiti配置文件" class="headerlink" title="4） 添加activiti配置文件"></a>4） 添加activiti配置文件</h5><p>我们使用activiti提供的默认方式来创建mysql的表。</p>
<p>默认方式的要求是在 resources 下创建 activiti.cfg.xml 文件，注意：默认方式目录和文件名不能修改，因为activiti的源码中已经设置，到固定的目录读取固定文件名的文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="5）-在-activiti-cfg-xml-中进行配置"><a href="#5）-在-activiti-cfg-xml-中进行配置" class="headerlink" title="5） 在 activiti.cfg.xml 中进行配置"></a>5） 在 activiti.cfg.xml 中进行配置</h5><p>默认方式要在在activiti.cfg.xml中bean的名字叫processEngineConfiguration，名字不可修改</p>
<p>在这里有2中配置方式：一种是单独配置数据源，一种是不单独配置数据源</p>
<h6 id="1、直接配置processEngineConfiguration"><a href="#1、直接配置processEngineConfiguration" class="headerlink" title="1、直接配置processEngineConfiguration"></a>1、直接配置processEngineConfiguration</h6><p>processEngineConfiguration 用来创建 ProcessEngine，在创建 ProcessEngine 时会执行数据库的操作。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 默认id对应的值 为processEngineConfiguration --&gt;</span><br>    <span class="hljs-comment">&lt;!-- processEngine Activiti的流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- activiti数据库表处理策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="2、配置数据源后，在processEngineConfiguration-引用"><a href="#2、配置数据源后，在processEngineConfiguration-引用" class="headerlink" title="2、配置数据源后，在processEngineConfiguration 引用"></a>2、配置数据源后，在processEngineConfiguration 引用</h6><p>首先配置数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 这里可以使用 链接池 dbcp--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 引用数据源 上面已经设置好了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- activiti数据库表处理策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="6）-java类编写程序生成表"><a href="#6）-java类编写程序生成表" class="headerlink" title="6） java类编写程序生成表"></a>6） java类编写程序生成表</h5><p>创建一个测试类，调用activiti的工具类，生成acitivti需要的数据库表。</p>
<p>直接使用activiti提供的工具类ProcessEngines，会默认读取classpath下的activiti.cfg.xml文件，读取其中的数据库配置，创建 ProcessEngine，在创建ProcessEngine 时会自动创建表。 </p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.activiti01.test;<br><br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngineConfiguration;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 activiti的数据库表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateDbTable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用classpath下的activiti.cfg.xml中的配置创建processEngine</span><br>		ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		System.out.println(processEngine);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：<br>1、运行以上程序段即可完成 activiti 表创建，通过改变 activiti.cfg.xml 中databaseSchemaUpdate 参数的值执行不同的数据表处理策略。<br>2 、 上 边 的 方法 getDefaultProcessEngine方法在执行时，从activiti.cfg.xml 中找固定的名称 processEngineConfiguration 。</p>
<p>在测试程序执行过程中，idea的控制台会输出日志，说明程序正在创建数据表，类似如下,注意红线内容：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1572852095.png"></p>
<p>执行完成后我们查看数据库， 创建了 25 张表，结果如下： </p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1572852222.png"></p>
<p>到这，我们就完成activiti运行需要的数据库和表的创建。</p>
<h2 id="3-4-表结构介绍"><a href="#3-4-表结构介绍" class="headerlink" title="3.4 表结构介绍"></a>3.4 表结构介绍</h2><h3 id="3-4-1-表的命名规则和作用"><a href="#3-4-1-表的命名规则和作用" class="headerlink" title="3.4.1 表的命名规则和作用"></a>3.4.1 表的命名规则和作用</h3><p>看到刚才创建的表，我们发现Activiti 的表都以   ACT_   开头。 </p>
<p>第二部分是表示表的用途的两个字母标识。 用途也和服务的 API 对应。<br><strong>ACT_RE</strong> ：’RE’表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。<br><strong>ACT_RU</strong>：’RU’表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti 只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。<br><strong>ACT_HI</strong>：’HI’表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。<br> <strong>ACT_GE</strong> ： GE 表示 general。 通用数据， 用于不同场景下 </p>
<h3 id="3-4-2-Activiti数据表介绍"><a href="#3-4-2-Activiti数据表介绍" class="headerlink" title="3.4.2 Activiti数据表介绍"></a>3.4.2 Activiti数据表介绍</h3><table>
<thead>
<tr>
<th><strong>表分类</strong></th>
<th><strong>表名</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一般数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_BYTEARRAY]</td>
<td>通用的流程定义和流程资源</td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_PROPERTY]</td>
<td>系统相关属性</td>
</tr>
<tr>
<td>流程历史记录</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ACTINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ATTACHMENT]</td>
<td>历史的流程附件</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_COMMENT]</td>
<td>历史的说明性信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_DETAIL]</td>
<td>历史的流程运行中的细节信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_IDENTITYLINK]</td>
<td>历史的流程运行过程中用户关系</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_PROCINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_TASKINST]</td>
<td>历史的任务实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_VARINST]</td>
<td>历史的流程运行中的变量信息</td>
</tr>
<tr>
<td>流程定义表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_DEPLOYMENT]</td>
<td>部署单元信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_MODEL]</td>
<td>模型信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_PROCDEF]</td>
<td>已部署的流程定义</td>
</tr>
<tr>
<td>运行实例表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EVENT_SUBSCR]</td>
<td>运行时事件</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EXECUTION]</td>
<td>运行时流程执行实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_IDENTITYLINK]</td>
<td>运行时用户关系信息，存储任务节点与参与者的相关信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_JOB]</td>
<td>运行时作业</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_TASK]</td>
<td>运行时任务</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_VARIABLE]</td>
<td>运行时变量表</td>
</tr>
</tbody></table>
<h1 id="四、Activiti类关系图"><a href="#四、Activiti类关系图" class="headerlink" title="四、Activiti类关系图"></a>四、Activiti类关系图</h1><p>上面我们完成了Activiti数据库表的生成，java代码中我们调用Activiti的工具类，下面来了解Activiti的类关系</p>
<h2 id="4-1-类关系图"><a href="#4-1-类关系图" class="headerlink" title="4.1 类关系图"></a>4.1 类关系图</h2><p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002.jpg" alt="img"></p>
<p>在新版本中，我们通过实验可以发现IdentityService，FormService两个Serivce都已经删除了。</p>
<p>所以后面我们对于这两个Service也不讲解了，但老版本中还是有这两个Service，同学们需要了解一下</p>
<h2 id="4-2-activiti-cfg-xml"><a href="#4-2-activiti-cfg-xml" class="headerlink" title="4.2 activiti.cfg.xml"></a>4.2 activiti.cfg.xml</h2><p>activiti的引擎配置文件，包括：ProcessEngineConfiguration的定义、数据源定义、事务管理器等，此文件其实就是一个spring配置文件。</p>
<h2 id="4-3-流程引擎配置类"><a href="#4-3-流程引擎配置类" class="headerlink" title="4.3 流程引擎配置类"></a>4.3 流程引擎配置类</h2><p>流程引擎的配置类（ProcessEngineConfiguration），通过ProcessEngineConfiguration可以创建工作流引擎ProceccEngine，常用的两种方法如下： </p>
<h3 id="4-3-1-StandaloneProcessEngineConfiguration"><a href="#4-3-1-StandaloneProcessEngineConfiguration" class="headerlink" title="4.3.1 StandaloneProcessEngineConfiguration"></a>4.3.1 StandaloneProcessEngineConfiguration</h3><p>使用StandaloneProcessEngineConfigurationActiviti可以单独运行，来创建ProcessEngine，Activiti会自己处理事务。</p>
<p> 配置文件方式：</p>
<p>通常在activiti.cfg.xml配置文件中定义一个id为 processEngineConfiguration 的bean.</p>
<p>方法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置数据库相关的信息--&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库链接--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库用户名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库密码--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--actviti数据库表在生成时的策略  true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>还可以加入连接池:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在默认方式下 bean的id  固定为 processEngineConfiguration--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入上面配置好的 链接池--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--actviti数据库表在生成时的策略  true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="4-3-2-SpringProcessEngineConfiguration"><a href="#4-3-2-SpringProcessEngineConfiguration" class="headerlink" title="4.3.2 SpringProcessEngineConfiguration"></a>4.3.2 SpringProcessEngineConfiguration</h3><p><strong>通过org.activiti.spring.SpringProcessEngineConfiguration 与==Spring整合==。</strong> </p>
<p>创建spring与activiti的整合配置文件：</p>
<p>activity-spring.cfg.xml（名称可修改）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context </span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop/spring-aop-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/tx </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/tx/spring-tx-3.1.xsd &quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 工作流引擎配置bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- 使用spring事务管理器 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- 数据库策略 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;drop-create&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- activiti的定时任务关闭 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobExecutorActivate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 资源服务service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;repositoryService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRepositoryService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程运行service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;runtimeService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRuntimeService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 任务管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getTaskService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 历史管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;historyService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getHistoryService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用户管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;identityService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getIdentityService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引擎管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;managementService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getManagementService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通知 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 传播行为 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;save*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 切面，根据具体项目修改切点配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span>  <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(* com.itheima.ihrm.service.impl.*.(..))&quot;</span>* /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="创建processEngineConfiguration"><a href="#创建processEngineConfiguration" class="headerlink" title="创建processEngineConfiguration"></a>创建processEngineConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>​    上边的代码要求activiti.cfg.xml中必须有一个processEngineConfiguration的bean</p>
<p>也可以使用下边的方法，更改bean 的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);<br></code></pre></td></tr></table></figure>

<h2 id="4-4-工作流引擎创建"><a href="#4-4-工作流引擎创建" class="headerlink" title="4.4 工作流引擎创建"></a>4.4 工作流引擎创建</h2><p>工作流引擎（ProcessEngine），相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine，通过ProcessEngine创建各个service接口。</p>
<h3 id="4-4-1-默认创建方式"><a href="#4-4-1-默认创建方式" class="headerlink" title="4.4.1 默认创建方式"></a>4.4.1 默认创建方式</h3><p>将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有 processEngineConfiguration的配置， 可以使用如下代码创建processEngine:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接使用工具类 ProcessEngines，使用classpath下的activiti.cfg.xml中的配置创建processEngine</span><br>ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>System.out.println(processEngine);<br></code></pre></td></tr></table></figure>

<h3 id="4-4-2-一般创建方式"><a href="#4-4-2-一般创建方式" class="headerlink" title="4.4.2 一般创建方式"></a>4.4.2 一般创建方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先构建ProcessEngineConfiguration</span><br>ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>);<br><span class="hljs-comment">//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库</span><br>ProcessEngine processEngine = configuration.buildProcessEngine();<br></code></pre></td></tr></table></figure>

<h2 id="4-5-Servcie服务接口"><a href="#4-5-Servcie服务接口" class="headerlink" title="4.5 Servcie服务接口"></a>4.5 Servcie服务接口</h2><p>Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表</p>
<h3 id="4-5-1-Service创建方式"><a href="#4-5-1-Service创建方式" class="headerlink" title="4.5.1 Service创建方式"></a>4.5.1 Service创建方式</h3><p>通过ProcessEngine创建Service</p>
<p>方式如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">RuntimeService runtimeService = processEngine.getRuntimeService();<br>RepositoryService repositoryService = processEngine.getRepositoryService();<br>TaskService taskService = processEngine.getTaskService();<br></code></pre></td></tr></table></figure>

<h3 id="4-5-2-Service总览"><a href="#4-5-2-Service总览" class="headerlink" title="4.5.2 Service总览"></a>4.5.2 Service总览</h3><table>
<thead>
<tr>
<th>service名称</th>
<th>service作用</th>
</tr>
</thead>
<tbody><tr>
<td>RepositoryService</td>
<td>activiti的资源管理类</td>
</tr>
<tr>
<td>RuntimeService</td>
<td>activiti的流程运行管理类</td>
</tr>
<tr>
<td>TaskService</td>
<td>activiti的任务管理类</td>
</tr>
<tr>
<td>HistoryService</td>
<td>activiti的历史管理类</td>
</tr>
<tr>
<td>ManagerService</td>
<td>activiti的引擎管理类</td>
</tr>
</tbody></table>
<p> 简单介绍：</p>
<p><strong>RepositoryService</strong></p>
<p>是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。</p>
<p>除了部署流程定义以外还可以：查询引擎中的发布包和流程定义。</p>
<p>暂停或激活发布包，对应全部和特定流程定义。 暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。获得多种资源，像是包含在发布包里的文件， 或引擎自动生成的流程图。</p>
<p>获得流程定义的pojo版本， 可以用来通过java解析流程，而不必通过xml。</p>
<h4 id="RuntimeService"><a href="#RuntimeService" class="headerlink" title="RuntimeService"></a>RuntimeService</h4><p>Activiti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息</p>
<h4 id="TaskService"><a href="#TaskService" class="headerlink" title="TaskService"></a>TaskService</h4><p>Activiti的任务管理类。可以从这个类中获取任务的信息。</p>
<h4 id="HistoryService"><a href="#HistoryService" class="headerlink" title="HistoryService"></a>HistoryService</h4><p>Activiti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。</p>
<h4 id="ManagementService"><a href="#ManagementService" class="headerlink" title="ManagementService"></a>ManagementService</h4><p>Activiti的引擎管理类，提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。</p>
<h1 id="五、Activiti入门"><a href="#五、Activiti入门" class="headerlink" title="五、Activiti入门"></a>五、Activiti入门</h1><p>在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。</p>
<p>创建Activiti工作流主要包含以下几步：</p>
<p>1、定义流程，按照BPMN的规范，使用流程定义工具，用<strong>流程符号</strong>把整个流程描述出来</p>
<p>2、部署流程，把画好的流程定义文件，加载到数据库中，生成表的数据</p>
<p>3、启动流程，使用java代码来操作数据库表中的内容</p>
<h2 id="5-1-流程符号"><a href="#5-1-流程符号" class="headerlink" title="5.1 流程符号"></a>5.1 流程符号</h2><p>BPMN 2.0是业务流程建模符号2.0的缩写。</p>
<p>它由Business Process Management Initiative这个非营利协会创建并不断发展。作为一种标识，BPMN 2.0是使用一些<strong>符号</strong>来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时的沟通效率。</p>
<p>目前BPMN2.0是最新的版本，它用于在BPM上下文中进行布局和可视化的沟通。</p>
<p>接下来我们先来了解在流程设计中常见的 符号。</p>
<p>BPMN2.0的<strong>基本符合</strong>主要包含：</p>
<h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h3><p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574522151044.png" alt="1574522151044"></p>
<h3 id="活动-Activity"><a href="#活动-Activity" class="headerlink" title="活动 Activity"></a>活动 Activity</h3><p>活动是工作或任务的一个通用术语。一个活动可以是一个任务，还可以是一个当前流程的子处理流程； 其次，你还可以为活动指定不同的类型。常见活动如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574562726375.png" alt="1574562726375"></p>
<h3 id="网关-GateWay"><a href="#网关-GateWay" class="headerlink" title="网关 GateWay"></a>网关 GateWay</h3><p>网关用来处理决策，有几种常用网关需要了解：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574563600305.png" alt="1574563600305"></p>
<h4 id="排他网关-x"><a href="#排他网关-x" class="headerlink" title="排他网关 (x)"></a>排他网关 (x)</h4><p>——只有一条路径会被选择。流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流；</p>
<p>​    如果多条线路计算结果都是 true，则会执行第一个值为 true 的线路。如果所有网关计算结果没有true，则引擎会抛出异常。</p>
<p>​    排他网关需要和条件顺序流结合使用，default 属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。</p>
<h4 id="并行网关"><a href="#并行网关" class="headerlink" title="并行网关 (+)"></a>并行网关 (+)</h4><p>——所有路径会被同时选择</p>
<p>​    拆分 —— 并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。</p>
<p>​    合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。</p>
<h4 id="包容网关"><a href="#包容网关" class="headerlink" title="包容网关 (+)"></a>包容网关 (+)</h4><p>—— 可以同时执行多条线路，也可以在网关上设置条件</p>
<p>​    拆分 —— 计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行线路并继续执行</p>
<p>​    合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。</p>
<h4 id="事件网关"><a href="#事件网关" class="headerlink" title="事件网关 (+)"></a>事件网关 (+)</h4><p>—— 专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。</p>
<h3 id="流向-Flow"><a href="#流向-Flow" class="headerlink" title="流向 Flow"></a>流向 Flow</h3><p>流是连接两个流程节点的连线。常见的流向包含以下几种：</p>
<p><img src="/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/1574563937457.png" alt="1574563937457"></p>
<h2 id="5-2-流程设计器使用"><a href="#5-2-流程设计器使用" class="headerlink" title="5.2 流程设计器使用"></a>5.2 流程设计器使用</h2><h3 id="Activiti-Designer使用"><a href="#Activiti-Designer使用" class="headerlink" title="Activiti-Designer使用"></a>Activiti-Designer使用</h3><h4 id="Palette（画板）"><a href="#Palette（画板）" class="headerlink" title="Palette（画板）"></a>Palette（画板）</h4><p>在idea中安装插件即可使用，画板中包括以下结点：</p>
<p>Connection—连接</p>
<p>Event—事件</p>
<p>Task—任务</p>
<p>Gateway—网关</p>
<p>Container—容器</p>
<p>Boundary event—边界事件</p>
<p>Intermediate event- -中间事件</p>
<p>流程图设计完毕保存生成.bpmn文件</p>
<h4 id="新建流程-IDEA工具"><a href="#新建流程-IDEA工具" class="headerlink" title="新建流程(IDEA工具)"></a>新建流程(IDEA工具)</h4><p>首先选中存放图形的目录(选择resources下的bpmn目录)，点击菜单：New  -&gt; BpmnFile，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575106985823.png" alt="1575106985823"></p>
<p>弹出如下图所示框，输入evection 表示 出差审批流程：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107231004.png" alt="1575107231004"></p>
<p>起完名字evection后（默认扩展名为bpmn），就可以看到流程设计页面，如图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107336431.png" alt="1575107336431"></p>
<p>左侧区域是绘图区，右侧区域是palette画板区域</p>
<p>鼠标先点击画板的元素即可在左侧绘图</p>
<h3 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h3><p>使用滑板来绘制流程，通过从右侧把图标拖拽到左侧的画板，最终效果如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107648105.png" alt="1575107648105"></p>
<h3 id="指定流程定义Key"><a href="#指定流程定义Key" class="headerlink" title="指定流程定义Key"></a>指定流程定义Key</h3><p>流程定义key即流程定义的标识，通过properties视图查看流程的key</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575115474865.png" alt="1575115474865"></p>
<h3 id="指定任务负责人"><a href="#指定任务负责人" class="headerlink" title="指定任务负责人"></a>指定任务负责人</h3><p>在properties视图指定每个任务结点的负责人，如：填写出差申请的负责人为 zhangsan</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575121491752.png" alt="1575121491752"></p>
<p>经理审批负责人为 jerry</p>
<p>总经理审批负责人为 jack</p>
<p>财务审批负责人为 rose</p>
<h1 id="六、流程操作"><a href="#六、流程操作" class="headerlink" title="六、流程操作"></a>六、流程操作</h1><h2 id="6-1-流程定义"><a href="#6-1-流程定义" class="headerlink" title="6.1 流程定义"></a>6.1 流程定义</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>流程定义是线下按照bpmn2.0标准去描述 业务流程，通常使用idea中的插件对业务流程进行建模。</p>
<p>使用idea下的designer设计器绘制流程，并会生成两个文件：.bpmn和.png</p>
<h3 id="bpmn文件"><a href="#bpmn文件" class="headerlink" title=".bpmn文件"></a>.bpmn文件</h3><p>使用activiti-desinger设计业务流程，会生成.bpmn文件，上面我们已经创建好了bpmn文件</p>
<p>BPMN 2.0根节点是definitions节点。 这个元素中，可以定义多个流程定义（不过我们建议每个文件只包含一个流程定义， 可以简化开发过程中的维护难度）。 注意，definitions元素 最少也要包含xmlns 和 targetNamespace的声明。 targetNamespace可以是任意值，它用来对流程实例进行分类。</p>
<p>流程定义部分：定义了流程每个结点的描述及结点之间的流程流转。</p>
<p>流程布局定义：定义流程每个结点在流程图上的位置坐标等信息。</p>
<h3 id="生成-png图片文件"><a href="#生成-png图片文件" class="headerlink" title="生成.png图片文件"></a>生成.png图片文件</h3><p>IDEA工具中的操作方式</p>
<h4 id="1、修改文件后缀为xml"><a href="#1、修改文件后缀为xml" class="headerlink" title="1、修改文件后缀为xml"></a>1、修改文件后缀为xml</h4><p>首先将evection.bpmn文件改名为evection.xml，如下图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575108966935.png" alt="1575108966935"></p>
<p>evection.xml修改前的bpmn文件，效果如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107648105-1618661266829.png" alt="1575107648105"></p>
<h4 id="2、使用designer设计器打开-xml文件"><a href="#2、使用designer设计器打开-xml文件" class="headerlink" title="2、使用designer设计器打开.xml文件"></a>2、使用designer设计器打开.xml文件</h4><p>在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer…</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109268443.png" alt="1575109268443"></p>
<h4 id="3、查看打开的文件"><a href="#3、查看打开的文件" class="headerlink" title="3、查看打开的文件"></a>3、查看打开的文件</h4><p>打开后，却出现乱码，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109366989.png" alt="1575109366989"></p>
<h4 id="4、解决中文乱码"><a href="#4、解决中文乱码" class="headerlink" title="4、解决中文乱码"></a>4、解决中文乱码</h4><p>1、打开Settings，找到File Encodings，把encoding的选项都选择UTF-8</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575112075626.png" alt="1575112075626"></p>
<p>2、打开IDEA安装路径，找到如下的安装目录</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109627745.png" alt="1575109627745"></p>
<p>根据自己所安装的版本来决定，我使用的是64位的idea，所以在idea64.exe.vmoptions文件的最后一行追加一条命令： -Dfile.encoding=UTF-8 </p>
<p>如下所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1618663095939.png" alt="https://images2017.cnblogs.com/blog/963440/201712/963440-20171221132445475-1259807908.png"></p>
<p>一定注意，不要有空格，否则重启IDEA时会打不开，然后 重启IDEA。</p>
<p>如果以上方法已经做完，还出现乱码，就再修改一个文件，并在文件的末尾添加： -Dfile.encoding=UTF-8，然后重启idea，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575113551947.png" alt="1575113551947"></p>
<p>最后重新在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer…，看到生成图片，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575113951966.png" alt="1575113951966"></p>
<p>到此，解决乱码问题</p>
<h4 id="5、导出为图片文件"><a href="#5、导出为图片文件" class="headerlink" title="5、导出为图片文件"></a>5、导出为图片文件</h4><p>点击Export To File的小图标，打开如下窗口，注意填写文件名及扩展名，选择好保存图片的位置：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575114245068.png" alt="1575114245068"></p>
<p>然后，我们把png文件拷贝到resources下的bpmn目录，并且把evection.xml改名为evection.bpmn。</p>
<h2 id="6-2-流程定义部署"><a href="#6-2-流程定义部署" class="headerlink" title="6.2 流程定义部署"></a>6.2 流程定义部署</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>将上面在设计器中定义的流程部署到activiti数据库中，就是流程定义部署。</p>
<p>通过调用activiti的api将流程定义的bpmn和png两个文件一个一个添加部署到activiti中，也可以将两个文件打成zip包进行部署。</p>
<h3 id="单个文件部署方式"><a href="#单个文件部署方式" class="headerlink" title="单个文件部署方式"></a>单个文件部署方式</h3><p>分别将bpmn文件和png图片文件部署。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngines;<br><span class="hljs-keyword">import</span> org.activiti.engine.RepositoryService;<br><span class="hljs-keyword">import</span> org.activiti.engine.repository.Deployment;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 部署流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeployment</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、创建ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、得到RepositoryService实例</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        3、使用RepositoryService进行部署</span><br>        Deployment deployment = repositoryService.createDeployment()<br>                .addClasspathResource(<span class="hljs-string">&quot;bpmn/evection.bpmn&quot;</span>) <span class="hljs-comment">// 添加bpmn资源</span><br>                .addClasspathResource(<span class="hljs-string">&quot;bpmn/evection.png&quot;</span>)  <span class="hljs-comment">// 添加png资源</span><br>                .name(<span class="hljs-string">&quot;出差申请流程&quot;</span>)<br>                .deploy();<br><span class="hljs-comment">//        4、输出部署信息</span><br>        System.out.println(<span class="hljs-string">&quot;流程部署id：&quot;</span> + deployment.getId());<br>        System.out.println(<span class="hljs-string">&quot;流程部署名称：&quot;</span> + deployment.getName());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。</p>
<h3 id="压缩包部署方式"><a href="#压缩包部署方式" class="headerlink" title="压缩包部署方式"></a>压缩包部署方式</h3><p>将evection.bpmn和evection.png压缩成zip包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deployProcessByZip</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 定义zip输入流</span><br>		InputStream inputStream = <span class="hljs-keyword">this</span><br>				.getClass()<br>				.getClassLoader()<br>				.getResourceAsStream(<br>						<span class="hljs-string">&quot;bpmn/evection.zip&quot;</span>);<br>		ZipInputStream zipInputStream = <span class="hljs-keyword">new</span> ZipInputStream(inputStream);<br>		<span class="hljs-comment">// 获取repositoryService</span><br>		RepositoryService repositoryService = processEngine<br>				.getRepositoryService();<br>		<span class="hljs-comment">// 流程部署</span><br>		Deployment deployment = repositoryService.createDeployment()<br>				.addZipInputStream(zipInputStream)<br>				.deploy();<br>		System.out.println(<span class="hljs-string">&quot;流程部署id：&quot;</span> + deployment.getId());<br>		System.out.println(<span class="hljs-string">&quot;流程部署名称：&quot;</span> + deployment.getName());<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。</p>
<h3 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h3><p>流程定义部署后操作activiti的3张表如下：</p>
<p>act_re_deployment     流程定义部署表，每部署一次增加一条记录</p>
<p>act_re_procdef            流程定义表，部署每个新的流程定义都会在这张表中增加一条记录</p>
<p>act_ge_bytearray        流程资源表 </p>
<p>接下来我们来看看，写入了什么数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_re_deployment #流程定义部署表，记录流程部署信息<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116732147.png" alt="1575116732147"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_re_procdef #流程定义表，记录流程定义信息<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p>注意，KEY 这个字段是用来唯一识别不同流程的关键字</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116797665.png" alt="1575116797665"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ge_bytearray #资源表 <br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116832196.png" alt="1575116832196"></p>
<p> 注意：</p>
<p>act_re_deployment和act_re_procdef一对多关系，一次部署在流程部署表生成一条记录，但一次部署可以部署多个流程定义，每个流程定义在流程定义表生成一条记录。每一个流程定义在act_ge_bytearray会存在两个资源记录，bpmn和png。</p>
<p>建议：一次部署一个流程，这样部署表和流程定义表是一对一有关系，方便读取流程部署及流程定义信息。</p>
<h2 id="6-3-启动流程实例"><a href="#6-3-启动流程实例" class="headerlink" title="6.3 启动流程实例"></a>6.3 启动流程实例</h2><p>流程定义部署在activiti后就可以通过工作流管理业务流程了，也就是说上边部署的出差申请流程可以使用了。</p>
<p>针对该流程，启动一个流程表示发起一个新的出差申请单，这就相当于java类与java对象的关系，类定义好后需要new创建一个对象使用，当然可以new多个对象。对于请出差申请流程，张三发起一个出差申请单需要启动一个流程实例，出差申请单发起一个出差单也需要启动一个流程实例。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStartProcess</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、创建ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、获取RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        3、根据流程定义Id启动流程</span><br>        ProcessInstance processInstance = runtimeService<br>                .startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection&quot;</span>);<br><span class="hljs-comment">//        输出内容</span><br>        System.out.println(<span class="hljs-string">&quot;流程定义id：&quot;</span> + processInstance.getProcessDefinitionId());<br>        System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + processInstance.getId());<br>        System.out.println(<span class="hljs-string">&quot;当前活动Id：&quot;</span> + processInstance.getActivityId());<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>输出内容如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575117588624.png" alt="1575117588624"></p>
<p><strong>操作数据表</strong></p>
<p>act_hi_actinst     流程实例执行历史</p>
<p>act_hi_identitylink  流程的参与用户历史信息</p>
<p>act_hi_procinst      流程实例历史信息</p>
<p>act_hi_taskinst       流程任务历史信息</p>
<p>act_ru_execution   流程执行信息</p>
<p>act_ru_identitylink  流程的参与用户信息</p>
<p>act_ru_task              任务信息</p>
<h2 id="6-4-任务查询"><a href="#6-4-任务查询" class="headerlink" title="6.4 任务查询"></a>6.4 任务查询</h2><p>流程启动后，任务的负责人就可以查询自己当前需要处理的任务，查询出来的任务都是该用户的待办任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询当前个人待执行的任务</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        任务负责人</span><br>        String assignee = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        根据流程key 和 任务负责人 查询任务</span><br>        List&lt;Task&gt; list = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>) <span class="hljs-comment">//流程Key</span><br>                .taskAssignee(assignee)<span class="hljs-comment">//只查询该任务负责人的任务</span><br>                .list();<br><br>        <span class="hljs-keyword">for</span> (Task task : list) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>            System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>            System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>            System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">流程实例<span class="hljs-built_in">id</span>：<span class="hljs-number">2501</span><br>任务<span class="hljs-built_in">id</span>：<span class="hljs-number">2505</span><br>任务负责人：zhangsan<br>任务名称：创建出差申请<br></code></pre></td></tr></table></figure>

<h2 id="6-5-流程任务处理"><a href="#6-5-流程任务处理" class="headerlink" title="6.5 流程任务处理"></a>6.5 流程任务处理</h2><p>任务负责人查询待办任务，选择任务进行处理，完成任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 完成任务</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取taskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><br><span class="hljs-comment">//        根据流程key 和 任务的负责人 查询任务</span><br><span class="hljs-comment">//        返回一个任务对象</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>) <span class="hljs-comment">//流程Key</span><br>                .taskAssignee(<span class="hljs-string">&quot;zhangsan&quot;</span>)  <span class="hljs-comment">//要查询的负责人</span><br>                .singleResult();<br><br><span class="hljs-comment">//        完成任务,参数：任务id</span><br>        taskService.complete(task.getId());<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="6-6-流程定义信息查询"><a href="#6-6-流程定义信息查询" class="headerlink" title="6.6 流程定义信息查询"></a>6.6 流程定义信息查询</h2><p>查询流程相关信息，包含流程定义，流程部署，流程定义版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProcessDefinition</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        得到ProcessDefinitionQuery 对象</span><br>        ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();<br><span class="hljs-comment">//          查询出当前所有的流程定义</span><br><span class="hljs-comment">//          条件：processDefinitionKey =evection</span><br><span class="hljs-comment">//          orderByProcessDefinitionVersion 按照版本排序</span><br><span class="hljs-comment">//        desc倒叙</span><br><span class="hljs-comment">//        list 返回集合</span><br>        List&lt;ProcessDefinition&gt; definitionList = processDefinitionQuery.processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>)<br>                .orderByProcessDefinitionVersion()<br>                .desc()<br>                .list();<br><span class="hljs-comment">//      输出流程定义信息</span><br>        <span class="hljs-keyword">for</span> (ProcessDefinition processDefinition : definitionList) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程定义 id=&quot;</span>+processDefinition.getId());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 name=&quot;</span>+processDefinition.getName());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 key=&quot;</span>+processDefinition.getKey());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 Version=&quot;</span>+processDefinition.getVersion());<br>            System.out.println(<span class="hljs-string">&quot;流程部署ID =&quot;</span>+processDefinition.getDeploymentId());<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">流程定<span class="hljs-built_in">义id</span>：myEvection:<span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>流程定义名称：出差申请单<br>流程定<span class="hljs-built_in">义key</span>：myEvection<br>流程定义版本：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<h2 id="6-7-流程删除"><a href="#6-7-流程删除" class="headerlink" title="6.7 流程删除"></a>6.7 流程删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDeployment</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 流程部署id</span><br>		String deploymentId = <span class="hljs-string">&quot;1&quot;</span>;<br>		<br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 通过流程引擎获取repositoryService</span><br>		RepositoryService repositoryService = processEngine<br>				.getRepositoryService();<br>		<span class="hljs-comment">//删除流程定义，如果该流程定义已有流程实例启动则删除时出错</span><br>		repositoryService.deleteDeployment(deploymentId);<br>		<span class="hljs-comment">//设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false非级别删除方式，如果流程</span><br>		<span class="hljs-comment">//repositoryService.deleteDeployment(deploymentId, true);</span><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><pre><code>  使用repositoryService删除流程定义，历史表信息不会被删除
</code></pre>
</li>
<li><pre><code>  如果该流程定义下没有正在运行的流程，则可以用普通删除。
</code></pre>
</li>
</ol>
<p>如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除。</p>
<p>先删除没有完成流程节点，最后就可以完全删除流程定义信息</p>
<p>项目开发中级联删除操作一般只开放给超级管理员使用.</p>
<h2 id="6-8-流程资源下载"><a href="#6-8-流程资源下载" class="headerlink" title="6.8 流程资源下载"></a>6.8 流程资源下载</h2><p>现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中把资源文件下载到本地。</p>
<p>解决方案有：</p>
<p>1、jdbc对blob类型，clob类型数据读取出来，保存到文件目录</p>
<p>2、使用activiti的api来实现</p>
<p>使用commons-io.jar 解决IO的操作</p>
<p>引入commons-io依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>通过流程定义对象获取流程定义资源，获取bpmn和png</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<br><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDeployment</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        根据部署id 删除部署信息,如果想要级联删除，可以添加第二个参数，true</span><br>        repositoryService.deleteDeployment(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">queryBpmnFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//        1、得到引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        3、得到查询器：ProcessDefinitionQuery，设置查询条件,得到想要的流程定义</span><br>        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>)<br>                .singleResult();<br><span class="hljs-comment">//        4、通过流程定义信息，得到部署ID</span><br>        String deploymentId = processDefinition.getDeploymentId();<br><span class="hljs-comment">//        5、通过repositoryService的方法，实现读取图片信息和bpmn信息</span><br><span class="hljs-comment">//        png图片的流</span><br>        InputStream pngInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getDiagramResourceName());<br><span class="hljs-comment">//        bpmn文件的流</span><br>        InputStream bpmnInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getResourceName());<br><span class="hljs-comment">//        6、构造OutputStream流</span><br>        File file_png = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/evectionflow01.png&quot;</span>);<br>        File file_bpmn = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/evectionflow01.bpmn&quot;</span>);<br>        FileOutputStream bpmnOut = <span class="hljs-keyword">new</span> FileOutputStream(file_bpmn);<br>        FileOutputStream pngOut = <span class="hljs-keyword">new</span> FileOutputStream(file_png);<br><span class="hljs-comment">//        7、输入流，输出流的转换</span><br>        IOUtils.copy(pngInput,pngOut);<br>        IOUtils.copy(bpmnInput,bpmnOut);<br><span class="hljs-comment">//        8、关闭流</span><br>        pngOut.close();<br>        bpmnOut.close();<br>        pngInput.close();<br>        bpmnInput.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><pre><code>  deploymentId为流程部署ID
</code></pre>
</li>
<li><pre><code>  resource_name为act_ge_bytearray表中NAME_列的值
</code></pre>
</li>
<li><pre><code>  使用repositoryService的getDeploymentResourceNames方法可以获取指定部署下得所有文件的名称
</code></pre>
</li>
<li><pre><code>  使用repositoryService的getResourceAsStream方法传入部署ID和资源图片名称可以获取部署下指定名称文件的输入流
</code></pre>
</li>
</ol>
<p>最后的将输入流中的图片资源进行输出。</p>
<h2 id="6-9-流程历史信息的查看"><a href="#6-9-流程历史信息的查看" class="headerlink" title="6.9 流程历史信息的查看"></a>6.9 流程历史信息的查看</h2><p>即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在activiti的act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过HistoryService来查看相关的历史记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查看历史信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findHistoryInfo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//      获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取HistoryService</span><br>        HistoryService historyService = processEngine.getHistoryService();<br><span class="hljs-comment">//        获取 actinst表的查询对象</span><br>        HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();<br><span class="hljs-comment">//        查询 actinst表，条件：根据 InstanceId 查询</span><br><span class="hljs-comment">//        instanceQuery.processInstanceId(&quot;2501&quot;);</span><br><span class="hljs-comment">//        查询 actinst表，条件：根据 DefinitionId 查询</span><br>        instanceQuery.processDefinitionId(<span class="hljs-string">&quot;myEvection:1:4&quot;</span>);<br><span class="hljs-comment">//        增加排序操作,orderByHistoricActivityInstanceStartTime 根据开始时间排序 asc 升序</span><br>        instanceQuery.orderByHistoricActivityInstanceStartTime().asc();<br><span class="hljs-comment">//        查询所有内容</span><br>        List&lt;HistoricActivityInstance&gt; activityInstanceList = instanceQuery.list();<br><span class="hljs-comment">//        输出</span><br>        <span class="hljs-keyword">for</span> (HistoricActivityInstance hi : activityInstanceList) &#123;<br>            System.out.println(hi.getActivityId());<br>            System.out.println(hi.getActivityName());<br>            System.out.println(hi.getProcessDefinitionId());<br>            System.out.println(hi.getProcessInstanceId());<br>            System.out.println(<span class="hljs-string">&quot;&lt;==========================&gt;&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti基础</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti进阶</title>
    <url>/2021/04/17/Activiti%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="Activiti进阶"><a href="#Activiti进阶" class="headerlink" title="Activiti进阶"></a>Activiti进阶</h1><h2 id="一、流程实例"><a href="#一、流程实例" class="headerlink" title="一、流程实例"></a>一、流程实例</h2><h3 id="什么是流程实例"><a href="#什么是流程实例" class="headerlink" title="什么是流程实例"></a>什么是流程实例</h3><p><strong>流程实例</strong>（ProcessInstance）代表流程定义的执行实例。</p>
<p>一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息。</p>
<p>例如：用户或程序按照流程定义内容发起一个流程，这就是一个流程实例。</p>
<p>流程定义和流程实例的图解：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577498489089.png" alt="1577498489089"></p>
<h3 id="启动流程实例-并添加Businesskey（业务标识）"><a href="#启动流程实例-并添加Businesskey（业务标识）" class="headerlink" title="启动流程实例 并添加Businesskey（业务标识）"></a>启动流程实例 并添加Businesskey（业务标识）</h3><p>流程定义部署在activiti后，就可以在系统中通过activiti去管理该流程的执行，执行流程表示流程的一次执行。</p>
<p>比如部署系统出差流程后，如果某用户要申请出差这时就需要执行这个流程，如果另外一个用户也要申请出差则也需要执行该流程，每个执行互不影响，每个执行是单独的流程实例。</p>
<p>启动流程实例时，指定的businesskey，就会在act_ru_execution #流程实例的执行表中存储businesskey。</p>
<p>Businesskey：业务标识，通常为业务表的主键，业务标识和流程实例一一对应。业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。</p>
<p>比如：出差流程启动一个流程实例，就可以将出差单的id作为业务标识存储到activiti中，将来查询activiti的流程实例信息就可以获取出差单的id从而关联查询业务系统数据库得到出差单信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例，添加businessKey</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBusinessKey</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、得到ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、得到RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        3、启动流程实例，同时还要指定业务标识businessKey，也就是出差申请单id，这里是1001</span><br>        ProcessInstance processInstance = runtimeService.<br>                startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection&quot;</span>,<span class="hljs-string">&quot;1001&quot;</span>);<br><span class="hljs-comment">//        4、输出processInstance相关属性</span><br>        System.out.println(<span class="hljs-string">&quot;业务id==&quot;</span>+processInstance.getBusinessKey());<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Activiti的act_ru_execution中存储业务标识：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577261568103.png" alt="1577261568103"></p>
<h3 id="操作数据库表"><a href="#操作数据库表" class="headerlink" title="操作数据库表"></a>操作数据库表</h3><p>启动流程实例，操作如下数据库表：</p>
<p>SELECT * FROM act_ru_execution #流程实例执行表，记录当前流程实例的执行情况</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499812252.png" alt="1577499812252"></p>
<p>说明：</p>
<p>流程实例执行，如果当前只有一个分支时，一个流程实例只有一条记录且执行表的主键id和流程实例id相同，如果当前有多个分支正在运行则该执行表中有多条记录，存在执行表的主键和流程实例id不相同的记录。<strong>不论当前有几个分支总会有一条记录的执行表的主键和流程实例</strong>id<strong>相同</strong> </p>
<p>一个流程实例运行完成，此表中与流程实例相关的记录删除。</p>
<p>SELECT * FROM act_ru_task #任务执行表，记录当前执行的任务</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499771599.png" alt="1577499771599"></p>
<p>说明：启动流程实例，流程当前执行到第一个任务结点，此表会插入一条记录表示当前任务的执行情况，如果任务完成则记录删除。</p>
<p>SELECT * FROM act_ru_identitylink #任务参与者，记录当前参与任务的用户或组</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499842115.png" alt="1577499842115"></p>
<p>SELECT * FROM act_hi_procinst #流程实例历史表</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499914186.png" alt="1577499914186"></p>
<p>流程实例启动，会在此表插入一条记录，流程实例运行完成记录也不会删除。</p>
<p> SELECT * FROM act_hi_taskinst  #任务历史表，记录所有任务</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499985580.png" alt="1577499985580"></p>
<p>开始一个任务，不仅在act_ru_task表插入记录，也会在历史任务表插入一条记录，任务历史表的主键就是任务id，任务完成此表记录不删除。</p>
<p> SELECT * FROM act_hi_actinst  #活动历史表，记录所有活动</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577500036347.png" alt="1577500036347"></p>
<p>活动包括任务，所以此表中不仅记录了任务，还记录了流程执行过程的其它活动，比如开始事件、结束事件。</p>
<h3 id="查询流程实例"><a href="#查询流程实例" class="headerlink" title="查询流程实例"></a>查询流程实例</h3><p>流程在运行过程中可以查询流程实例的状态，当前运行结点等信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProcessInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 流程定义key</span><br>		String processDefinitionKey = <span class="hljs-string">&quot;evection&quot;</span>;<br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		<span class="hljs-comment">// 获取RunTimeService</span><br>		RuntimeService runtimeService = processEngine.getRuntimeService();<br>		List&lt;ProcessInstance&gt; list = runtimeService<br>				.createProcessInstanceQuery()<br>				.processDefinitionKey(processDefinitionKey)<span class="hljs-comment">//</span><br>				.list();<br><br>		<span class="hljs-keyword">for</span> (ProcessInstance processInstance : list) &#123;<br>			System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>			System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span><br>					+ processInstance.getProcessInstanceId());<br>			System.out.println(<span class="hljs-string">&quot;所属流程定义id：&quot;</span><br>					+ processInstance.getProcessDefinitionId());<br>			System.out.println(<span class="hljs-string">&quot;是否执行完成：&quot;</span> + processInstance.isEnded());<br>			System.out.println(<span class="hljs-string">&quot;是否暂停：&quot;</span> + processInstance.isSuspended());<br>			System.out.println(<span class="hljs-string">&quot;当前活动标识：&quot;</span> + processInstance.getActivityId());<br>		&#125;<br>	&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="关联BusinessKey"><a href="#关联BusinessKey" class="headerlink" title="关联BusinessKey"></a>关联BusinessKey</h4><p>需求：</p>
<p>在activiti实际应用时，查询流程实例列表时可能要显示出业务系统的一些相关信息，比如：查询当前运行的出差流程列表需要将出差单名称、出差天数等信息显示出来，出差天数等信息在业务系统中存在，而并没有在activiti数据库中存在，所以是无法通过activiti的api查询到出差天数等信息。</p>
<p>实现：</p>
<p>在查询流程实例时，通过businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。</p>
<p>通过下面的代码就可以获取activiti中所对应实例保存的业务Key。而这个业务Key一般都会保存相关联的业务操作表的主键，再通过主键ID去查询业务信息，比如通过出差单的ID，去查询更多的请假信息（出差人，出差时间，出差天数，出差目的地等）</p>
<p>String businessKey = processInstance.getBusinessKey();</p>
<p>在activiti的act_ru_execution表，字段BUSINESS_KEY就是存放业务KEY的。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1574136375409.png" alt="1574136375409"></p>
<h3 id="挂起、激活流程实例"><a href="#挂起、激活流程实例" class="headerlink" title="挂起、激活流程实例"></a>挂起、激活流程实例</h3><p>某些情况可能由于流程变更需要将当前运行的流程暂停而不是直接删除，流程暂停后将不会继续执行。</p>
<h4 id="全部流程实例挂起"><a href="#全部流程实例挂起" class="headerlink" title="全部流程实例挂起"></a>全部流程实例挂起</h4><p>操作流程定义为挂起状态，该流程定义下边所有的流程实例全部暂停：</p>
<p>流程定义为挂起状态该流程定义将不允许启动新的流程实例，同时该流程定义下所有的流程实例将全部挂起暂停执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 全部流程实例挂起与激活</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendAllProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().<br>                processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processDefinition.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processDefinition.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数1 ：流程定义id ，参数2：是否激活，参数3：激活时间</span><br>            repositoryService.activateProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span><br>            );<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数1 ：流程定义id ，参数2：是否暂停，参数3：暂停时间</span><br>            repositoryService.suspendProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="单个流程实例挂起"><a href="#单个流程实例挂起" class="headerlink" title="单个流程实例挂起"></a>单个流程实例挂起</h4><p><strong>操作流程实例对象，针对单个流程执行挂起操作，某个流程实例挂起则此流程不再继续执行，完成该流程实例的当前任务将报异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单个流程实例挂起与激活</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendSingleProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessInstance processInstance = runtimeService.<br>                createProcessInstanceQuery().<br>                processInstanceId(<span class="hljs-string">&quot;15001&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processInstance.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processInstance.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数：流程定义id</span><br>            runtimeService.activateProcessInstanceById(processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数：流程定义id</span><br>            runtimeService.suspendProcessInstanceById( processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试完成个人任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取操作任务的服务 TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务,参数：流程实例id,完成zhangsan的任务</span><br>        Task task = taskService.createTaskQuery()<br>                .processInstanceId(<span class="hljs-string">&quot;15001&quot;</span>)<br>                .taskAssignee(<span class="hljs-string">&quot;rose&quot;</span>)<br>                .singleResult();<br><br><br>        System.out.println(<span class="hljs-string">&quot;流程实例id=&quot;</span>+task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务Id=&quot;</span>+task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人=&quot;</span>+task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称=&quot;</span>+task.getName());<br>        taskService.complete(task.getId());<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="二、个人任务"><a href="#二、个人任务" class="headerlink" title="二、个人任务"></a>二、个人任务</h2><h3 id="2-1、分配任务负责人"><a href="#2-1、分配任务负责人" class="headerlink" title="2.1、分配任务负责人"></a>2.1、分配任务负责人</h3><h4 id="2-1-1、固定分配"><a href="#2-1-1、固定分配" class="headerlink" title="2.1.1、固定分配"></a>2.1.1、固定分配</h4><p>在进行业务流程建模时指定固定的任务负责人， 如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1575121491752.png" alt="1575121491752"></p>
<p>并在 properties 视图中，填写 Assignee 项为任务负责人。 </p>
<h4 id="2-1-2、表达式分配"><a href="#2-1-2、表达式分配" class="headerlink" title="2.1.2、表达式分配"></a>2.1.2、表达式分配</h4><p>由于固定分配方式，任务只管一步一步执行任务，执行到每一个任务将按照 bpmn 的配置去分配任<br>务负责人。 </p>
<h5 id="2-1-2-1、UEL-表达式"><a href="#2-1-2-1、UEL-表达式" class="headerlink" title="2.1.2.1、UEL 表达式"></a>2.1.2.1、UEL 表达式</h5><p>Activiti 使用 UEL 表达式， UEL 是 java EE6 规范的一部分， UEL（Unified Expression Language）即 统一表达式语言， activiti 支持两个 UEL 表达式： UEL-value 和 UEL-method。 </p>
<h6 id="1）UEL-value-定义"><a href="#1）UEL-value-定义" class="headerlink" title="1）UEL-value 定义"></a>1）UEL-value 定义</h6><p>如图： </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503716131.png" alt="1577503716131"></p>
<p>assignee 这个变量是 activiti 的一个流程变量，</p>
<p>或者使用这种方式定义：</p>
<p>如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503804336.png" alt="1577503804336"></p>
<p> user 也是 activiti 的一个流程变量， user.assignee 表示通过调用 user 的 getter 方法获取值。 </p>
<h6 id="2）UEL-method-方式"><a href="#2）UEL-method-方式" class="headerlink" title="2）UEL-method 方式"></a>2）UEL-method 方式</h6><p>如图： </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585972081.png"></p>
<p>userBean 是 spring 容器中的一个 bean，表示调用该 bean 的 getUserId()方法。 </p>
<h6 id="3）UEL-method-与-UEL-value-结合"><a href="#3）UEL-method-与-UEL-value-结合" class="headerlink" title="3）UEL-method 与 UEL-value 结合"></a>3）UEL-method 与 UEL-value 结合</h6><p>再比如：<br>${ldapService.findManagerForEmployee(emp)}<br>ldapService 是 spring 容器的一个 bean，findManagerForEmployee 是该 bean 的一个方法，emp 是 activiti<br>流程变量， emp 作为参数传到 ldapService.findManagerForEmployee 方法中。 </p>
<h6 id="4）其它"><a href="#4）其它" class="headerlink" title="4）其它"></a>4）其它</h6><p>表达式支持解析基础类型、 bean、 list、 array 和 map，也可作为条件判断。<br>如下：<br>${order.price &gt; 100 &amp;&amp; order.price &lt; 250} </p>
<h5 id="2-1-2-2、编写代码配置负责人"><a href="#2-1-2-2、编写代码配置负责人" class="headerlink" title="2.1.2.2、编写代码配置负责人"></a>2.1.2.2、编写代码配置负责人</h5><h6 id="1-定义任务分配流程变量"><a href="#1-定义任务分配流程变量" class="headerlink" title="1)定义任务分配流程变量"></a>1)定义任务分配流程变量</h6><p>如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503716131-1618662529258.png" alt="1577503716131"></p>
<h6 id="2-设置流程变量"><a href="#2-设置流程变量" class="headerlink" title="2)设置流程变量"></a>2)设置流程变量</h6><p>在启动流程实例时设置流程变量，如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置流程负责人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assigneeUEL</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//      获取流程引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取 RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        设置assignee的取值，用户可以在界面上设置流程的执行</span><br>        Map&lt;String,Object&gt; assigneeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee0&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee1&quot;</span>,<span class="hljs-string">&quot;李经理&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee2&quot;</span>,<span class="hljs-string">&quot;王总经理&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee3&quot;</span>,<span class="hljs-string">&quot;赵财务&quot;</span>);<br><span class="hljs-comment">//        启动流程实例，同时还要设置流程定义的assignee的值</span><br>        runtimeService.startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection1&quot;</span>,assigneeMap);<br><span class="hljs-comment">//       输出</span><br>        System.out.println(processEngine.getName());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>执行成功后，可以在act_ru_variable表中看到刚才map中的数据</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585562066-1585562152652.png"></p>
<h5 id="2-1-2-3、注意事项"><a href="#2-1-2-3、注意事项" class="headerlink" title="2.1.2.3、注意事项"></a>2.1.2.3、注意事项</h5><p>由于使用了表达式分配，必须保证在任务执行过程表达式执行成功，比如：<br>某个任务使用了表达式${order.price &gt; 100 &amp;&amp; order.price &lt; 250}，当执行该任务时必须保证 order 在<br>流程变量中存在，否则 activiti 异常。 </p>
<h4 id="2-1-3、监听器分配"><a href="#2-1-3、监听器分配" class="headerlink" title="2.1.3、监听器分配"></a>2.1.3、监听器分配</h4><p>可以使用监听器来完成很多Activiti流程的业务。</p>
<p>在本章我们使用监听器的方式来指定负责人，那么在流程设计时就不需要指定assignee。</p>
<p>任务监听器是发生对应的任务相关事件时执行自定义 java 逻辑 或表达式。<br>任务相当事件包括：  </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577506842889.png" alt="1577506842889"></p>
<p><strong>Event的选项包含</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Create</span>：任务创建后触发<br>Assignment：任务分配后触发<br><span class="hljs-keyword">Delete</span>：任务完成后触发<br><span class="hljs-keyword">All</span>：所有事件发生都触发<br></code></pre></td></tr></table></figure>

<p>定义任务监听类，且类必须实现 org.activiti.engine.delegate.TaskListener 接口 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(DelegateTask delegateTask)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(delegateTask.getName().equals(<span class="hljs-string">&quot;创建出差申请&quot;</span>)&amp;&amp;<br>                delegateTask.getEventName().equals(<span class="hljs-string">&quot;create&quot;</span>))&#123;<br>            <span class="hljs-comment">//这里指定任务负责人</span><br>            delegateTask.setAssignee(<span class="hljs-string">&quot;张三&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>DelegateTask对象的内容如下：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585561653.png"></p>
<h5 id="2-1-3-1、注意事项"><a href="#2-1-3-1、注意事项" class="headerlink" title="2.1.3.1、注意事项"></a>2.1.3.1、注意事项</h5><p>使用监听器分配方式，按照监听事件去执行监听类的 notify 方法，方法如果不能正常执行也会影响<br>任务的执行。 </p>
<h3 id="2-2、查询任务"><a href="#2-2、查询任务" class="headerlink" title="2.2、查询任务"></a>2.2、查询任务</h3><h4 id="查询任务负责人的待办任务"><a href="#查询任务负责人的待办任务" class="headerlink" title="查询任务负责人的待办任务"></a>查询任务负责人的待办任务</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询当前个人待执行的任务</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 流程定义key</span><br>    String processDefinitionKey = <span class="hljs-string">&quot;myEvection1&quot;</span>;<br>    <span class="hljs-comment">// 任务负责人</span><br>    String assignee = <span class="hljs-string">&quot;张三&quot;</span>;<br>    <span class="hljs-comment">// 获取TaskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    List&lt;Task&gt; taskList = taskService.createTaskQuery()<br>    	.processDefinitionKey(processDefinitionKey)<br>    	.includeProcessVariables()<br>        .taskAssignee(assignee)<br>        .list();<br>    <span class="hljs-keyword">for</span> (Task task : taskList) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;流程实例id： &quot;</span> + task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务id： &quot;</span> + task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人： &quot;</span> + task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称： &quot;</span> + task.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="关联-businessKey"><a href="#关联-businessKey" class="headerlink" title="关联 businessKey"></a>关联 businessKey</h4><p>需求：<br>在 activiti 实际应用时，查询待办任务可能要显示出业务系统的一些相关信息。</p>
<p>比如：查询待审批出差任务列表需要将出差单的日期、 出差天数等信息显示出来。</p>
<p>出差天数等信息在业务系统中存在，而并没有在 activiti 数据库中存在，所以是无法通过 activiti 的 api 查询到出差天数等信息。<br>实现：<br>在查询待办任务时，通过 businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        获取RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection1&quot;</span>)<br>                .taskAssignee(<span class="hljs-string">&quot;张三&quot;</span>)<br>                .singleResult();<br><span class="hljs-comment">//        使用task对象获取实例id</span><br>        String processInstanceId = task.getProcessInstanceId();<br><span class="hljs-comment">//          使用实例id，获取流程实例对象</span><br>        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()<br>                .processInstanceId(processInstanceId)<br>                .singleResult();<br><span class="hljs-comment">//        使用processInstance，得到 businessKey</span><br>        String businessKey = processInstance.getBusinessKey();<br><br>        System.out.println(<span class="hljs-string">&quot;businessKey==&quot;</span>+businessKey);<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-3、办理任务"><a href="#2-3、办理任务" class="headerlink" title="2.3、办理任务"></a>2.3、办理任务</h3><p>注意：在实际应用中，完成任务前需要校验任务的负责人是否具有该任务的办理权限 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String taskId = <span class="hljs-string">&quot;15005&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br>        <span class="hljs-comment">//获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>        <span class="hljs-comment">// 创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .taskId(taskId)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            taskService.complete(taskId);<br>            System.out.println(<span class="hljs-string">&quot;完成任务&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="三、流程变量"><a href="#三、流程变量" class="headerlink" title="三、流程变量"></a>三、流程变量</h2><h3 id="3-1、什么是流程变量"><a href="#3-1、什么是流程变量" class="headerlink" title="3.1、什么是流程变量"></a>3.1、什么是流程变量</h3><p>流程变量在 activiti 中是一个非常重要的角色，流程运转有时需要靠流程变量，业务系统和 activiti<br>结合时少不了流程变量，流程变量就是 activiti 在管理工作流时根据管理需要而设置的变量。<br>比如：在出差申请流程流转时如果出差天数大于 3 天则由总经理审核，否则由人事直接审核， 出差天<br>数就可以设置为流程变量，在流程流转时使用。 </p>
<p><strong>注意：虽然流程变量中可以存储业务数据可以通过activiti的api查询流程变量从而实现 查询业务数据，但是不建议这样使用，因为业务数据查询由业务系统负责，activiti设置流程变量是为了流程执行需要而创建。</strong></p>
<h3 id="3-2、流程变量类型"><a href="#3-2、流程变量类型" class="headerlink" title="3.2、流程变量类型"></a>3.2、流程变量类型</h3><p>如果将 pojo 存储到流程变量中，必须实现序列化接口 serializable，为了防止由于新增字段无<br>法反序列化，需要生成 serialVersionUID。 </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/20190731150933695.png"></p>
<h3 id="3-3、流程变量作用域"><a href="#3-3、流程变量作用域" class="headerlink" title="3.3、流程变量作用域"></a>3.3、流程变量作用域</h3><p>流程变量的作用域可以是一个流程实例(processInstance)，或一个任务(task)，或一个执行实例<br>(execution)</p>
<h4 id="3-3-1、globa变量"><a href="#3-3-1、globa变量" class="headerlink" title="3.3.1、globa变量"></a>3.3.1、globa变量</h4><p>流程变量的默认作用域是流程实例。当一个流程变量的作用域为流程实例时，可以称为 global 变量</p>
<p>注意：</p>
<p>如：    Global变量：userId（变量名）、zhangsan（变量值）</p>
<p>global 变量中变量名不允许重复，设置相同名称的变量，后设置的值会覆盖前设置的变量值。</p>
<h4 id="3-3-2、local变量"><a href="#3-3-2、local变量" class="headerlink" title="3.3.2、local变量"></a>3.3.2、local变量</h4><p>任务和执行实例仅仅是针对一个任务和一个执行实例范围，范围没有流程实例大， 称为 local 变量。</p>
<p>Local 变量由于在不同的任务或不同的执行实例中，作用域互不影响，变量名可以相同没有影响。Local 变量名也可以和 global 变量名相同，没有影响。 </p>
<h3 id="3-4、流程变量的使用方法"><a href="#3-4、流程变量的使用方法" class="headerlink" title="3.4、流程变量的使用方法"></a>3.4、流程变量的使用方法</h3><h4 id="3-4-1、在属性上使用UEL表达式"><a href="#3-4-1、在属性上使用UEL表达式" class="headerlink" title="3.4.1、在属性上使用UEL表达式"></a>3.4.1、在属性上使用UEL表达式</h4><p>可以在 assignee 处设置 UEL 表达式，表达式的值为任务的负责人，比如： ${assignee}， assignee 就是一个流程变量名称。</p>
<p>Activiti获取UEL表达式的值，即流程变量assignee的值 ，将assignee的值作为任务的负责人进行任务分配</p>
<h4 id="3-4-2、在连线上使用UEL表达式"><a href="#3-4-2、在连线上使用UEL表达式" class="headerlink" title="3.4.2、在连线上使用UEL表达式"></a>3.4.2、在连线上使用UEL表达式</h4><p>可以在连线上设置UEL表达式，决定流程走向。</p>
<p>比如：${price&lt;10000} 。price就是一个流程变量名称，uel表达式结果类型为布尔类型。</p>
<p>如果UEL表达式是true，要决定 流程执行走向。</p>
<h3 id="3-5、使用Global变量控制流程"><a href="#3-5、使用Global变量控制流程" class="headerlink" title="3.5、使用Global变量控制流程"></a>3.5、使用Global变量控制流程</h3><h4 id="3-5-1、需求"><a href="#3-5-1、需求" class="headerlink" title="3.5.1、需求"></a>3.5.1、需求</h4><p>员工创建出差申请单，由部门经理审核，部门经理审核通过后出差3天及以下由人财务直接审批，3天以上先由总经理审核，总经理审核通过再由财务审批。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847570736.png" alt="1577847570736"></p>
<h4 id="3-5-2、流程定义"><a href="#3-5-2、流程定义" class="headerlink" title="3.5.2、流程定义"></a>3.5.2、流程定义</h4><p>1）、出差天数大于等于3连线条件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847654279.png" alt="1577847654279"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847695723.png" alt="1577847695723"></p>
<p>也可以使用对象参数命名，如evection.num：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870487533.png" alt="1577870487533"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870510159.png" alt="1577870510159"></p>
<p>2）、出差天数小于3连线条件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847740055.png" alt="1577847740055"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847766231.png" alt="1577847766231"></p>
<p>也可以使用对象参数命名，如：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870638264.png" alt="1577870638264"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870654033.png" alt="1577870654033"></p>
<h4 id="3-5-3、设置global流程变量"><a href="#3-5-3、设置global流程变量" class="headerlink" title="3.5.3、设置global流程变量"></a>3.5.3、设置global流程变量</h4><p>在部门经理审核前设置流程变量，变量值为出差单信息（包括出差天数），部门经理审核后可以根据流程变量的值决定流程走向。</p>
<p>在设置流程变量时，可以在启动流程时设置，也可以在任务办理时设置</p>
<h5 id="3-5-3-1、创建POJO对象"><a href="#3-5-3-1、创建POJO对象" class="headerlink" title="3.5.3.1、创建POJO对象"></a>3.5.3.1、创建POJO对象</h5><p>创建出差申请pojo对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.demo.pojo;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 出差申请 pojo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差申请单名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String evectionName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Double num;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 预计开始时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date beginDate;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 预计结束时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date endDate;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 目的地</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String destination;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差事由</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String reson;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEvectionName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> evectionName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEvectionName</span><span class="hljs-params">(String evectionName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.evectionName = evectionName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBeginDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beginDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeginDate</span><span class="hljs-params">(Date beginDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.beginDate = beginDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getEndDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> endDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEndDate</span><span class="hljs-params">(Date endDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.endDate = endDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDestination</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> destination;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDestination</span><span class="hljs-params">(String destination)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.destination = destination;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getReson</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reson;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReson</span><span class="hljs-params">(String reson)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.reson = reson;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum</span><span class="hljs-params">(Double num)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="3-5-3-2、启动流程时设置变量"><a href="#3-5-3-2、启动流程时设置变量" class="headerlink" title="3.5.3.2、启动流程时设置变量"></a>3.5.3.2、启动流程时设置变量</h5><p>在启动流程时设置流程变量，变量的作用域是整个流程实例。</p>
<p>通过Map&lt;key,value&gt;设置流程变量，map中可以设置多个变量，这个key就是流程变量的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例,设置流程变量的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startProcess</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取流程引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        流程定义key</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//       创建变量集合</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置出差天数</span><br>        evection.setNum(<span class="hljs-number">2d</span>);<br><span class="hljs-comment">//      定义流程变量，把出差pojo对象放入map</span><br>        map.put(<span class="hljs-string">&quot;evection&quot;</span>,evection);<br><span class="hljs-comment">//      设置assignee的取值，用户可以在界面上设置流程的执行</span><br>        map.put(<span class="hljs-string">&quot;assignee0&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee1&quot;</span>,<span class="hljs-string">&quot;李经理&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee2&quot;</span>,<span class="hljs-string">&quot;王总经理&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee3&quot;</span>,<span class="hljs-string">&quot;赵财务&quot;</span>);<br><span class="hljs-comment">//        启动流程实例，并设置流程变量的值（把map传入）</span><br>        ProcessInstance processInstance = runtimeService<br>                .startProcessInstanceByKey(key, map);<br><span class="hljs-comment">//      输出</span><br>        System.out.println(<span class="hljs-string">&quot;流程实例名称=&quot;</span>+processInstance.getName());<br>        System.out.println(<span class="hljs-string">&quot;流程定义id==&quot;</span>+processInstance.getProcessDefinitionId());<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br>        <span class="hljs-comment">//获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>        <span class="hljs-comment">// 创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(key)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            taskService.complete(task.getId());<br>            System.out.println(<span class="hljs-string">&quot;任务执行完成&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>startProcessInstanceByKey(processDefinitionKey, variables)</p>
<p>流程变量作用域是一个流程实例，流程变量使用Map存储，同一个流程实例设置变量map中key相同，后者覆盖前者。</p>
<h5 id="3-5-3-2、任务办理时设置变量"><a href="#3-5-3-2、任务办理时设置变量" class="headerlink" title="3.5.3.2、任务办理时设置变量"></a>3.5.3.2、任务办理时设置变量</h5><p>在完成任务时设置流程变量，该流程变量只有在该任务完成后其它结点才可使用该变量，它的作用域是整个流程实例，如果设置的流程变量的key在流程实例中已存在相同的名字则后设置的变量替换前边设置的变量。</p>
<p>这里需要在创建出差单任务完成时设置流程变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-comment">//       获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//       创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//       创建变量集合</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置出差天数</span><br>        evection.setNum(<span class="hljs-number">2d</span>);<br><span class="hljs-comment">//      定义流程变量</span><br>        map.put(<span class="hljs-string">&quot;evection&quot;</span>,evection);<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(key)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//完成任务是，设置流程变量的值</span><br>            taskService.complete(task.getId(),map);<br>            System.out.println(<span class="hljs-string">&quot;任务执行完成&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>通过当前任务设置流程变量，需要指定当前任务id，如果当前执行的任务id不存在则抛出异常。</p>
<p>任务办理时也是通过map&lt;key,value&gt;设置流程变量，一次可以设置多个变量。</p>
<h5 id="3-5-3-3、通过当前流程实例设置"><a href="#3-5-3-3、通过当前流程实例设置" class="headerlink" title="3.5.3.3、通过当前流程实例设置"></a>3.5.3.3、通过当前流程实例设置</h5><p>通过流程实例id设置全局变量，该流程实例必须未执行完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGlobalVariableByExecutionId</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    当前流程实例执行 id，通常设置为当前执行的流程实例</span><br>        String executionId=<span class="hljs-string">&quot;2601&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置天数</span><br>        evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">//      通过流程实例 id设置流程变量</span><br>        runtimeService.setVariable(executionId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//      一次设置多个值</span><br><span class="hljs-comment">//      runtimeService.setVariables(executionId, variables)</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>executionId必须当前未结束 流程实例的执行id，通常此id设置流程实例 的id。也可以通runtimeService.getVariable()获取流程变量。</p>
<h5 id="3-5-3-4、通过当前任务设置"><a href="#3-5-3-4、通过当前任务设置" class="headerlink" title="3.5.3.4、通过当前任务设置"></a>3.5.3.4、通过当前任务设置</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGlobalVariableByTaskId</span><span class="hljs-params">()</span></span>&#123;<br>		<br>		<span class="hljs-comment">//当前待办任务id</span><br>		String taskId=<span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		TaskService taskService = processEngine.getTaskService();<br>		Evection evection = <span class="hljs-keyword">new</span> Evection();<br>		evection.setNum(<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">//通过任务设置流程变量</span><br>		taskService.setVariable(taskId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br>		<span class="hljs-comment">//一次设置多个值 </span><br>		<span class="hljs-comment">//taskService.setVariables(taskId, variables)</span><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>任务id必须是当前待办任务id，act_ru_task中存在。如果该任务已结束，会报错</p>
<p>也可以通过taskService.getVariable()获取流程变量。</p>
<h4 id="3-5-4、测试"><a href="#3-5-4、测试" class="headerlink" title="3.5.4、测试"></a>3.5.4、测试</h4><p>正常测试：</p>
<p>​       设置流程变量的值大于等于3天</p>
<p>​       设计流程变量的值小于3天</p>
<p>异常测试：</p>
<p>​       流程变量不存在</p>
<p>​       流程变量的值为空NULL，price属性为空</p>
<p>​       UEL表达式都不符合条件  </p>
<p>​      不设置连线的条件</p>
<h4 id="3-5-5、注意事项"><a href="#3-5-5、注意事项" class="headerlink" title="3.5.5、注意事项"></a>3.5.5、注意事项</h4><p>1、  如果UEL表达式中流程变量名不存在则报错。</p>
<p>2、  如果UEL表达式中流程变量值为空NULL，流程不按UEL表达式去执行，而流程结束 。</p>
<p>3、  如果UEL表达式都不符合条件，流程结束 </p>
<p>4、  <strong>==如果连线不设置条件，会走flow序号小的那条线==</strong></p>
<h4 id="3-5-6、操作数据库表"><a href="#3-5-6、操作数据库表" class="headerlink" title="3.5.6、操作数据库表"></a>3.5.6、操作数据库表</h4><p>设置流程变量会在当前执行流程变量表插入记录，同时也会在历史流程变量表也插入记录。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前流程变量表<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_variable <br></code></pre></td></tr></table></figure>

<p>记录当前运行流程实例可使用的流程变量，包括 global和local变量</p>
<p>Id_：主键</p>
<p>Type_：变量类型</p>
<p>Name_：变量名称 </p>
<p>Execution_id_：所属流程实例执行id，global和local变量都存储</p>
<p>Proc_inst_id_：所属流程实例id，global和local变量都存储 </p>
<p>Task_id_：所属任务id，local变量存储</p>
<p>Bytearray_：serializable类型变量存储对应act_ge_bytearray表的id</p>
<p>Double_：double类型变量值</p>
<p>Long_：long类型变量值</p>
<p>Text_：text类型变量值 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"> #历史流程变量表<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_hi_varinst <br></code></pre></td></tr></table></figure>

<p>记录所有已创建的流程变量，包括 global和local变量</p>
<p>字段意义参考当前流程变量表。</p>
<h3 id="3-6、设置local流程变量"><a href="#3-6、设置local流程变量" class="headerlink" title="3.6、设置local流程变量"></a>3.6、设置local流程变量</h3><h4 id="3-6-1、任务办理时设置"><a href="#3-6-1、任务办理时设置" class="headerlink" title="3.6.1、任务办理时设置"></a>3.6.1、任务办理时设置</h4><p> 任务办理时设置local流程变量，当前运行的流程实例只能在该任务结束前使用，任务结束该变量无法在当前流程实例使用，可以通过查询历史任务查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*处理任务时设置local流程变量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">//任务id</span><br>   String taskId = <span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//  获取processEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//  定义流程变量</span><br>   Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>   Evection evection = <span class="hljs-keyword">new</span> Evection ();<br>   evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">// 定义流程变量</span><br>   Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br><span class="hljs-comment">//  变量名是holiday，变量值是holiday对象</span><br>    variables.put(<span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//  设置local变量，作用域为该任务</span><br>    taskService.setVariablesLocal(taskId, variables);<br><span class="hljs-comment">//  完成任务</span><br>   taskService.complete(taskId);<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​       说明：</p>
<p>设置作用域为任务的local变量，每个任务可以设置同名的变量，互不影响。</p>
<h4 id="3-6-2、通过当前任务设置"><a href="#3-6-2、通过当前任务设置" class="headerlink" title="3.6.2、通过当前任务设置"></a>3.6.2、通过当前任务设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalVariableByTaskId</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//   当前待办任务id</span><br>    String taskId=<span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//  获取processEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    TaskService taskService = processEngine.getTaskService();<br>    Evection evection = <span class="hljs-keyword">new</span> Evection ();<br>    evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">//  通过任务设置流程变量</span><br>    taskService.setVariableLocal(taskId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//  一次设置多个值 </span><br>    <span class="hljs-comment">//taskService.setVariablesLocal(taskId, variables)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>任务id必须是当前待办任务id，act_ru_task中存在。</p>
<h4 id="3-6-3、-Local变量测试1"><a href="#3-6-3、-Local变量测试1" class="headerlink" title="3.6.3、  Local变量测试1"></a>3.6.3、  Local变量测试1</h4><p>如果上边例子中设置global变量改为设置local变量是否可行？为什么？</p>
<p> Local变量在任务结束后无法在当前流程实例执行中使用，如果后续的流程执行需要用到此变量则会报错。</p>
<h4 id="3-6-4、-Local变量测试2"><a href="#3-6-4、-Local变量测试2" class="headerlink" title="3.6.4、  Local变量测试2"></a>3.6.4、  Local变量测试2</h4><p>在部门经理审核、总经理审核、财务审核时设置local变量，可通过historyService查询每个历史任务时将流程变量的值也查询出来。</p>
<p> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建历史任务查询对象</span><br>      HistoricTaskInstanceQuery historicTaskInstanceQuery = historyService.createHistoricTaskInstanceQuery();<br>      <span class="hljs-comment">// 查询结果包括 local变量</span><br>      historicTaskInstanceQuery.includeTaskLocalVariables();<br><span class="hljs-keyword">for</span> (HistoricTaskInstance historicTaskInstance : list) &#123;<br>         System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + historicTaskInstance.getId());<br>         System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + historicTaskInstance.getName());<br>         System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + historicTaskInstance.getAssignee());<br>     System.out.println(<span class="hljs-string">&quot;任务local变量：&quot;</span>+ historicTaskInstance.getTaskLocalVariables());<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：查询历史流程变量，特别是查询pojo变量需要经过反序列化，不推荐使用。</p>
<h2 id="四、组任务"><a href="#四、组任务" class="headerlink" title="四、组任务"></a>四、组任务</h2><h3 id="4-1、需求"><a href="#4-1、需求" class="headerlink" title="4.1、需求"></a>4.1、需求</h3><p>在流程定义中在任务结点的 assignee 固定设置任务负责人，在流程定义时将参与者固定设置在.bpmn 文件中，如果临时任务负责人变更则需要修改流程定义，系统可扩展性差。</p>
<p>针对这种情况可以给任务设置多个候选人，可以从候选人中选择参与者来完成任务。 </p>
<h3 id="4-2、设置任务候选人"><a href="#4-2、设置任务候选人" class="headerlink" title="4.2、设置任务候选人"></a>4.2、设置任务候选人</h3><p>在流程图中任务节点的配置中设置 candidate-users(候选人)，多个候选人之间用逗号分开。 </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577878753288.png" alt="1577878753288"></p>
<p>查看bpmn文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">activiti:candidateUsers</span>=<span class="hljs-string">&quot;lisi,wangwu&quot;</span> <span class="hljs-attr">activiti:exclusive</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;_3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;经理审批&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们可以看到部门经理的审核人已经设置为 lisi,wangwu 这样的一组候选人，可以使用</p>
<p>activiti:candiateUsers=”用户 1,用户 2,用户 3”的这种方式来实现设置一组候选人 </p>
<h3 id="4-3、组任务"><a href="#4-3、组任务" class="headerlink" title="4.3、组任务"></a>4.3、组任务</h3><h4 id="4-3-1、组任务办理流程"><a href="#4-3-1、组任务办理流程" class="headerlink" title="4.3.1、组任务办理流程"></a>4.3.1、组任务办理流程</h4><h5 id="a、查询组任务"><a href="#a、查询组任务" class="headerlink" title="a、查询组任务"></a>a、查询组任务</h5><p>指定候选人，查询该候选人当前的待办任务。</p>
<p>候选人不能立即办理任务。</p>
<h5 id="b、拾取-claim-任务"><a href="#b、拾取-claim-任务" class="headerlink" title="b、拾取(claim)任务"></a>b、拾取(claim)任务</h5><p>该组任务的所有候选人都能拾取。</p>
<p>将候选人的组任务，变成个人任务。原来候选人就变成了该任务的负责人。</p>
<p>如果拾取后不想办理该任务？</p>
<p>   需要将已经拾取的个人任务归还到组里边，将个人任务变成了组任务。</p>
<h5 id="c、查询个人任务"><a href="#c、查询个人任务" class="headerlink" title="c、查询个人任务"></a>c、查询个人任务</h5><p>查询方式同个人任务部分，根据assignee查询用户负责的个人任务。</p>
<h5 id="d、办理个人任务"><a href="#d、办理个人任务" class="headerlink" title="d、办理个人任务"></a>d、办理个人任务</h5><h4 id="4-3-2、-查询组任务"><a href="#4-3-2、-查询组任务" class="headerlink" title="4.3.2、  查询组任务"></a>4.3.2、  查询组任务</h4><p> 根据候选人查询组任务</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findGroupTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">// 流程定义key</span><br>       String processDefinitionKey = <span class="hljs-string">&quot;evection3&quot;</span>;<br>       <span class="hljs-comment">// 任务候选人</span><br>       String candidateUser = <span class="hljs-string">&quot;lisi&quot;</span>;<br>        <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       <span class="hljs-comment">// 创建TaskService</span><br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">//查询组任务</span><br>       List&lt;Task&gt; list = taskService.createTaskQuery()<br>              .processDefinitionKey(processDefinitionKey)<br>              .taskCandidateUser(candidateUser)<span class="hljs-comment">//根据候选人查询</span><br>              .list();<br>       <span class="hljs-keyword">for</span> (Task task : list) &#123;<br>           System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>           System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>           System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>           System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>           System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-3-3-、-拾取组任务"><a href="#4-3-3-、-拾取组任务" class="headerlink" title="4.3.3 、 拾取组任务"></a>4.3.3 、 拾取组任务</h4><p> 候选人员拾取组任务后该任务变为自己的个人任务。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">claimTask</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">//要拾取的任务id</span><br>       String taskId = <span class="hljs-string">&quot;6302&quot;</span>;<br>       <span class="hljs-comment">//任务候选人id</span><br>       String userId = <span class="hljs-string">&quot;lisi&quot;</span>;<br>       <span class="hljs-comment">//拾取任务</span><br>       <span class="hljs-comment">//即使该用户不是候选人也能拾取(建议拾取时校验是否有资格)    </span><br>       <span class="hljs-comment">//校验该用户有没有拾取任务的资格</span><br>       Task task = taskService.createTaskQuery()<br>              .taskId(taskId)<br>              .taskCandidateUser(userId)<span class="hljs-comment">//根据候选人查询</span><br>              .singleResult();<br>       <span class="hljs-keyword">if</span>(task!=<span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-comment">//拾取任务</span><br>           taskService.claim(taskId, userId);<br>           System.out.println(<span class="hljs-string">&quot;任务拾取成功&quot;</span>);<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：即使该用户不是候选人也能拾取，建议拾取时校验是否有资格</p>
<p>组任务拾取后，该任务已有负责人，通过候选人将查询不到该任务</p>
<h4 id="4-3-4、-查询个人待办任务"><a href="#4-3-4、-查询个人待办任务" class="headerlink" title="4.3.4、  查询个人待办任务"></a>4.3.4、  查询个人待办任务</h4><p> 查询方式同个人任务查询</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 流程定义key</span><br>    String processDefinitionKey = <span class="hljs-string">&quot;evection1&quot;</span>;<br>    <span class="hljs-comment">// 任务负责人</span><br>    String assignee = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>     <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 创建TaskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    List&lt;Task&gt; list = taskService.createTaskQuery()<br>        .processDefinitionKey(processDefinitionKey)<br>        .taskAssignee(assignee)<br>        .list();<br>    <span class="hljs-keyword">for</span> (Task task : list) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-3-5、-办理个人任务"><a href="#4-3-5、-办理个人任务" class="headerlink" title="4.3.5、  办理个人任务"></a>4.3.5、  办理个人任务</h4><p>同个人任务办理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/*完成任务*/</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completeTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//     任务ID</span><br>      String taskId = <span class="hljs-string">&quot;12304&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>      processEngine.getTaskService()<br>                   .complete(taskId);<br>      System.out.println(<span class="hljs-string">&quot;完成任务：&quot;</span>+taskId);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>说明：建议完成任务前校验该用户是否是该任务的负责人。</p>
<h4 id="4-3-6、-归还组任务"><a href="#4-3-6、-归还组任务" class="headerlink" title="4.3.6、  归还组任务"></a>4.3.6、  归还组任务</h4><p> 如果个人不想办理该组任务，可以归还组任务，归还后该用户不再是该任务的负责人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*归还组任务，由个人任务变为组任务，还可以进行任务交接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAssigneeToGroupTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>   <span class="hljs-comment">// 查询任务使用TaskService</span><br>   TaskService taskService = processEngine.getTaskService();<br>   <span class="hljs-comment">// 当前待办任务</span><br>   String taskId = <span class="hljs-string">&quot;6004&quot;</span>;<br>   <span class="hljs-comment">// 任务负责人</span><br>   String userId = <span class="hljs-string">&quot;zhangsan2&quot;</span>;<br>    <span class="hljs-comment">// 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务</span><br>   Task task = taskService<br>       .createTaskQuery()<br>       .taskId(taskId)<br>       .taskAssignee(userId)<br>       .singleResult();<br>    <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-comment">// 如果设置为null，归还组任务,该 任务没有负责人</span><br>       taskService.setAssignee(taskId, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 说明：建议归还任务前校验该用户是否是该任务的负责人</p>
<p>也可以通过setAssignee方法将任务委托给其它用户负责，注意被委托的用户可以不是候选人（建议不要这样使用）</p>
<h4 id="4-3-7、-任务交接"><a href="#4-3-7、-任务交接" class="headerlink" title="4.3.7、  任务交接"></a>4.3.7、  任务交接</h4><p>任务交接,任务负责人将任务交给其它候选人办理该任务</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAssigneeToCandidateUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       <span class="hljs-comment">// 查询任务使用TaskService</span><br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">// 当前待办任务</span><br>       String taskId = <span class="hljs-string">&quot;6004&quot;</span>;<br>       <span class="hljs-comment">// 任务负责人</span><br>       String userId = <span class="hljs-string">&quot;zhangsan2&quot;</span>;<br><span class="hljs-comment">// 将此任务交给其它候选人办理该 任务</span><br>           String candidateuser = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>       <span class="hljs-comment">// 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务</span><br>       Task task = taskService<br>           .createTaskQuery()<br>           .taskId(taskId)<br>           .taskAssignee(userId)<br>           .singleResult();<br>       <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>           taskService.setAssignee(taskId, candidateuser);<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-3-8、-数据库表操作"><a href="#4-3-8、-数据库表操作" class="headerlink" title="4.3.8、  数据库表操作"></a>4.3.8、  数据库表操作</h4><p>查询当前任务执行表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_task <br></code></pre></td></tr></table></figure>

<p>任务执行表，记录当前执行的任务，由于该任务当前是组任务，所有assignee为空，当拾取任务后该字段就是拾取用户的id</p>
<p>查询任务参与者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_identitylink<br></code></pre></td></tr></table></figure>

<p> 任务参与者，记录当前参考任务用户或组，当前任务如果设置了候选人，会向该表插入候选人记录，有几个候选就插入几个</p>
<p>与act_ru_identitylink对应的还有一张历史表act_hi_identitylink，向act_ru_identitylink插入记录的同时也会向历史表插入记录。任务完成</p>
<h2 id="五、网关"><a href="#五、网关" class="headerlink" title="五、网关"></a>五、网关</h2><p>网关用来控制流程的流向</p>
<h3 id="5-1-排他网关ExclusiveGateway"><a href="#5-1-排他网关ExclusiveGateway" class="headerlink" title="5.1 排他网关ExclusiveGateway"></a>5.1 排他网关ExclusiveGateway</h3><h4 id="5-1-1-什么是排他网关："><a href="#5-1-1-什么是排他网关：" class="headerlink" title="5.1.1  什么是排他网关："></a>5.1.1  什么是排他网关：</h4><p>排他网关，用来在流程中实现决策。 当流程执行到这个网关，所有分支都会判断条件是否为true，如果为true则执行该分支，</p>
<p><strong>注意</strong>：**==排他网关只会选择一个为true的分支执行。如果有两个分支条件都为true，排他网关会选择id值较小的一条分支去执行，如果条件都为false，则抛出异常==**。</p>
<p>为什么要用排他网关？</p>
<p>不用排他网关也可以实现分支，如：在连线的condition条件上设置分支条件。</p>
<p><strong>在连线设置condition条件的缺点：如果条件都不满足，流程就结束了(是异常结束)。</strong></p>
<p>如果 使用排他网关决定分支的走向，如下：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577879740282.png" alt="1577879740282"></p>
<p>如果从网关出去的线所有条件都不满足则系统抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway <span class="hljs-string">&#x27;exclusivegateway1&#x27;</span> could be selected <span class="hljs-keyword">for</span> continuing the process<br>   at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:<span class="hljs-number">85</span>)<br><br></code></pre></td></tr></table></figure>



<h4 id="5-1-2-流程定义"><a href="#5-1-2-流程定义" class="headerlink" title="5.1.2  流程定义"></a>5.1.2  流程定义</h4><p> 排他网关图标，红框内：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577879961637.png" alt="1577879961637"></p>
<h4 id="5-1-3-测试"><a href="#5-1-3-测试" class="headerlink" title="5.1.3  测试"></a>5.1.3  测试</h4><p>在部门经理审核后，走排他网关，从排他网关出来的分支有两条，一条是判断出差天数是否大于3天，另一条是判断出差天数是否小于等于3天。</p>
<p>设置分支条件时，如果所有分支条件都不是true，报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway <span class="hljs-string">&#x27;exclusivegateway1&#x27;</span> could be selected <span class="hljs-keyword">for</span> continuing the process<br><br>       at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:<span class="hljs-number">85</span>)<br><br></code></pre></td></tr></table></figure>

<h3 id="5-2-并行网关ParallelGateway"><a href="#5-2-并行网关ParallelGateway" class="headerlink" title="5.2 并行网关ParallelGateway"></a>5.2 并行网关ParallelGateway</h3><h4 id="5-2-1-什么是并行网关"><a href="#5-2-1-什么是并行网关" class="headerlink" title="5.2.1  什么是并行网关"></a>5.2.1  什么是并行网关</h4><p>并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的：</p>
<p>l  fork分支：</p>
<p> 并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。</p>
<p>l  join汇聚： </p>
<p>所有到达并行网关，在此等待的进入分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。</p>
<p>注意，如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。</p>
<p><strong>与其他网关的主要区别是，并行网关不会解析条件。</strong> <strong>即使顺序流中定义了条件，也会被忽略。</strong></p>
<p>例子：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586679201.png"></p>
<p>说明：</p>
<p>技术经理和项目经理是两个execution分支，在act_ru_execution表有两条记录分别是技术经理和项目经理，act_ru_execution还有一条记录表示该流程实例。</p>
<p>待技术经理和项目经理任务全部完成，在汇聚点汇聚，通过parallelGateway并行网关。</p>
<p>并行网关在业务应用中常用于会签任务，会签任务即多个参与者共同办理的任务。</p>
<h4 id="5-2-2-流程定义"><a href="#5-2-2-流程定义" class="headerlink" title="5.2.2  流程定义"></a>5.2.2  流程定义</h4><p>并行网关图标，红框内：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577880020127.png" alt="1577880020127"></p>
<h4 id="5-2-3-测试"><a href="#5-2-3-测试" class="headerlink" title="5.2.3  测试"></a>5.2.3  测试</h4><p>当执行到并行网关数据库跟踪如下：</p>
<p>当前任务表：SELECT * FROM act_ru_task   </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680533.png"></p>
<p>上图中：有两个任务当前执行。</p>
<p>查询流程实例执行表：SELECT * FROM act_ru_execution </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680570.png"></p>
<p>上图中，说明当前流程实例有多个分支(两个)在运行。</p>
<p>对并行任务的执行：</p>
<p>并行任务执行不分前后，由任务的负责人去执行即可。</p>
<p>执行技术经理任务后，查询当前任务表 SELECT * FROM act_ru_task   </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680672.png"></p>
<p>已完成的技术经理任务在当前任务表act_ru_task_已被删除。</p>
<p>在流程实例执行表：SELECT * FROM act_ru_execution有中多个分支存在且有并行网关的汇聚结点。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680728.png"></p>
<p>有并行网关的汇聚结点：说明有一个分支已经到汇聚，等待其它的分支到达。</p>
<p>当所有分支任务都完成，都到达汇聚结点后：</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution，执行流程实例已经变为总经理审批，说明流程执行已经通过并行网关</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680801.png"></p>
<p>总结：所有分支到达汇聚结点，并行网关执行完成。         </p>
<h3 id="5-3-包含网关InclusiveGateway"><a href="#5-3-包含网关InclusiveGateway" class="headerlink" title="5.3    包含网关InclusiveGateway"></a>5.3    包含网关InclusiveGateway</h3><h4 id="5-3-1-什么是包含网关"><a href="#5-3-1-什么是包含网关" class="headerlink" title="5.3.1  什么是包含网关"></a>5.3.1  什么是包含网关</h4><p>包含网关可以看做是排他网关和并行网关的结合体。 </p>
<p>和排他网关一样，你可以在外出顺序流上定义条件，包含网关会解析它们。 <strong>但是主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。</strong></p>
<p>包含网关的功能是基于进入和外出顺序流的：</p>
<p>l  分支： </p>
<p>所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。</p>
<p>l  汇聚：</p>
<p> 所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。 这是与并行网关的最大不同。换句话说，<strong>包含网关只会等待被选中执行了的进入顺序流。 在汇聚之后，流程会穿过包含网关继续执行。</strong></p>
<h4 id="5-3-2-流程定义："><a href="#5-3-2-流程定义：" class="headerlink" title="5.3.2  流程定义："></a>5.3.2  流程定义：</h4><p>出差申请大于等于3天需要由项目经理审批，小于3天由技术经理审批，出差申请必须经过人事经理审批。</p>
<p> 包含网关图标，红框内：</p>
<p> <img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577880080004.png" alt="1577880080004"></p>
<p>定义流程：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586689674.png"></p>
<p>注意：通过包含网关的每个分支的连线上设置condition条件。</p>
<h4 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3  测试"></a>5.3.3  测试</h4><p>如果包含网关设置的条件中，流程变量不存在，报错;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: Unknown property used in expression: $&#123;evection.num&gt;=<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>

<p>需要在流程启动时设置流程变量evection.num。</p>
<p>1）、当流程执行到第一个包含网关后，会根据条件判断，当前要走哪几个分支：</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586676678.png"></p>
<p>第一条记录：包含网关分支。</p>
<p>后两条记录代表两个要执行的分支：</p>
<p>ACT_ID = “_13” 代表 项目经理神品</p>
<p>ACT_ID = “_5” 代表 人事经理审批</p>
<p>当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586676828.png"></p>
<p>上图中，项目经理审批、人事经理审批 都是当前的任务，在并行执行。</p>
<p>如果有一个分支执行先走到汇聚结点的分支，要等待其它执行分支走到汇聚。</p>
<p>2）、先执行项目经理审批，然后查询当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677325.png"></p>
<p>当前任务还有人事经理审批需要处理。</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677432.png"></p>
<p>发现人事经理的分支还存在，而项目经理分支已经走到ACT_ID = _18的节点。而ACT_ID=__18就是第二个包含网关</p>
<p>这时，因为有2个分支要执行，包含网关会等所有分支走到汇聚才能执行完成。</p>
<p>3）、执行人事经理审批</p>
<p>然后查询当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677665.png"></p>
<p>当前任务表已经不是人事经理审批了，说明人事经理审批已经完成。 </p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677735.png"></p>
<p>包含网关执行完成，分支和汇聚就从act_ru_execution删除。</p>
<p>小结：在分支时，需要判断条件，<strong>符合条件的分支，将会执行</strong>，符合条件的分支最终才进行汇聚。</p>
<h3 id="5-4-事件网关EventGateway"><a href="#5-4-事件网关EventGateway" class="headerlink" title="5.4 事件网关EventGateway"></a>5.4 事件网关EventGateway</h3><p>事件网关允许根据事件判断流向。网关的每个外出顺序流都要连接到一个中间捕获事件。 当流程到达一个基于事件网关，网关会进入等待状态：会暂停执行。与此同时，会为每个外出顺序流创建相对的事件订阅。</p>
<p>事件网关的外出顺序流和普通顺序流不同，这些顺序流不会真的”执行”， 相反它们让流程引擎去决定执行到事件网关的流程需要订阅哪些事件。 要考虑以下条件：</p>
<ol>
<li>事件网关必须有两条或以上外出顺序流；</li>
<li>事件网关后，只能使用intermediateCatchEvent类型（activiti不支持基于事件网关后连接ReceiveTask）</li>
<li>连接到事件网关的中间捕获事件必须只有一个入口顺序流。 </li>
</ol>
<h4 id="5-4-1流程定义"><a href="#5-4-1流程定义" class="headerlink" title="5.4.1流程定义"></a>5.4.1流程定义</h4><p>事件网关图标，红框内</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586666799.png" alt="1586666799"></p>
<p>intermediateCatchEvent：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586667342.png"></p>
<p>intermediateCatchEvent支持的事件类型：</p>
<p>Message Event: 消息事件</p>
<p>Singal Event：  信号事件</p>
<p>Timer Event：  定时事件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586667220.png"></p>
<p>使用事件网关定义流程：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586694673.png"></p>
<h3 id="5-5-排他、并行、包含网关的区别"><a href="#5-5-排他、并行、包含网关的区别" class="headerlink" title="5.5 排他、并行、包含网关的区别"></a>5.5 排他、并行、包含网关的区别</h3><h4 id="5-5-1-排他网关："><a href="#5-5-1-排他网关：" class="headerlink" title="5.5.1 排他网关："></a>5.5.1 排他网关：</h4><p>​    只有一个分支为true能执行，如果都为true，则执行flowid娇小的那个分支，如果都为false，则报错异常结束</p>
<h4 id="5-5-2-并行网关"><a href="#5-5-2-并行网关" class="headerlink" title="5.5.2 并行网关:"></a>5.5.2 并行网关:</h4><p>​    允许有多个fork分支进入（此时在连线上无论true，flase都会执行，即连线判断无效），等待所有分支join汇聚后才尽心下一步操作。</p>
<h4 id="5-5-3-包含网关"><a href="#5-5-3-包含网关" class="headerlink" title="5.5.3  包含网关:"></a>5.5.3  包含网关:</h4><p>​    允许有多个fork分支进入（此时在连线上判断条件是true或者无设置条件的都会执行），等待所有分支join汇聚后才尽心下一步操作。</p>
]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day05</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day05/</url>
    <content><![CDATA[<h1 id="6，行为型模式"><a href="#6，行为型模式" class="headerlink" title="6，行为型模式"></a>6，行为型模式</h1><h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h2><h3 id="6-5-1-概述"><a href="#6-5-1-概述" class="headerlink" title="6.5.1 概述"></a>6.5.1 概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/状态模式前.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILift</span> </span>&#123;<br>    <span class="hljs-comment">//电梯的4个状态</span><br>    <span class="hljs-comment">//开门状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> OPENING_STATE = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//关门状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CLOSING_STATE = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//运行状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> RUNNING_STATE = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//停止状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> STOPPING_STATE = <span class="hljs-number">4</span>;<br><br><br>    <span class="hljs-comment">//电梯的动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lift</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ILift</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> state;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-comment">//执行关门动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯关门了。。。&quot;</span>);<span class="hljs-comment">//只有开门状态可以关闭电梯门，可以对应电梯状态表来看</span><br>                <span class="hljs-keyword">this</span>.setState(CLOSING_STATE);<span class="hljs-comment">//关门之后电梯就是关闭状态了</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<br>                <span class="hljs-comment">//do nothing //已经是关门状态，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing //运行时电梯门是关着的，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                <span class="hljs-comment">//do nothing //停止时电梯也是关着的，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行开门动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<span class="hljs-comment">//门已经开了，不能再开门了</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//关门状态，门打开:</span><br>                System.out.println(<span class="hljs-string">&quot;电梯门打开了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(OPENING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing 运行时电梯不能开门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯门开了。。。&quot;</span>);<span class="hljs-comment">//电梯停了，可以开门了</span><br>                <span class="hljs-keyword">this</span>.setState(OPENING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行运行动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<span class="hljs-comment">//电梯不能开着门就走</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//门关了，可以运行了</span><br>                System.out.println(<span class="hljs-string">&quot;电梯开始运行了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(RUNNING_STATE);<span class="hljs-comment">//现在是运行状态</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing 已经是运行状态了</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯开始运行了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(RUNNING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行停止动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE: <span class="hljs-comment">//开门的电梯已经是是停止的了(正常情况下)</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//关门时才可以停止</span><br>                System.out.println(<span class="hljs-string">&quot;电梯停止了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(STOPPING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<span class="hljs-comment">//运行时当然可以停止了</span><br>                System.out.println(<span class="hljs-string">&quot;电梯停止了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(STOPPING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Lift lift = <span class="hljs-keyword">new</span> Lift();<br>        lift.setState(ILift.STOPPING_STATE);<span class="hljs-comment">//电梯是停止的</span><br>        lift.open();<span class="hljs-comment">//开门</span><br>        lift.close();<span class="hljs-comment">//关门</span><br>        lift.run();<span class="hljs-comment">//运行</span><br>        lift.stop();<span class="hljs-comment">//停止</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题分析：</p>
<ul>
<li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li>
<li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li>
</ul>
<p><strong>定义：</strong></p>
<p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h3 id="6-5-2-结构"><a href="#6-5-2-结构" class="headerlink" title="6.5.2 结构"></a>6.5.2 结构</h3><p>状态模式包含以下主要角色。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ul>
<h3 id="6-5-3-案例实现"><a href="#6-5-3-案例实现" class="headerlink" title="6.5.3 案例实现"></a>6.5.3 案例实现</h3><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p>
<img src="/images/设计模式-day05/状态模式.png" style="zoom:70%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiftState</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span><br>    <span class="hljs-keyword">protected</span> Context context;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContext</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-comment">//电梯开门动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯关门动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯运行动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯停止动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//开启状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯门开启...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.closeingState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().close();<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门不能开着就跑，这里什么也不做</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//开门状态已经是停止的了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关闭？这是肯定了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//这是在运行状态下要实现的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯正在运行...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.stoppingState);<br>        <span class="hljs-keyword">super</span>.context.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//停止状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoppingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//停止状态，开门，那是要的！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.openningState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.closeingState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().close();<br>    &#125;<br><br>    <span class="hljs-comment">//停止状态再跑起来，正常的很</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.runningState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().run();<br>    &#125;<br><br>    <span class="hljs-comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯停止了...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//关闭状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClosingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//电梯门关闭，这是关闭状态要实现的动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯门关闭...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.openningState);<br>        <span class="hljs-keyword">super</span>.context.open();<br>    &#125;<br><br><br>    <span class="hljs-comment">//电梯门关了就跑，这是再正常不过了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.runningState);<br>        <span class="hljs-keyword">super</span>.context.run();<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关着，我就不按楼层</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.stoppingState);<br>        <span class="hljs-keyword">super</span>.context.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//环境角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-comment">//定义出所有的电梯状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> OpenningState openningState = <span class="hljs-keyword">new</span> OpenningState();<span class="hljs-comment">//开门状态，这时候电梯只能关闭</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ClosingState closeingState = <span class="hljs-keyword">new</span> ClosingState();<span class="hljs-comment">//关闭状态，这时候电梯可以运行、停止和开门</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RunningState runningState = <span class="hljs-keyword">new</span> RunningState();<span class="hljs-comment">//运行状态，这时候电梯只能停止</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> StoppingState stoppingState = <span class="hljs-keyword">new</span> StoppingState();<span class="hljs-comment">//停止状态，这时候电梯可以开门、运行</span><br><br><br>    <span class="hljs-comment">//定义一个当前电梯状态</span><br>    <span class="hljs-keyword">private</span> LiftState liftState;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiftState <span class="hljs-title">getLiftState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.liftState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLiftState</span><span class="hljs-params">(LiftState liftState)</span> </span>&#123;<br>        <span class="hljs-comment">//当前环境改变</span><br>        <span class="hljs-keyword">this</span>.liftState = liftState;<br>        <span class="hljs-comment">//把当前的环境通知到各个实现类中</span><br>        <span class="hljs-keyword">this</span>.liftState.setContext(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.open();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.run();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setLiftState(<span class="hljs-keyword">new</span> ClosingState());<br><br>        context.open();<br>        context.close();<br>        context.run();<br>        context.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-5-4-优缺点"><a href="#6-5-4-优缺点" class="headerlink" title="6.5.4 优缺点"></a>6.5.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好。</li>
</ul>
<h3 id="6-5-5-使用场景"><a href="#6-5-5-使用场景" class="headerlink" title="6.5.5 使用场景"></a>6.5.5 使用场景</h3><ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h3 id="6-5-6-菜鸟教程：策略模式和状态模式的区别"><a href="#6-5-6-菜鸟教程：策略模式和状态模式的区别" class="headerlink" title="6.5.6 菜鸟教程：策略模式和状态模式的区别"></a>6.5.6 菜鸟教程：策略模式和状态模式的区别</h3><p>​    1、策略模式:更侧重于选中客户端哪种策略,不同策略对应不同操作</p>
<p>​    2、状态模式:侧重于客户端无需知道内部状态，<strong>对象状态可以自行流转</strong>，且不同状态不同操作结果，</p>
<p>​        客户端不需要清楚状态的改变，它只用调用状态的方法就行</p>
<p>​    <a href="https://www.runoob.com/w3cnote/state-vs-strategy.html">https://www.runoob.com/w3cnote/state-vs-strategy.html</a> </p>
<h2 id="6-6-观察者模式"><a href="#6-6-观察者模式" class="headerlink" title="6.6 观察者模式"></a>6.6 观察者模式</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1 概述"></a>6.6.1 概述</h3><p><strong>定义：</strong></p>
<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<h3 id="6-6-2-结构"><a href="#6-6-2-结构" class="headerlink" title="6.6.2 结构"></a>6.6.2 结构</h3><p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<h3 id="6-6-3-案例实现"><a href="#6-6-3-案例实现" class="headerlink" title="6.6.3 案例实现"></a>6.6.3 案例实现</h3><p>【例】微信公众号</p>
<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/观察者模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>定义抽象观察者类，里面定义一个更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeixinUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-comment">// 微信用户名</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeixinUser</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;-&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//增加订阅者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-comment">//删除订阅者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span></span>;<br>    <br>    <span class="hljs-comment">//通知订阅者更新消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubscriptionSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//储存订阅公众号的微信用户</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        weixinUserlist.add(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        weixinUserlist.remove(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : weixinUserlist) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SubscriptionSubject mSubscriptionSubject=<span class="hljs-keyword">new</span> SubscriptionSubject();<br>        <span class="hljs-comment">//创建微信用户</span><br>        WeixinUser user1=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;孙悟空&quot;</span>);<br>        WeixinUser user2=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;猪悟能&quot;</span>);<br>        WeixinUser user3=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;沙悟净&quot;</span>);<br>        <span class="hljs-comment">//订阅公众号</span><br>        mSubscriptionSubject.attach(user1);<br>        mSubscriptionSubject.attach(user2);<br>        mSubscriptionSubject.attach(user3);<br>        <span class="hljs-comment">//公众号更新发出消息给订阅的微信用户</span><br>        mSubscriptionSubject.notify(<span class="hljs-string">&quot;传智黑马的专栏更新了&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-6-4-优缺点"><a href="#6-6-4-优缺点" class="headerlink" title="6.6.4 优缺点"></a>6.6.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li>
</ul>
<h3 id="6-6-5-使用场景"><a href="#6-6-5-使用场景" class="headerlink" title="6.6.5 使用场景"></a>6.6.5 使用场景</h3><ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h3 id="6-6-6-JDK中提供的实现"><a href="#6-6-6-JDK中提供的实现" class="headerlink" title="6.6.6 JDK中提供的实现"></a>6.6.6 JDK中提供的实现</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>
<p><strong>1，Observable类</strong></p>
<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ul>
<li><p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p>
</li>
<li><p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>
</li>
<li><p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>
</li>
</ul>
<p><strong>2，Observer 接口</strong></p>
<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>
<p>【例】警察抓小偷</p>
<p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p>
<p>小偷是一个被观察者，所以需要继承Observable类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thief</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thief</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">steal</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;</span>);<br>        <span class="hljs-keyword">super</span>.setChanged(); <span class="hljs-comment">//changed  = true</span><br>        <span class="hljs-keyword">super</span>.notifyObservers();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>警察是一个观察者，所以需要让其实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Policemen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Policemen</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="hljs-string">&quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建小偷对象</span><br>        Thief t = <span class="hljs-keyword">new</span> Thief(<span class="hljs-string">&quot;隔壁老王&quot;</span>);<br>        <span class="hljs-comment">//创建警察对象</span><br>        Policemen p = <span class="hljs-keyword">new</span> Policemen(<span class="hljs-string">&quot;小李&quot;</span>);<br>        <span class="hljs-comment">//让警察盯着小偷</span><br>        t.addObserver(p);<br>        <span class="hljs-comment">//小偷偷东西</span><br>        t.steal();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-7-中介者模式（https-blog-csdn-net-wwwdc1012-article-details-83389158）"><a href="#6-7-中介者模式（https-blog-csdn-net-wwwdc1012-article-details-83389158）" class="headerlink" title="6.7 中介者模式（https://blog.csdn.net/wwwdc1012/article/details/83389158）"></a>6.7 中介者模式（<a href="https://blog.csdn.net/wwwdc1012/article/details/83389158%EF%BC%89">https://blog.csdn.net/wwwdc1012/article/details/83389158）</a></h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1 概述"></a>6.7.1 概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<img src="/images/设计模式-day05/image-20200214110924010.png" style="zoom:60%;">

<p><strong>定义：</strong></p>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<h3 id="6-7-2-结构"><a href="#6-7-2-结构" class="headerlink" title="6.7.2 结构"></a>6.7.2 结构</h3><p>中介者模式包含以下主要角色：</p>
<ul>
<li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ul>
<h3 id="6-7-3-案例实现"><a href="#6-7-3-案例实现" class="headerlink" title="6.7.3 案例实现"></a>6.7.3 案例实现</h3><p>【例】租房</p>
<p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/中介者模式.png" style="zoom:70%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象中介者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//申明一个联络方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message,Person person)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//抽象同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,Mediator mediator)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.mediator = mediator;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体同事类 房屋拥有者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HouseOwner</span><span class="hljs-params">(String name, Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.constact(message, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房主&quot;</span> + name +<span class="hljs-string">&quot;获取到的信息：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体同事类 承租人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tenant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tenant</span><span class="hljs-params">(String name, Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.constact(message, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;租房者&quot;</span> + name +<span class="hljs-string">&quot;获取到的信息：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中介机构</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediatorStructure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//首先中介结构必须知道所有房主和租房者的信息</span><br>    <span class="hljs-keyword">private</span> HouseOwner houseOwner;<br>    <span class="hljs-keyword">private</span> Tenant tenant;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HouseOwner <span class="hljs-title">getHouseOwner</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> houseOwner;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHouseOwner</span><span class="hljs-params">(HouseOwner houseOwner)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.houseOwner = houseOwner;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Tenant <span class="hljs-title">getTenant</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tenant;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTenant</span><span class="hljs-params">(Tenant tenant)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tenant = tenant;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message, Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (person == houseOwner) &#123;          <span class="hljs-comment">//如果是房主，则租房者获得信息</span><br>            tenant.getMessage(message);<br>        &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">//反正则是房主获得信息</span><br>            houseOwner.getMessage(message);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//一个房主、一个租房者、一个中介机构</span><br>        MediatorStructure mediator = <span class="hljs-keyword">new</span> MediatorStructure();<br><br>        <span class="hljs-comment">//房主和租房者只需要知道中介机构即可</span><br>        HouseOwner houseOwner = <span class="hljs-keyword">new</span> HouseOwner(<span class="hljs-string">&quot;张三&quot;</span>, mediator);<br>        Tenant tenant = <span class="hljs-keyword">new</span> Tenant(<span class="hljs-string">&quot;李四&quot;</span>, mediator);<br><br>        <span class="hljs-comment">//中介结构要知道房主和租房者</span><br>        mediator.setHouseOwner(houseOwner);<br>        mediator.setTenant(tenant);<br><br>        tenant.constact(<span class="hljs-string">&quot;需要租三室的房子&quot;</span>);<br>        houseOwner.constact(<span class="hljs-string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-7-4-优缺点"><a href="#6-7-4-优缺点" class="headerlink" title="6.7.4 优缺点"></a>6.7.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>松散耦合</p>
<p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p>
</li>
<li><p>集中控制交互</p>
<p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p>
</li>
<li><p>一对多关联转变为一对一的关联</p>
<p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="6-7-5-使用场景"><a href="#6-7-5-使用场景" class="headerlink" title="6.7.5 使用场景"></a>6.7.5 使用场景</h3><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h2 id="6-8-迭代器模式"><a href="#6-8-迭代器模式" class="headerlink" title="6.8 迭代器模式"></a>6.8 迭代器模式</h2><h3 id="6-8-1-概述"><a href="#6-8-1-概述" class="headerlink" title="6.8.1 概述"></a>6.8.1 概述</h3><p><strong>定义：</strong></p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p>
<h3 id="6-8-2-结构"><a href="#6-8-2-结构" class="headerlink" title="6.8.2 结构"></a>6.8.2 结构</h3><p>迭代器模式主要包含以下角色：</p>
<ul>
<li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p>
</li>
<li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p>
</li>
<li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p>
</li>
<li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p>
</li>
</ul>
<h3 id="6-8-3-案例实现"><a href="#6-8-3-案例实现" class="headerlink" title="6.8.3 案例实现"></a>6.8.3 案例实现</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p>
<img src="/images/设计模式-day05/迭代器模式.png" style="zoom:90%;">



<p>代码如下：</p>
<p>定义迭代器接口，声明hasNext、next方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentIterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Student <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体的迭代器类，重写所有的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentIteratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentIterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; list;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentIteratorImpl</span><span class="hljs-params">(List&lt;Student&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &lt; list.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        Student currentStudent = list.get(position);<br>        position ++;<br>        <span class="hljs-keyword">return</span> currentStudent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentAggregate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeStudent</span><span class="hljs-params">(Student student)</span></span>;<br><br>    <span class="hljs-function">StudentIterator <span class="hljs-title">getStudentIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体的容器类，重写所有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentAggregateImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentAggregate</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();  <span class="hljs-comment">// 学生列表</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list.add(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list.remove(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StudentIterator <span class="hljs-title">getStudentIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudentIteratorImpl(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-8-4-优缺点"><a href="#6-8-4-优缺点" class="headerlink" title="6.8.4 优缺点"></a>6.8.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h3 id="6-8-5-使用场景"><a href="#6-8-5-使用场景" class="headerlink" title="6.8.5 使用场景"></a>6.8.5 使用场景</h3><ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h3 id="6-8-6-JDK源码解析"><a href="#6-8-6-JDK源码解析" class="headerlink" title="6.8.6 JDK源码解析"></a>6.8.6 JDK源码解析</h3><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; iterator = list.iterator(); <span class="hljs-comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li>
</ul>
<p>具体的来看看 ArrayList的代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// 下一个要返回元素的索引</span><br>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 上一个返回元素的索引</span><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>        Itr() &#123;&#125;<br>		<br>        <span class="hljs-comment">//判断是否还有元素</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br><br>        <span class="hljs-comment">//获取下一个元素</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            checkForComodification();<br>            <span class="hljs-keyword">int</span> i = cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这部分代码还是比较简单，大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p>
<blockquote>
<p>注意： </p>
<p>​    当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p>
</blockquote>
<h2 id="6-9-访问者模式"><a href="#6-9-访问者模式" class="headerlink" title="6.9 访问者模式"></a>6.9 访问者模式</h2><h3 id="6-9-1-概述"><a href="#6-9-1-概述" class="headerlink" title="6.9.1 概述"></a>6.9.1 概述</h3><p><strong>定义：</strong></p>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<h3 id="6-9-2-结构"><a href="#6-9-2-结构" class="headerlink" title="6.9.2 结构"></a>6.9.2 结构</h3><p>访问者模式包含以下主要角色:</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li>
<li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li>
<li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<h3 id="6-9-3-案例实现"><a href="#6-9-3-案例实现" class="headerlink" title="6.9.3 案例实现"></a>6.9.3 案例实现</h3><p>【例】给宠物喂食</p>
<p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p>
<ul>
<li>访问者角色：给宠物喂食的人</li>
<li>具体访问者角色：主人、其他人</li>
<li>抽象元素角色：动物抽象类</li>
<li>具体元素角色：宠物狗、宠物猫</li>
<li>结构对象角色：主人家</li>
</ul>
<p>类图如下：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day05/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p>
<p>代码如下：</p>
<p>创建抽象访问者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食猫&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食狗&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Someone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食猫&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食狗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象节点 – 宠物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现<code>Animal</code>接口的 具体节点（元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        person.feed(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;好好吃，汪汪汪！！！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        person.feed(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;好好吃，喵喵喵！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义对象结构，此案例中就是主人的家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Animal&gt; nodeList = <span class="hljs-keyword">new</span> ArrayList&lt;Animal&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Animal node : nodeList) &#123;<br>            node.accept(person);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Animal animal)</span> </span>&#123;<br>        nodeList.add(animal);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Home home = <span class="hljs-keyword">new</span> Home();<br>        home.add(<span class="hljs-keyword">new</span> Dog());<br>        home.add(<span class="hljs-keyword">new</span> Cat());<br><br>        Owner owner = <span class="hljs-keyword">new</span> Owner();<br>        home.action(owner);<br><br>        Someone someone = <span class="hljs-keyword">new</span> Someone();<br>        home.action(someone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-9-4-优缺点"><a href="#6-9-4-优缺点" class="headerlink" title="6.9.4 优缺点"></a>6.9.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>扩展性好</p>
<p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p>
</li>
<li><p>复用性好</p>
<p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p>
</li>
<li><p>分离无关行为</p>
<p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对象结构变化很困难</p>
<p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p>
</li>
<li><p>违反了依赖倒置原则</p>
<p>访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<h3 id="6-9-5-使用场景"><a href="#6-9-5-使用场景" class="headerlink" title="6.9.5  使用场景"></a>6.9.5  使用场景</h3><ul>
<li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p>
</li>
<li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p>
</li>
</ul>
<h3 id="6-9-6-扩展"><a href="#6-9-6-扩展" class="headerlink" title="6.9.6 扩展"></a>6.9.6 扩展</h3><p>访问者模式用到了一种双分派的技术。</p>
<p><strong>1，分派：</strong></p>
<p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p>
<p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p>
<p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p>
<p><strong>2，动态分派：</strong></p>
<p>通过方法的重写支持动态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>   	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Dog();<br>        a.execute();<br>        <br>        Animal a1 = <span class="hljs-keyword">new</span> Cat();<br>        a1.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p>
<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>
<p><strong>3，静态分派：</strong></p>
<p>通过方法重载支持静态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Execute</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Animal a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Dog d)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Cat c)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Animal();<br>        Animal a1 = <span class="hljs-keyword">new</span> Dog();<br>        Animal a2 = <span class="hljs-keyword">new</span> Cat();<br><br>        Execute exe = <span class="hljs-keyword">new</span> Execute();<br>        exe.execute(a);<br>        exe.execute(a1);<br>        exe.execute(a2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/images/设计模式-day05/image-20200214215446638.png" style="zoom:70%;">

<p>这个结果可能出乎一些人的意料了，为什么呢？</p>
<p><strong>==重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了==</strong></p>
<p><strong>4，双分派：</strong></p>
<p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Execute</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Animal a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Dog d)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Cat c)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Animal();<br>        Animal d = <span class="hljs-keyword">new</span> Dog();<br>        Animal c = <span class="hljs-keyword">new</span> Cat();<br><br>        Execute exe = <span class="hljs-keyword">new</span> Execute();<br>        a.accept(exe);<br>        d.accept(exe);<br>        c.accept(exe);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p>
<p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p>
<p>运行结果如下：</p>
<img src="/images/设计模式-day05/image-20200426233931693.png" style="zoom:67%;">

<p><strong>==双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。==</strong></p>
<h2 id="6-10-备忘录模式"><a href="#6-10-备忘录模式" class="headerlink" title="6.10 备忘录模式"></a>6.10 备忘录模式</h2><h3 id="6-10-1-概述"><a href="#6-10-1-概述" class="headerlink" title="6.10.1 概述"></a>6.10.1 概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><strong>定义：</strong></p>
<p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<h3 id="6-10-2-结构"><a href="#6-10-2-结构" class="headerlink" title="6.10.2 结构"></a>6.10.2 结构</h3><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<blockquote>
<p>备忘录有两个等效的接口：</p>
<ul>
<li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li>
<li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
</blockquote>
<h3 id="6-10-3-案例实现"><a href="#6-10-3-案例实现" class="headerlink" title="6.10.3 案例实现"></a>6.10.3 案例实现</h3><p>【例】游戏挑战BOSS</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>要实现上述案例，有两种方式：</p>
<ul>
<li>“白箱”备忘录模式</li>
<li>“黑箱”备忘录模式</li>
</ul>
<h4 id="6-10-3-1-“白箱”备忘录模式"><a href="#6-10-3-1-“白箱”备忘录模式" class="headerlink" title="6.10.3.1 “白箱”备忘录模式"></a>6.10.3.1 “白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p>
<img src="/images/设计模式-day05/白箱备忘录模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//游戏角色类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameRole</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit; <span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk; <span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def; <span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title">saveState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RoleStateMemento(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//回复角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverState</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-keyword">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-keyword">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateDisplay</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力：&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力：&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力：&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//游戏状态存储类(备忘录类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateMemento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit, <span class="hljs-keyword">int</span> atk, <span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//角色状态管理者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateCaretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RoleStateMemento roleStateMemento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title">getRoleStateMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roleStateMemento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleStateMemento</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleStateMemento = roleStateMemento;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss前------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        GameRole gameRole = <span class="hljs-keyword">new</span> GameRole();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        RoleStateCaretaker roleStateCaretaker = <span class="hljs-keyword">new</span> RoleStateCaretaker();<br>        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss后------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss时，损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br>        System.out.println(<span class="hljs-string">&quot;------------恢复之前状态------------&quot;</span>);<br>        <span class="hljs-comment">//恢复之前状态</span><br>        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());<br>        gameRole.stateDisplay();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p>
</blockquote>
<h4 id="6-10-3-2-“黑箱”备忘录模式"><a href="#6-10-3-2-“黑箱”备忘录模式" class="headerlink" title="6.10.3.2 “黑箱”备忘录模式"></a>6.10.3.2 “黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p>
<p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p>
<img src="/images/设计模式-day05/黑箱备忘录模式.png" style="zoom:70%;">

<p>代码如下：</p>
<p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Memento</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">/游戏角色类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameRole</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit; <span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk; <span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def; <span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">saveState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RoleStateMemento(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//回复角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverState</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;<br>        <span class="hljs-keyword">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-keyword">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-keyword">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateDisplay</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力：&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力：&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力：&quot;</span> + def);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateMemento</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memento</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit, <span class="hljs-keyword">int</span> atk, <span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.vit = vit;<br>            <span class="hljs-keyword">this</span>.atk = atk;<br>            <span class="hljs-keyword">this</span>.def = def;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> vit;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.vit = vit;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> atk;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.atk = atk;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.def = def;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//角色状态管理者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateCaretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memento = memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss前------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        GameRole gameRole = <span class="hljs-keyword">new</span> GameRole();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        RoleStateCaretaker roleStateCaretaker = <span class="hljs-keyword">new</span> RoleStateCaretaker();<br>        roleStateCaretaker.setMemento(gameRole.saveState());<br>        <br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss后------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss时，损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br>        System.out.println(<span class="hljs-string">&quot;------------恢复之前状态------------&quot;</span>);<br>        <span class="hljs-comment">//恢复之前状态</span><br>        gameRole.recoverState(roleStateCaretaker.getMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-10-4-优缺点"><a href="#6-10-4-优缺点" class="headerlink" title="6.10.4 优缺点"></a>6.10.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<h3 id="6-10-5-使用场景"><a href="#6-10-5-使用场景" class="headerlink" title="6.10.5 使用场景"></a>6.10.5 使用场景</h3><ul>
<li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p>
</li>
<li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day04</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day04/</url>
    <content><![CDATA[<h1 id="5，结构型模式"><a href="#5，结构型模式" class="headerlink" title="5，结构型模式"></a>5，结构型模式</h1><h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><img src="/images/设计模式-day04/image-20200208180417291.png" style="zoom:60%;">

<p>​    对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>
<p><strong>定义：</strong></p>
<p>​    又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h3 id="5-6-2-结构"><a href="#5-6-2-结构" class="headerlink" title="5.6.2 结构"></a>5.6.2 结构</h3><p>组合模式主要包含三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h3 id="5-6-3-案例实现"><a href="#5-6-3-案例实现" class="headerlink" title="5.6.3 案例实现"></a>5.6.3 案例实现</h3><p>【例】软件菜单</p>
<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>
<img src="/images/设计模式-day04/image-20200208182322313.png" style="zoom:80%;">

<p>要实现该案例，我们先画出类图：</p>
<img src="/images/设计模式-day04/组合模式.png" style="zoom:80%;">

<p><strong>代码实现：</strong></p>
<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> level;<br><br>    <span class="hljs-comment">//添加菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//移除菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取指定的子菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取菜单名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.level = level;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        menuComponentList = <span class="hljs-keyword">new</span> ArrayList&lt;MenuComponent&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.add(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.remove(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> menuComponentList.get(i);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>        <span class="hljs-keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;<br>            menuComponent.print();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<h3 id="5-6-4-组合模式的分类"><a href="#5-6-4-组合模式的分类" class="headerlink" title="5.6.4 组合模式的分类"></a>5.6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>
<ul>
<li><p>透明组合模式</p>
<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
</li>
<li><p>安全组合模式</p>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>
<img src="/images/设计模式-day04/组合模式-安全性.png" style="zoom:80%;"></li>
</ul>
<h3 id="5-6-5-优点"><a href="#5-6-5-优点" class="headerlink" title="5.6.5 优点"></a>5.6.5 优点</h3><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<h3 id="5-6-6-使用场景"><a href="#5-6-6-使用场景" class="headerlink" title="5.6.6 使用场景"></a>5.6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>
<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>定义：</strong></p>
<p>​    **==运用共享技术来有效地支持大量细粒度对象的复用==**。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h3 id="5-7-2-结构"><a href="#5-7-2-结构" class="headerlink" title="5.7.2 结构"></a>5.7.2 结构</h3><p>享元（Flyweight ）模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li>
</ol>
<p>享元模式的主要有以下角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<h3 id="5-7-3-案例实现"><a href="#5-7-3-案例实现" class="headerlink" title="5.7.3 案例实现"></a>5.7.3 案例实现</h3><p>【例】俄罗斯方块</p>
<p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<img src="/images/设计模式-day04/俄罗斯方块.jpeg" style="zoom:60%;">



<p><strong>先来看类图：</strong></p>
<img src="/images/设计模式-day04/享元模式.png" style="zoom:80%;">

<p><strong>代码如下：</strong></p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方块形状：&quot;</span> + <span class="hljs-keyword">this</span>.getShape() + <span class="hljs-string">&quot; 颜色：&quot;</span> + color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;O&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoxFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BoxFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;String, AbstractBox&gt;();<br>        AbstractBox iBox = <span class="hljs-keyword">new</span> IBox();<br>        AbstractBox lBox = <span class="hljs-keyword">new</span> LBox();<br>        AbstractBox oBox = <span class="hljs-keyword">new</span> OBox();<br>        map.put(<span class="hljs-string">&quot;I&quot;</span>, iBox);<br>        map.put(<span class="hljs-string">&quot;L&quot;</span>, lBox);<br>        map.put(<span class="hljs-string">&quot;O&quot;</span>, oBox);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory INSTANCE = <span class="hljs-keyword">new</span> BoxFactory();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBox <span class="hljs-title">getBox</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-7-5-优缺点和使用场景"><a href="#5-7-5-优缺点和使用场景" class="headerlink" title="5.7.5 优缺点和使用场景"></a>5.7.5 优缺点和使用场景</h3><p><strong>1，优点</strong></p>
<ul>
<li><strong>极大减少内存中相似或相同对象数量</strong>，节约系统资源，提供系统性能</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p>
<p><strong>3，使用场景：</strong></p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h3 id="5-7-6-JDK源码解析"><a href="#5-7-6-JDK源码解析" class="headerlink" title="5.7.6 JDK源码解析"></a>5.7.6 JDK源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = <span class="hljs-number">127</span>;<br>        Integer i2 = <span class="hljs-number">127</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));<br><br>        Integer i3 = <span class="hljs-number">128</span>;<br>        Integer i4 = <span class="hljs-number">128</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行上面代码，结果如下：</p>
<img src="/images/设计模式-day04/image-20200208212930857.png" style="zoom:80%;">

<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        Integer i2 Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i1 == i2)).toString());<br>        Integer i3 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        Integer i4 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i3 == i4)).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                &#125;<br>            &#125;<br>            high = h;<br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>
<h1 id="6，行为型模式"><a href="#6，行为型模式" class="headerlink" title="6，行为型模式"></a>6，行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>职责链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>
<h2 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1 模板方法模式"></a>6.1 模板方法模式</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p><strong>定义：</strong></p>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h3 id="6-1-2-结构"><a href="#6-1-2-结构" class="headerlink" title="6.1.2 结构"></a>6.1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
</li>
<li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>
</li>
<li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>
</li>
<li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<h3 id="6-1-3-案例实现"><a href="#6-1-3-案例实现" class="headerlink" title="6.1.3 案例实现"></a>6.1.3 案例实现</h3><p>【例】炒菜</p>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p>
<img src="/images/设计模式-day04/模板方法模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookProcess</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//第一步：倒油</span><br>        <span class="hljs-keyword">this</span>.pourOil();<br>        <span class="hljs-comment">//第二步：热油</span><br>        <span class="hljs-keyword">this</span>.heatOil();<br>        <span class="hljs-comment">//第三步：倒蔬菜</span><br>        <span class="hljs-keyword">this</span>.pourVegetable();<br>        <span class="hljs-comment">//第四步：倒调味料</span><br>        <span class="hljs-keyword">this</span>.pourSauce();<br>        <span class="hljs-comment">//第五步：翻炒</span><br>        <span class="hljs-keyword">this</span>.fry();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourOil</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;倒油&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//第二步：热油是一样的，所以直接实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heatOil</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;热油&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//第四步：倒调味料是不一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//第五步：翻炒是一样的，所以直接实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fry</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;炒啊炒啊炒到熟啊&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass_BaoCai</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的蔬菜是包菜&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的酱料是辣椒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass_CaiXin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的蔬菜是菜心&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的酱料是蒜蓉&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//炒手撕包菜</span><br>        ConcreteClass_BaoCai baoCai = <span class="hljs-keyword">new</span> ConcreteClass_BaoCai();<br>        baoCai.cookProcess();<br><br>        <span class="hljs-comment">//炒蒜蓉菜心</span><br>        ConcreteClass_CaiXin caiXin = <span class="hljs-keyword">new</span> ConcreteClass_CaiXin();<br>        caiXin.cookProcess();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p>
</blockquote>
<h3 id="6-1-3-优缺点"><a href="#6-1-3-优缺点" class="headerlink" title="6.1.3 优缺点"></a>6.1.3 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li><p>提高代码复用性</p>
<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>
</li>
<li><p>实现了反向控制</p>
<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h3 id="6-1-4-适用场景"><a href="#6-1-4-适用场景" class="headerlink" title="6.1.4 适用场景"></a>6.1.4 适用场景</h3><ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h3 id="6-1-5-JDK源码解析"><a href="#6-1-5-JDK源码解析" class="headerlink" title="6.1.5 JDK源码解析"></a>6.1.5 JDK源码解析</h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>    <span class="hljs-comment">//抽象方法，要求子类必须重写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> c = read(); <span class="hljs-comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span><br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-keyword">byte</span>)c;<br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-keyword">byte</span>)c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p>
<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>
<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>
<h2 id="6-2-策略模式"><a href="#6-2-策略模式" class="headerlink" title="6.2 策略模式"></a>6.2 策略模式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>
<img src="/images/设计模式-day04/image-20200210143039168.png" style="zoom:80%;">

<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p>
<img src="/images/设计模式-day04/image-20200210144457478.png" style="zoom:70%;">

<p><strong>定义：</strong></p>
<p>​    该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h3 id="6-2-2-结构"><a href="#6-2-2-结构" class="headerlink" title="6.2.2 结构"></a>6.2.2 结构</h3><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h3 id="6-2-3-案例实现"><a href="#6-2-3-案例实现" class="headerlink" title="6.2.3 案例实现"></a>6.2.3 案例实现</h3><p>【例】促销活动</p>
<p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p>
<img src="/images/设计模式-day04/策略模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>定义百货公司所有促销活动的共同接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为春节准备的促销活动A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;买一送一&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//为中秋准备的促销活动B</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;满200元减50元&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//为圣诞准备的促销活动C</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesMan</span> </span>&#123;                        <br>    <span class="hljs-comment">//持有抽象策略角色的引用                              </span><br>    <span class="hljs-keyword">private</span> Strategy strategy;                 <br>                                               <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SalesMan</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;       <br>        <span class="hljs-keyword">this</span>.strategy = strategy;              <br>    &#125;                                          <br>                                               <br>    <span class="hljs-comment">//向客户展示促销活动                                </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">salesManShow</span><span class="hljs-params">()</span></span>&#123;                <br>        strategy.show();                       <br>    &#125;                                          <br>&#125;                                              <br></code></pre></td></tr></table></figure>



<h3 id="6-2-4-优缺点"><a href="#6-2-4-优缺点" class="headerlink" title="6.2.4 优缺点"></a>6.2.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>策略类之间可以自由切换</p>
<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>
</li>
<li><p>易于扩展</p>
<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>
</li>
<li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h3 id="6-2-5-使用场景"><a href="#6-2-5-使用场景" class="headerlink" title="6.2.5 使用场景"></a>6.2.5 使用场景</h3><ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<h3 id="6-2-6-JDK源码解析"><a href="#6-2-6-JDK源码解析" class="headerlink" title="6.2.6 JDK源码解析"></a>6.2.6 JDK源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arrays</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            sort(a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (LegacyMergeSort.userRequested)<br>                legacyMergeSort(a, c);<br>            <span class="hljs-keyword">else</span><br>                TimSort.sort(a, <span class="hljs-number">0</span>, a.length, c, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Integer[] data = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-comment">// 实现降序排序</span><br>        Arrays.sort(data, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o2 - o1;<br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(data)); <span class="hljs-comment">//[12, 5, 4, 3, 2, 2, 1]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimSort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c,</span></span><br><span class="hljs-function"><span class="hljs-params">                         T[] work, <span class="hljs-keyword">int</span> workBase, <span class="hljs-keyword">int</span> workLen)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> c != <span class="hljs-keyword">null</span> &amp;&amp; a != <span class="hljs-keyword">null</span> &amp;&amp; lo &gt;= <span class="hljs-number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;<br><br>        <span class="hljs-keyword">int</span> nRemaining  = hi - lo;<br>        <span class="hljs-keyword">if</span> (nRemaining &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Arrays of size 0 and 1 are always sorted</span><br><br>        <span class="hljs-comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;<br>            <span class="hljs-keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);<br>            binarySort(a, lo, hi, lo + initRunLen, c);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ...<br>    &#125;   <br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRunAndMakeAscending</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi,Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> lo &lt; hi;<br>        <span class="hljs-keyword">int</span> runHi = lo + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (runHi == hi)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Find end of run, and reverse range if descending</span><br>        <span class="hljs-keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Descending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)<br>                runHi++;<br>            reverseRange(a, lo, runHi);<br>        &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// Ascending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">0</span>)<br>                runHi++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> runHi - lo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>
<h3 id="6-2-7-策略模式的实战使用"><a href="#6-2-7-策略模式的实战使用" class="headerlink" title="6.2.7 策略模式的实战使用"></a>6.2.7 策略模式的实战使用</h3><p>==<strong><a href="https://blog.csdn.net/m0_37602117/article/details/101756303">https://blog.csdn.net/m0_37602117/article/details/101756303</a></strong>==</p>
<h2 id="6-3-命令模式"><a href="#6-3-命令模式" class="headerlink" title="6.3 命令模式"></a>6.3 命令模式</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>
<img src="/images/设计模式-day04/image-20200211130313251.png" style="zoom:60%;">

<p><strong>定义：</strong></p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<h3 id="6-3-2-结构"><a href="#6-3-2-结构" class="headerlink" title="6.3.2 结构"></a>6.3.2 结构</h3><p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
</ul>
<h3 id="6-3-3-案例实现"><a href="#6-3-3-案例实现" class="headerlink" title="6.3.3 案例实现"></a>6.3.3 案例实现</h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<p>服务员： 就是调用者角色，由她来发起命令。</p>
<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>
<p>订单： 命令中包含订单。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day04/命令模式.png" style="zoom:75%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//只需要定义一个统一的执行方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br><br>    <span class="hljs-comment">//持有接受者对象</span><br>    <span class="hljs-keyword">private</span> SeniorChef receiver;<br>    <span class="hljs-keyword">private</span> Order order;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderCommand</span><span class="hljs-params">(SeniorChef receiver, Order order)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.receiver = receiver;<br>        <span class="hljs-keyword">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span>  </span>&#123;<br>        System.out.println(order.getDiningTable() + <span class="hljs-string">&quot;桌的订单：&quot;</span>);<br>        Set&lt;String&gt; keys = order.getFoodDic().keySet();<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            receiver.makeFood(order.getFoodDic().get(key),key);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">//停顿一下 模拟做饭的过程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>        System.out.println(order.getDiningTable() + <span class="hljs-string">&quot;桌的饭弄好了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;<br>    <span class="hljs-comment">// 餐桌号码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> diningTable;<br><br>    <span class="hljs-comment">// 用来存储餐名并记录份数</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDiningTable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> diningTable;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDiningTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> diningTable)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.diningTable = diningTable;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Integer&gt; <span class="hljs-title">getFoodDic</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> foodDic;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFoodDic</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        foodDic.put(name,num);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 资深大厨类 是命令的Receiver</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeniorChef</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeFood</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,String foodName)</span> </span>&#123;<br>        System.out.println(num + <span class="hljs-string">&quot;份&quot;</span> + foodName);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="hljs-comment">//可以持有很多的命令对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitor</span><span class="hljs-params">()</span> </span>&#123;<br>        commands = <span class="hljs-keyword">new</span> ArrayList();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command cmd)</span></span>&#123;<br>        commands.add(cmd);<br>    &#125;<br><br>    <span class="hljs-comment">// 发出命令 喊 订单来了，厨师开始执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orderUp</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; commands.size(); i++) &#123;<br>            Command cmd = commands.get(i);<br>            <span class="hljs-keyword">if</span> (cmd != <span class="hljs-keyword">null</span>) &#123;<br>                cmd.execute();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建2个order</span><br>        Order order1 = <span class="hljs-keyword">new</span> Order();<br>        order1.setDiningTable(<span class="hljs-number">1</span>);<br>        order1.getFoodDic().put(<span class="hljs-string">&quot;西红柿鸡蛋面&quot;</span>,<span class="hljs-number">1</span>);<br>        order1.getFoodDic().put(<span class="hljs-string">&quot;小杯可乐&quot;</span>,<span class="hljs-number">2</span>);<br><br>        Order order2 = <span class="hljs-keyword">new</span> Order();<br>        order2.setDiningTable(<span class="hljs-number">3</span>);<br>        order2.getFoodDic().put(<span class="hljs-string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="hljs-number">1</span>);<br>        order2.getFoodDic().put(<span class="hljs-string">&quot;小杯雪碧&quot;</span>,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建接收者</span><br>        SeniorChef receiver=<span class="hljs-keyword">new</span> SeniorChef();<br>        <span class="hljs-comment">//将订单和接收者封装成命令对象</span><br>        OrderCommand cmd1 = <span class="hljs-keyword">new</span> OrderCommand(receiver, order1);<br>        OrderCommand cmd2 = <span class="hljs-keyword">new</span> OrderCommand(receiver, order2);<br>        <span class="hljs-comment">//创建调用者 waitor</span><br>        Waitor invoker = <span class="hljs-keyword">new</span> Waitor();<br>        invoker.setCommand(cmd1);<br>        invoker.setCommand(cmd2);<br><br>        <span class="hljs-comment">//将订单带到柜台 并向厨师喊 订单来了</span><br>        invoker.orderUp();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-3-4-优缺点"><a href="#6-3-4-优缺点" class="headerlink" title="6.3.4 优缺点"></a>6.3.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更加复杂。</li>
</ul>
<h3 id="6-3-5-使用场景"><a href="#6-3-5-使用场景" class="headerlink" title="6.3.5 使用场景"></a>6.3.5 使用场景</h3><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
</ul>
<h3 id="6-3-6-JDK源码解析"><a href="#6-3-6-JDK源码解析" class="headerlink" title="6.3.6 JDK源码解析"></a>6.3.6 JDK源码解析</h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//命令接口(抽象命令角色)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//调用者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br><br>        group.add(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            start0();<br>            started = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!started) &#123;<br>                    group.threadStartFailed(<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jdk Runnable 命令模式</span><br><span class="hljs-comment"> *		TurnOffThread ： 属于具体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurnOffThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>     <span class="hljs-keyword">private</span> Receiver receiver;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurnOffThread</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;<br>     	<span class="hljs-keyword">this</span>.receiver = receiver;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     	receiver.turnOFF();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         Receiver receiver = <span class="hljs-keyword">new</span> Receiver();<br>         TurnOffThread turnOffThread = <span class="hljs-keyword">new</span> TurnOffThread(receiver);<br>         Thread thread = <span class="hljs-keyword">new</span> Thread(turnOffThread);<br>         thread.start();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4 责任链模式"></a>6.4 责任链模式</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>
<p><strong>定义：</strong></p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2 结构"></a>6.4.2 结构</h3><p>职责链模式主要包含以下角色:</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h3 id="6-4-3-案例实现"><a href="#6-4-3-案例实现" class="headerlink" title="6.4.3 案例实现"></a>6.4.3 案例实现</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day04/责任链模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请假条</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaveRequest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<span class="hljs-comment">//请假天数</span><br>    <span class="hljs-keyword">private</span> String content;<span class="hljs-comment">//请假内容</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaveRequest</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> num, String content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.num = num;<br>        <span class="hljs-keyword">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//处理者抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_ONE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_THREE = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_SEVEN = <span class="hljs-number">7</span>;<br><br>    <span class="hljs-comment">//该领导处理的请假天数区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numStart;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numEnd;<br><br>    <span class="hljs-comment">//领导上面还有领导</span><br>    <span class="hljs-keyword">private</span> Handler nextHandler;<br><br>    <span class="hljs-comment">//设置请假天数范围 上不封顶</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numStart)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.numStart = numStart;<br>    &#125;<br><br>    <span class="hljs-comment">//设置请假天数范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numStart, <span class="hljs-keyword">int</span> numEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.numStart = numStart;<br>        <span class="hljs-keyword">this</span>.numEnd = numEnd;<br>    &#125;<br><br>    <span class="hljs-comment">//设置上级领导</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextHandler</span><span class="hljs-params">(Handler nextHandler)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.nextHandler = nextHandler;<br>    &#125;<br><br>    <span class="hljs-comment">//提交请假条</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(LeaveRequest leave)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-keyword">this</span>.numStart)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果请假天数达到该领导者的处理要求</span><br>        <span class="hljs-keyword">if</span>(leave.getNum() &gt;= <span class="hljs-keyword">this</span>.numStart)&#123;<br>            <span class="hljs-keyword">this</span>.handleLeave(leave);<br><br>            <span class="hljs-comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != <span class="hljs-keyword">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;<br>                <span class="hljs-keyword">this</span>.nextHandler.submit(leave);<span class="hljs-comment">//继续提交</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;流程结束&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//各级领导处理请假条方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//小组长</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupLeader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupLeader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//小组长处理1-3天的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;小组长审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//部门经理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//部门经理处理3-7天的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;部门经理审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//总经理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeneralManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//部门经理处理7天以上的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_SEVEN);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;总经理审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//请假条来一张</span><br>        LeaveRequest leave = <span class="hljs-keyword">new</span> LeaveRequest(<span class="hljs-string">&quot;小花&quot;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&quot;身体不适&quot;</span>);<br><br>        <span class="hljs-comment">//各位领导</span><br>        GroupLeader groupLeader = <span class="hljs-keyword">new</span> GroupLeader();<br>        Manager manager = <span class="hljs-keyword">new</span> Manager();<br>        GeneralManager generalManager = <span class="hljs-keyword">new</span> GeneralManager();<br><br>        groupLeader.setNextHandler(manager);<span class="hljs-comment">//小组长的领导是部门经理</span><br>        manager.setNextHandler(generalManager);<span class="hljs-comment">//部门经理的领导是总经理</span><br>        <span class="hljs-comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span><br><br>        <span class="hljs-comment">//提交申请</span><br>        groupLeader.submit(leave);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-4-4-优缺点"><a href="#6-4-4-优缺点" class="headerlink" title="6.4.4 优缺点"></a>6.4.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>降低了对象之间的耦合度</p>
<p>该模式降低了请求发送者和接收者的耦合度。</p>
</li>
<li><p>增强了系统的可扩展性</p>
<p>可以根据需要增加新的请求处理类，<strong>满足开闭原则</strong>。</p>
</li>
<li><p>增强了给<strong>对象指派职责的灵活性</strong></p>
<p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p>
</li>
<li><p><strong>==责任链简化了对象之间的连接==</strong></p>
<p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p>
</li>
<li><p>责任分担</p>
<p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的<strong>单一职责原则</strong>。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ul>
<h3 id="6-4-5-源码解析"><a href="#6-4-5-源码解析" class="headerlink" title="6.4.5 源码解析"></a>6.4.5 源码解析</h3><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p>
<ul>
<li><p>模拟web请求Request以及web响应Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Request</span></span>&#123;<br> <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Response</span></span>&#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟web过滤器Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filter</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request req,Response res,FilterChain c)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟实现具体过滤器  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器1 前置处理&quot;</span>);<br><br>        <span class="hljs-comment">// 先执行所有request再倒序执行所有response</span><br>        chain.doFilter(request, response);<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器1 后置处理&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondFilter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器2 前置处理&quot;</span>);<br><br>        <span class="hljs-comment">// 先执行所有request再倒序执行所有response</span><br>        chain.doFilter(request, response);<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器2 后置处理&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟实现过滤器链FilterChain  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterChain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Filter&gt; filters = <span class="hljs-keyword">new</span> ArrayList&lt;Filter&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 链式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterChain <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.filters.add(filter);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == filters.size()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Filter filter = filters.get(index);<br>        index++;<br>        filter.doFilter(request, response, <span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request  req = <span class="hljs-keyword">null</span>;<br>        Response res = <span class="hljs-keyword">null</span> ;<br><br>        FilterChain filterChain = <span class="hljs-keyword">new</span> FilterChain();<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> FirstFilter()).addFilter(<span class="hljs-keyword">new</span> SecondFilter());<br>        filterChain.doFilter(req,res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/26/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/oops-1621091626441/</url>
    <content><![CDATA[<!DOCTYPE html><html lang="zh-CN" class="lizard-project-oops"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,user-scalable=no"><meta name="google" content="notranslate"><meta name="renderer" content="webkit"><meta name="Pragma" content="no-cache"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="applicable-device" content="pc,mobile"><link rel="shortcut icon" href="https://assets.shimonote.com/from_qbox/favicon.ico"><title>石墨文档</title><meta name="keywords" content="在线协作文档,在线文档编辑,在线协作编辑,协同编辑,多人编辑,团队协作工具,文档管理工具,文档协作,文件存储,文件共享,协作办公,SAAS,云协作,google docs,在线office"><meta name="description" content="石墨文档是一款轻便、简洁的在线协作文档工具，PC端和移动端全覆盖，支持多人同时对文档编辑和评论，让你与他人轻松完成协作撰稿、方案讨论、会议记录和资料共享等工作。"><script>window.dataLayer=window.dataLayer||[],window.dataLayer.push({lizard_service_name:"others"})</script><script>!function(e,t,a,n){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5FRC9C5",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer")</script></head><body class="lizard-project-oops"><div id="root"></div><div id="feedback-root"></div><script>var __MANIFEST_REVISION__="bea57d9",perf={startTime:{launch:(new Date).getTime()},trackNow:function(){return this.trackEnd("launch")},trackStart:function(t){this.startTime[t]=(new Date).getTime()},trackEnd:function(t){return(new Date).getTime()-this.startTime[t]}};if(location.pathname.match(/^\/sheet/)&&window.perf.trackStart("sheet-js-load-time"),navigator.serviceWorker)try{navigator.serviceWorker.getRegistrations().then(function(t){for(var e=0;e<t.length;e++)t[e].unregister()})}catch(t){console.error(t)}function _L(){}var __LIZARD_FAILED__=!1;function _E(){__LIZARD_FAILED__||(__LIZARD_FAILED__=!0,alert("资源加载错误, 请刷新页面重试!"))}!function(t,e,r){for(var i in e)t[i]=e[i];for(var i in r)t[i]=r[i]}(window,{"__INITIAL_STATE__":{"user":null},"__LIZARD_CONFIG_HOST__":"https://lizard-config.shimodev.com"},{"__SM_CDN_HOST__":"https://assets.shimonote.com","__LANG__":"zh-CN","__SCOPE__":"__UNSCOPED__","__RUNTIME_ENV__":{"SSE_HOST":"https://event.shimo.im","FILE_IMPORT_LIMIT_MB":50,"NEW_SIGNUP_TEST_ID":31,"PLUGIN_STORE":"","SDK_V2_APP_ID":"8fe36678-85a8-44ab-ad80-eaf291020700","PRIVATE_DEPLOY_TOP_SPACE":"","FILE_CONTROL_ENABLE":1,"CONTENT_HEADER_META_PREFIX":"x-oss-meta-","WEBSOCKET_HOST":"https://ws.shimo.im","API_PATH":"/lizard-api","OPEN_COMMENT":true,"SDK_V2_SIGNATURE":"31d24269384a224d6e43498caf6ca9c60f4327b0","UPLOADER_TOKEN_PATH":"/api/upload/token","SDK_V2_PATH_PREFIX":"/sdk/v2/api","PRIVATE_DEPLOY":"","QUESTION_TEST_ID":36,"UPLOADER_HOST":"https://uploader.shimo.im/token","SENTRY_ENABLE":"1","SELF_HOSTED_LOGOUT":1,"PRIVATE_DEPLOY_FEEDBACK":false,"UPLOADER_TYPE":"qiniu","DEBUG_SA":"","IS_DEV":"","SDK_V2_HOST":"https://shimo.im","CURRENT_TIME":1621091625960},"__SM_SSR__":false})</script><script src="https://assets.shimonote.com/static/lizard-project-oops/locales/zh-CN.e9f39c1ac8.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script>!function(){"use strict";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){var n={exports:{}};return e(n,n.exports),n.exports}var t=n((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.DEBUG_getCompileCache=n.clearCompileCache=n.compile=void 0;var t="undefined"!=typeof Symbol?Symbol.for("s18n-compiled"):"__$s18n-compiled",o={};n.compile=function(e,n){return function(e){for(var n=o,r=0;r<e.length&&n;r++)n=n[e[r]];return n&&n[t]}(e)||function(e,n){for(var r=o,a=0;a<e.length&&r;a++)r=r[e[a]]||(r[e[a]]={});return r[t]=n,n}(e,function(e,n){var t=e.length,o=e.map((function(e,n){return n===t-1?e:e+"%"+(2===t?"s":n+1)})).join(""),r=n[o];return("string"==typeof r?r:o).split(/(%s|%\d)/g).map((function(e){var n,t=null===(n=/^%(s|\d)$/g.exec(e))||void 0===n?void 0:n[1];return t?"s"===t?1:Number(t):e}))}(e,n))};n.clearCompileCache=function(){o={}};n.DEBUG_getCompileCache=function(){return o}})),o=n((function(n,o){var r=e&&e.__awaiter||function(e,n,t,o){return new(t||(t=Promise))((function(r,a){function c(e){try{l(o.next(e))}catch(e){a(e)}}function i(e){try{l(o.throw(e))}catch(e){a(e)}}function l(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(c,i)}l((o=o.apply(e,n||[])).next())}))},a=e&&e.__generator||function(e,n){var t,o,r,a,c={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function i(a){return function(i){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;c;)try{if(t=1,o&&(r=2&a[0]?o.return:a[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,a[1])).done)return r;switch(o=0,r&&(a=[2&a[0],r.value]),a[0]){case 0:case 1:r=a;break;case 4:return c.label++,{value:a[1],done:!1};case 5:c.label++,o=a[1],a=[0];continue;case 7:a=c.ops.pop(),c.trys.pop();continue;default:if(!(r=c.trys,(r=r.length>0&&r[r.length-1])||6!==a[0]&&2!==a[0])){c=0;continue}if(3===a[0]&&(!r||a[1]>r[0]&&a[1]<r[3])){c.label=a[1];break}if(6===a[0]&&c.label<r[1]){c.label=r[1],r=a;break}if(r&&c.label<r[2]){c.label=r[2],c.ops.push(a);break}r[2]&&c.ops.pop(),c.trys.pop();continue}a=n.call(e,c)}catch(e){a=[6,e],o=0}finally{t=r=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,i])}}};Object.defineProperty(o,"__esModule",{value:!0}),o.getS18n=void 0;var c=("undefined"!=typeof navigator&&navigator.languages||[])[0]||"en-US",i="__$s18n-instances",l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==e?e:(console.warn("[s18n] cannot resolve globalThis, sharing by namespace is disabled"),{}),u=l[i]||(l[i]={}),s={},f=function(e){return u[e]||(u[e]=d())};o.getS18n=f;var d=function(){var e,n=c,o=((e={})[n]={},e),i=o[n];function l(e){if("string"==typeof e){var n=i[e];return"string"==typeof n?n:e}if(e&&"number"==typeof e.length){for(var o=t.compile(e,i),r=arguments,a="",c=0;c<o.length;c++){var l=o[c];a+="number"==typeof l?String(r[l]):l}return a}return console.warn("[s18n] invalid input:",arguments),null==e?"":String(e)}l.x=function(e){if("number"==typeof e.length){for(var n=t.compile(e,i),o=arguments,r=[],a=0;a<n.length;a++){var c=n[a];r.push("number"==typeof c?o[c]:c)}return r}return console.warn("[s18n] invalid input:",arguments),[e]},l.addLocaleResource=function(e,n){o[e]||(o[e]={}),Object.assign(o[e],n),t.clearCompileCache()},l.setLocale=function(e){if("string"!=typeof e)throw new TypeError("'locale' is expect to be a string");o[n=e]||(o[n]={}),i=o[n],t.clearCompileCache()},l.getLocale=function(){return n},l.getS18n=f,l.DEBUG_reset=function(e){(void 0===e&&(e=!1),o={},i={},p={},n=c,t.clearCompileCache(),e)||[].concat(Object.values(u)).concat(Object.values(s)).forEach((function(e){e!==l&&e.DEBUG_reset(!0)}))},l.DEBUG_print=function(){var e=t.DEBUG_getCompileCache();return console.log(JSON.stringify({currentLocale:n,resources:o,resource:i,compileCache:e},null,2)),{currentLocale:n,resources:o,resource:i,compileCache:e}};var d=function(e){console.warn("[s18n:deprecated]",e)},p={};return l.configure=function(e){d("`s18n.configure()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p=e},l.setLocaleSync=function(e){d("`s18n.setLocaleSync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocaleSync?l.addLocaleResource(e,p.fetchLocaleSync(e)):console.warn("fetchLocaleSync not provided"),l.setLocale(e)},l.setLocaleAsync=function(e){return r(void 0,void 0,void 0,(function(){var n;return a(this,(function(t){switch(t.label){case 0:return d("`s18n.setLocaleAsync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocale?[4,p.fetchLocale(e)]:[3,2];case 1:return n=t.sent(),l.addLocaleResource(e,n),[3,3];case 2:console.warn("fetchLocaleSync not provided"),t.label=3;case 3:return l.setLocale(e),[2]}}))}))},l},p=s.__default_namespace__=d();n.exports=p,o.default=p})),r=(e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(o);"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),t=1;t<arguments.length;t++){var o=arguments[t];if(null!=o)for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(n[r]=o[r])}return n},writable:!0,configurable:!0});var a=window.lizardLocaleMessages;window.s18n=r.default,window.s18n.applyResource=function(){var e="ja"===document.documentElement.lang?"jp":document.documentElement.lang,n=function(){if(void 0===a||!Array.isArray(a)||0===a.length)return{};for(var e={},n=0,t=a;n<t.length;n++){var o=t[n];for(var r in o)if(o.hasOwnProperty(r))for(var c in o[r])o[r].hasOwnProperty(c)&&(e[c]=o[r][c]||e[c])}return e}();r.default.setLocale(e),r.default.addLocaleResource(e,n)},window.s18n.applyResource()}();
</script><script src="https://assets.shimonote.com/static/lizard-project-oops/runtime.b79c318b.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/vendors.c2e090cd.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/oops.1fe0277e.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script></body></html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/26/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/oops/</url>
    <content><![CDATA[<!DOCTYPE html><html lang="zh-CN" class="lizard-project-oops"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,user-scalable=no"><meta name="google" content="notranslate"><meta name="renderer" content="webkit"><meta name="Pragma" content="no-cache"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="applicable-device" content="pc,mobile"><link rel="shortcut icon" href="https://assets.shimonote.com/from_qbox/favicon.ico"><title>石墨文档</title><meta name="keywords" content="在线协作文档,在线文档编辑,在线协作编辑,协同编辑,多人编辑,团队协作工具,文档管理工具,文档协作,文件存储,文件共享,协作办公,SAAS,云协作,google docs,在线office"><meta name="description" content="石墨文档是一款轻便、简洁的在线协作文档工具，PC端和移动端全覆盖，支持多人同时对文档编辑和评论，让你与他人轻松完成协作撰稿、方案讨论、会议记录和资料共享等工作。"><script>window.dataLayer=window.dataLayer||[],window.dataLayer.push({lizard_service_name:"others"})</script><script>!function(e,t,a,n){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5FRC9C5",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer")</script></head><body class="lizard-project-oops"><div id="root"></div><div id="feedback-root"></div><script>var __MANIFEST_REVISION__="bea57d9",perf={startTime:{launch:(new Date).getTime()},trackNow:function(){return this.trackEnd("launch")},trackStart:function(t){this.startTime[t]=(new Date).getTime()},trackEnd:function(t){return(new Date).getTime()-this.startTime[t]}};if(location.pathname.match(/^\/sheet/)&&window.perf.trackStart("sheet-js-load-time"),navigator.serviceWorker)try{navigator.serviceWorker.getRegistrations().then(function(t){for(var e=0;e<t.length;e++)t[e].unregister()})}catch(t){console.error(t)}function _L(){}var __LIZARD_FAILED__=!1;function _E(){__LIZARD_FAILED__||(__LIZARD_FAILED__=!0,alert("资源加载错误, 请刷新页面重试!"))}!function(t,e,r){for(var i in e)t[i]=e[i];for(var i in r)t[i]=r[i]}(window,{"__INITIAL_STATE__":{"user":null},"__LIZARD_CONFIG_HOST__":"https://lizard-config.shimodev.com"},{"__SM_CDN_HOST__":"https://assets.shimonote.com","__LANG__":"zh-CN","__SCOPE__":"__UNSCOPED__","__RUNTIME_ENV__":{"SSE_HOST":"https://event.shimo.im","FILE_IMPORT_LIMIT_MB":50,"NEW_SIGNUP_TEST_ID":31,"PLUGIN_STORE":"","SDK_V2_APP_ID":"8fe36678-85a8-44ab-ad80-eaf291020700","PRIVATE_DEPLOY_TOP_SPACE":"","FILE_CONTROL_ENABLE":1,"CONTENT_HEADER_META_PREFIX":"x-oss-meta-","WEBSOCKET_HOST":"https://ws.shimo.im","API_PATH":"/lizard-api","OPEN_COMMENT":true,"SDK_V2_SIGNATURE":"31d24269384a224d6e43498caf6ca9c60f4327b0","UPLOADER_TOKEN_PATH":"/api/upload/token","SDK_V2_PATH_PREFIX":"/sdk/v2/api","PRIVATE_DEPLOY":"","QUESTION_TEST_ID":36,"UPLOADER_HOST":"https://uploader.shimo.im/token","SENTRY_ENABLE":"1","SELF_HOSTED_LOGOUT":1,"PRIVATE_DEPLOY_FEEDBACK":false,"UPLOADER_TYPE":"qiniu","DEBUG_SA":"","IS_DEV":"","SDK_V2_HOST":"https://shimo.im","CURRENT_TIME":1621091611187},"__SM_SSR__":false})</script><script src="https://assets.shimonote.com/static/lizard-project-oops/locales/zh-CN.e9f39c1ac8.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script>!function(){"use strict";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){var n={exports:{}};return e(n,n.exports),n.exports}var t=n((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.DEBUG_getCompileCache=n.clearCompileCache=n.compile=void 0;var t="undefined"!=typeof Symbol?Symbol.for("s18n-compiled"):"__$s18n-compiled",o={};n.compile=function(e,n){return function(e){for(var n=o,r=0;r<e.length&&n;r++)n=n[e[r]];return n&&n[t]}(e)||function(e,n){for(var r=o,a=0;a<e.length&&r;a++)r=r[e[a]]||(r[e[a]]={});return r[t]=n,n}(e,function(e,n){var t=e.length,o=e.map((function(e,n){return n===t-1?e:e+"%"+(2===t?"s":n+1)})).join(""),r=n[o];return("string"==typeof r?r:o).split(/(%s|%\d)/g).map((function(e){var n,t=null===(n=/^%(s|\d)$/g.exec(e))||void 0===n?void 0:n[1];return t?"s"===t?1:Number(t):e}))}(e,n))};n.clearCompileCache=function(){o={}};n.DEBUG_getCompileCache=function(){return o}})),o=n((function(n,o){var r=e&&e.__awaiter||function(e,n,t,o){return new(t||(t=Promise))((function(r,a){function c(e){try{l(o.next(e))}catch(e){a(e)}}function i(e){try{l(o.throw(e))}catch(e){a(e)}}function l(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(c,i)}l((o=o.apply(e,n||[])).next())}))},a=e&&e.__generator||function(e,n){var t,o,r,a,c={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function i(a){return function(i){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;c;)try{if(t=1,o&&(r=2&a[0]?o.return:a[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,a[1])).done)return r;switch(o=0,r&&(a=[2&a[0],r.value]),a[0]){case 0:case 1:r=a;break;case 4:return c.label++,{value:a[1],done:!1};case 5:c.label++,o=a[1],a=[0];continue;case 7:a=c.ops.pop(),c.trys.pop();continue;default:if(!(r=c.trys,(r=r.length>0&&r[r.length-1])||6!==a[0]&&2!==a[0])){c=0;continue}if(3===a[0]&&(!r||a[1]>r[0]&&a[1]<r[3])){c.label=a[1];break}if(6===a[0]&&c.label<r[1]){c.label=r[1],r=a;break}if(r&&c.label<r[2]){c.label=r[2],c.ops.push(a);break}r[2]&&c.ops.pop(),c.trys.pop();continue}a=n.call(e,c)}catch(e){a=[6,e],o=0}finally{t=r=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,i])}}};Object.defineProperty(o,"__esModule",{value:!0}),o.getS18n=void 0;var c=("undefined"!=typeof navigator&&navigator.languages||[])[0]||"en-US",i="__$s18n-instances",l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==e?e:(console.warn("[s18n] cannot resolve globalThis, sharing by namespace is disabled"),{}),u=l[i]||(l[i]={}),s={},f=function(e){return u[e]||(u[e]=d())};o.getS18n=f;var d=function(){var e,n=c,o=((e={})[n]={},e),i=o[n];function l(e){if("string"==typeof e){var n=i[e];return"string"==typeof n?n:e}if(e&&"number"==typeof e.length){for(var o=t.compile(e,i),r=arguments,a="",c=0;c<o.length;c++){var l=o[c];a+="number"==typeof l?String(r[l]):l}return a}return console.warn("[s18n] invalid input:",arguments),null==e?"":String(e)}l.x=function(e){if("number"==typeof e.length){for(var n=t.compile(e,i),o=arguments,r=[],a=0;a<n.length;a++){var c=n[a];r.push("number"==typeof c?o[c]:c)}return r}return console.warn("[s18n] invalid input:",arguments),[e]},l.addLocaleResource=function(e,n){o[e]||(o[e]={}),Object.assign(o[e],n),t.clearCompileCache()},l.setLocale=function(e){if("string"!=typeof e)throw new TypeError("'locale' is expect to be a string");o[n=e]||(o[n]={}),i=o[n],t.clearCompileCache()},l.getLocale=function(){return n},l.getS18n=f,l.DEBUG_reset=function(e){(void 0===e&&(e=!1),o={},i={},p={},n=c,t.clearCompileCache(),e)||[].concat(Object.values(u)).concat(Object.values(s)).forEach((function(e){e!==l&&e.DEBUG_reset(!0)}))},l.DEBUG_print=function(){var e=t.DEBUG_getCompileCache();return console.log(JSON.stringify({currentLocale:n,resources:o,resource:i,compileCache:e},null,2)),{currentLocale:n,resources:o,resource:i,compileCache:e}};var d=function(e){console.warn("[s18n:deprecated]",e)},p={};return l.configure=function(e){d("`s18n.configure()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p=e},l.setLocaleSync=function(e){d("`s18n.setLocaleSync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocaleSync?l.addLocaleResource(e,p.fetchLocaleSync(e)):console.warn("fetchLocaleSync not provided"),l.setLocale(e)},l.setLocaleAsync=function(e){return r(void 0,void 0,void 0,(function(){var n;return a(this,(function(t){switch(t.label){case 0:return d("`s18n.setLocaleAsync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocale?[4,p.fetchLocale(e)]:[3,2];case 1:return n=t.sent(),l.addLocaleResource(e,n),[3,3];case 2:console.warn("fetchLocaleSync not provided"),t.label=3;case 3:return l.setLocale(e),[2]}}))}))},l},p=s.__default_namespace__=d();n.exports=p,o.default=p})),r=(e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(o);"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),t=1;t<arguments.length;t++){var o=arguments[t];if(null!=o)for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(n[r]=o[r])}return n},writable:!0,configurable:!0});var a=window.lizardLocaleMessages;window.s18n=r.default,window.s18n.applyResource=function(){var e="ja"===document.documentElement.lang?"jp":document.documentElement.lang,n=function(){if(void 0===a||!Array.isArray(a)||0===a.length)return{};for(var e={},n=0,t=a;n<t.length;n++){var o=t[n];for(var r in o)if(o.hasOwnProperty(r))for(var c in o[r])o[r].hasOwnProperty(c)&&(e[c]=o[r][c]||e[c])}return e}();r.default.setLocale(e),r.default.addLocaleResource(e,n)},window.s18n.applyResource()}();
</script><script src="https://assets.shimonote.com/static/lizard-project-oops/runtime.b79c318b.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/vendors.c2e090cd.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/oops.1fe0277e.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script></body></html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/26/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(1)/oops/</url>
    <content><![CDATA[<!DOCTYPE html><html lang="zh-CN" class="lizard-project-oops"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,user-scalable=no"><meta name="google" content="notranslate"><meta name="renderer" content="webkit"><meta name="Pragma" content="no-cache"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="applicable-device" content="pc,mobile"><link rel="shortcut icon" href="https://assets.shimonote.com/from_qbox/favicon.ico"><title>石墨文档</title><meta name="keywords" content="在线协作文档,在线文档编辑,在线协作编辑,协同编辑,多人编辑,团队协作工具,文档管理工具,文档协作,文件存储,文件共享,协作办公,SAAS,云协作,google docs,在线office"><meta name="description" content="石墨文档是一款轻便、简洁的在线协作文档工具，PC端和移动端全覆盖，支持多人同时对文档编辑和评论，让你与他人轻松完成协作撰稿、方案讨论、会议记录和资料共享等工作。"><script>window.dataLayer=window.dataLayer||[],window.dataLayer.push({lizard_service_name:"others"})</script><script>!function(e,t,a,n){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5FRC9C5",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer")</script></head><body class="lizard-project-oops"><div id="root"></div><div id="feedback-root"></div><script>var __MANIFEST_REVISION__="bea57d9",perf={startTime:{launch:(new Date).getTime()},trackNow:function(){return this.trackEnd("launch")},trackStart:function(t){this.startTime[t]=(new Date).getTime()},trackEnd:function(t){return(new Date).getTime()-this.startTime[t]}};if(location.pathname.match(/^\/sheet/)&&window.perf.trackStart("sheet-js-load-time"),navigator.serviceWorker)try{navigator.serviceWorker.getRegistrations().then(function(t){for(var e=0;e<t.length;e++)t[e].unregister()})}catch(t){console.error(t)}function _L(){}var __LIZARD_FAILED__=!1;function _E(){__LIZARD_FAILED__||(__LIZARD_FAILED__=!0,alert("资源加载错误, 请刷新页面重试!"))}!function(t,e,r){for(var i in e)t[i]=e[i];for(var i in r)t[i]=r[i]}(window,{"__INITIAL_STATE__":{"user":null},"__LIZARD_CONFIG_HOST__":"https://lizard-config.shimodev.com"},{"__SM_CDN_HOST__":"https://assets.shimonote.com","__LANG__":"zh-CN","__SCOPE__":"__UNSCOPED__","__RUNTIME_ENV__":{"SSE_HOST":"https://event.shimo.im","FILE_IMPORT_LIMIT_MB":50,"NEW_SIGNUP_TEST_ID":31,"PLUGIN_STORE":"","SDK_V2_APP_ID":"8fe36678-85a8-44ab-ad80-eaf291020700","PRIVATE_DEPLOY_TOP_SPACE":"","FILE_CONTROL_ENABLE":1,"CONTENT_HEADER_META_PREFIX":"x-oss-meta-","WEBSOCKET_HOST":"https://ws.shimo.im","API_PATH":"/lizard-api","OPEN_COMMENT":true,"SDK_V2_SIGNATURE":"31d24269384a224d6e43498caf6ca9c60f4327b0","UPLOADER_TOKEN_PATH":"/api/upload/token","SDK_V2_PATH_PREFIX":"/sdk/v2/api","PRIVATE_DEPLOY":"","QUESTION_TEST_ID":36,"UPLOADER_HOST":"https://uploader.shimo.im/token","SENTRY_ENABLE":"1","SELF_HOSTED_LOGOUT":1,"PRIVATE_DEPLOY_FEEDBACK":false,"UPLOADER_TYPE":"qiniu","DEBUG_SA":"","IS_DEV":"","SDK_V2_HOST":"https://shimo.im","CURRENT_TIME":1621091611187},"__SM_SSR__":false})</script><script src="https://assets.shimonote.com/static/lizard-project-oops/locales/zh-CN.e9f39c1ac8.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script>!function(){"use strict";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){var n={exports:{}};return e(n,n.exports),n.exports}var t=n((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.DEBUG_getCompileCache=n.clearCompileCache=n.compile=void 0;var t="undefined"!=typeof Symbol?Symbol.for("s18n-compiled"):"__$s18n-compiled",o={};n.compile=function(e,n){return function(e){for(var n=o,r=0;r<e.length&&n;r++)n=n[e[r]];return n&&n[t]}(e)||function(e,n){for(var r=o,a=0;a<e.length&&r;a++)r=r[e[a]]||(r[e[a]]={});return r[t]=n,n}(e,function(e,n){var t=e.length,o=e.map((function(e,n){return n===t-1?e:e+"%"+(2===t?"s":n+1)})).join(""),r=n[o];return("string"==typeof r?r:o).split(/(%s|%\d)/g).map((function(e){var n,t=null===(n=/^%(s|\d)$/g.exec(e))||void 0===n?void 0:n[1];return t?"s"===t?1:Number(t):e}))}(e,n))};n.clearCompileCache=function(){o={}};n.DEBUG_getCompileCache=function(){return o}})),o=n((function(n,o){var r=e&&e.__awaiter||function(e,n,t,o){return new(t||(t=Promise))((function(r,a){function c(e){try{l(o.next(e))}catch(e){a(e)}}function i(e){try{l(o.throw(e))}catch(e){a(e)}}function l(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(c,i)}l((o=o.apply(e,n||[])).next())}))},a=e&&e.__generator||function(e,n){var t,o,r,a,c={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function i(a){return function(i){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;c;)try{if(t=1,o&&(r=2&a[0]?o.return:a[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,a[1])).done)return r;switch(o=0,r&&(a=[2&a[0],r.value]),a[0]){case 0:case 1:r=a;break;case 4:return c.label++,{value:a[1],done:!1};case 5:c.label++,o=a[1],a=[0];continue;case 7:a=c.ops.pop(),c.trys.pop();continue;default:if(!(r=c.trys,(r=r.length>0&&r[r.length-1])||6!==a[0]&&2!==a[0])){c=0;continue}if(3===a[0]&&(!r||a[1]>r[0]&&a[1]<r[3])){c.label=a[1];break}if(6===a[0]&&c.label<r[1]){c.label=r[1],r=a;break}if(r&&c.label<r[2]){c.label=r[2],c.ops.push(a);break}r[2]&&c.ops.pop(),c.trys.pop();continue}a=n.call(e,c)}catch(e){a=[6,e],o=0}finally{t=r=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,i])}}};Object.defineProperty(o,"__esModule",{value:!0}),o.getS18n=void 0;var c=("undefined"!=typeof navigator&&navigator.languages||[])[0]||"en-US",i="__$s18n-instances",l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==e?e:(console.warn("[s18n] cannot resolve globalThis, sharing by namespace is disabled"),{}),u=l[i]||(l[i]={}),s={},f=function(e){return u[e]||(u[e]=d())};o.getS18n=f;var d=function(){var e,n=c,o=((e={})[n]={},e),i=o[n];function l(e){if("string"==typeof e){var n=i[e];return"string"==typeof n?n:e}if(e&&"number"==typeof e.length){for(var o=t.compile(e,i),r=arguments,a="",c=0;c<o.length;c++){var l=o[c];a+="number"==typeof l?String(r[l]):l}return a}return console.warn("[s18n] invalid input:",arguments),null==e?"":String(e)}l.x=function(e){if("number"==typeof e.length){for(var n=t.compile(e,i),o=arguments,r=[],a=0;a<n.length;a++){var c=n[a];r.push("number"==typeof c?o[c]:c)}return r}return console.warn("[s18n] invalid input:",arguments),[e]},l.addLocaleResource=function(e,n){o[e]||(o[e]={}),Object.assign(o[e],n),t.clearCompileCache()},l.setLocale=function(e){if("string"!=typeof e)throw new TypeError("'locale' is expect to be a string");o[n=e]||(o[n]={}),i=o[n],t.clearCompileCache()},l.getLocale=function(){return n},l.getS18n=f,l.DEBUG_reset=function(e){(void 0===e&&(e=!1),o={},i={},p={},n=c,t.clearCompileCache(),e)||[].concat(Object.values(u)).concat(Object.values(s)).forEach((function(e){e!==l&&e.DEBUG_reset(!0)}))},l.DEBUG_print=function(){var e=t.DEBUG_getCompileCache();return console.log(JSON.stringify({currentLocale:n,resources:o,resource:i,compileCache:e},null,2)),{currentLocale:n,resources:o,resource:i,compileCache:e}};var d=function(e){console.warn("[s18n:deprecated]",e)},p={};return l.configure=function(e){d("`s18n.configure()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p=e},l.setLocaleSync=function(e){d("`s18n.setLocaleSync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocaleSync?l.addLocaleResource(e,p.fetchLocaleSync(e)):console.warn("fetchLocaleSync not provided"),l.setLocale(e)},l.setLocaleAsync=function(e){return r(void 0,void 0,void 0,(function(){var n;return a(this,(function(t){switch(t.label){case 0:return d("`s18n.setLocaleAsync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocale?[4,p.fetchLocale(e)]:[3,2];case 1:return n=t.sent(),l.addLocaleResource(e,n),[3,3];case 2:console.warn("fetchLocaleSync not provided"),t.label=3;case 3:return l.setLocale(e),[2]}}))}))},l},p=s.__default_namespace__=d();n.exports=p,o.default=p})),r=(e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(o);"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),t=1;t<arguments.length;t++){var o=arguments[t];if(null!=o)for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(n[r]=o[r])}return n},writable:!0,configurable:!0});var a=window.lizardLocaleMessages;window.s18n=r.default,window.s18n.applyResource=function(){var e="ja"===document.documentElement.lang?"jp":document.documentElement.lang,n=function(){if(void 0===a||!Array.isArray(a)||0===a.length)return{};for(var e={},n=0,t=a;n<t.length;n++){var o=t[n];for(var r in o)if(o.hasOwnProperty(r))for(var c in o[r])o[r].hasOwnProperty(c)&&(e[c]=o[r][c]||e[c])}return e}();r.default.setLocale(e),r.default.addLocaleResource(e,n)},window.s18n.applyResource()}();
</script><script src="https://assets.shimonote.com/static/lizard-project-oops/runtime.b79c318b.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/vendors.c2e090cd.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/oops.1fe0277e.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script></body></html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/26/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(1)/oops-1621091626441/</url>
    <content><![CDATA[<!DOCTYPE html><html lang="zh-CN" class="lizard-project-oops"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,user-scalable=no"><meta name="google" content="notranslate"><meta name="renderer" content="webkit"><meta name="Pragma" content="no-cache"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="applicable-device" content="pc,mobile"><link rel="shortcut icon" href="https://assets.shimonote.com/from_qbox/favicon.ico"><title>石墨文档</title><meta name="keywords" content="在线协作文档,在线文档编辑,在线协作编辑,协同编辑,多人编辑,团队协作工具,文档管理工具,文档协作,文件存储,文件共享,协作办公,SAAS,云协作,google docs,在线office"><meta name="description" content="石墨文档是一款轻便、简洁的在线协作文档工具，PC端和移动端全覆盖，支持多人同时对文档编辑和评论，让你与他人轻松完成协作撰稿、方案讨论、会议记录和资料共享等工作。"><script>window.dataLayer=window.dataLayer||[],window.dataLayer.push({lizard_service_name:"others"})</script><script>!function(e,t,a,n){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5FRC9C5",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer")</script></head><body class="lizard-project-oops"><div id="root"></div><div id="feedback-root"></div><script>var __MANIFEST_REVISION__="bea57d9",perf={startTime:{launch:(new Date).getTime()},trackNow:function(){return this.trackEnd("launch")},trackStart:function(t){this.startTime[t]=(new Date).getTime()},trackEnd:function(t){return(new Date).getTime()-this.startTime[t]}};if(location.pathname.match(/^\/sheet/)&&window.perf.trackStart("sheet-js-load-time"),navigator.serviceWorker)try{navigator.serviceWorker.getRegistrations().then(function(t){for(var e=0;e<t.length;e++)t[e].unregister()})}catch(t){console.error(t)}function _L(){}var __LIZARD_FAILED__=!1;function _E(){__LIZARD_FAILED__||(__LIZARD_FAILED__=!0,alert("资源加载错误, 请刷新页面重试!"))}!function(t,e,r){for(var i in e)t[i]=e[i];for(var i in r)t[i]=r[i]}(window,{"__INITIAL_STATE__":{"user":null},"__LIZARD_CONFIG_HOST__":"https://lizard-config.shimodev.com"},{"__SM_CDN_HOST__":"https://assets.shimonote.com","__LANG__":"zh-CN","__SCOPE__":"__UNSCOPED__","__RUNTIME_ENV__":{"SSE_HOST":"https://event.shimo.im","FILE_IMPORT_LIMIT_MB":50,"NEW_SIGNUP_TEST_ID":31,"PLUGIN_STORE":"","SDK_V2_APP_ID":"8fe36678-85a8-44ab-ad80-eaf291020700","PRIVATE_DEPLOY_TOP_SPACE":"","FILE_CONTROL_ENABLE":1,"CONTENT_HEADER_META_PREFIX":"x-oss-meta-","WEBSOCKET_HOST":"https://ws.shimo.im","API_PATH":"/lizard-api","OPEN_COMMENT":true,"SDK_V2_SIGNATURE":"31d24269384a224d6e43498caf6ca9c60f4327b0","UPLOADER_TOKEN_PATH":"/api/upload/token","SDK_V2_PATH_PREFIX":"/sdk/v2/api","PRIVATE_DEPLOY":"","QUESTION_TEST_ID":36,"UPLOADER_HOST":"https://uploader.shimo.im/token","SENTRY_ENABLE":"1","SELF_HOSTED_LOGOUT":1,"PRIVATE_DEPLOY_FEEDBACK":false,"UPLOADER_TYPE":"qiniu","DEBUG_SA":"","IS_DEV":"","SDK_V2_HOST":"https://shimo.im","CURRENT_TIME":1621091625960},"__SM_SSR__":false})</script><script src="https://assets.shimonote.com/static/lizard-project-oops/locales/zh-CN.e9f39c1ac8.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script>!function(){"use strict";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){var n={exports:{}};return e(n,n.exports),n.exports}var t=n((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.DEBUG_getCompileCache=n.clearCompileCache=n.compile=void 0;var t="undefined"!=typeof Symbol?Symbol.for("s18n-compiled"):"__$s18n-compiled",o={};n.compile=function(e,n){return function(e){for(var n=o,r=0;r<e.length&&n;r++)n=n[e[r]];return n&&n[t]}(e)||function(e,n){for(var r=o,a=0;a<e.length&&r;a++)r=r[e[a]]||(r[e[a]]={});return r[t]=n,n}(e,function(e,n){var t=e.length,o=e.map((function(e,n){return n===t-1?e:e+"%"+(2===t?"s":n+1)})).join(""),r=n[o];return("string"==typeof r?r:o).split(/(%s|%\d)/g).map((function(e){var n,t=null===(n=/^%(s|\d)$/g.exec(e))||void 0===n?void 0:n[1];return t?"s"===t?1:Number(t):e}))}(e,n))};n.clearCompileCache=function(){o={}};n.DEBUG_getCompileCache=function(){return o}})),o=n((function(n,o){var r=e&&e.__awaiter||function(e,n,t,o){return new(t||(t=Promise))((function(r,a){function c(e){try{l(o.next(e))}catch(e){a(e)}}function i(e){try{l(o.throw(e))}catch(e){a(e)}}function l(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(c,i)}l((o=o.apply(e,n||[])).next())}))},a=e&&e.__generator||function(e,n){var t,o,r,a,c={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function i(a){return function(i){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;c;)try{if(t=1,o&&(r=2&a[0]?o.return:a[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,a[1])).done)return r;switch(o=0,r&&(a=[2&a[0],r.value]),a[0]){case 0:case 1:r=a;break;case 4:return c.label++,{value:a[1],done:!1};case 5:c.label++,o=a[1],a=[0];continue;case 7:a=c.ops.pop(),c.trys.pop();continue;default:if(!(r=c.trys,(r=r.length>0&&r[r.length-1])||6!==a[0]&&2!==a[0])){c=0;continue}if(3===a[0]&&(!r||a[1]>r[0]&&a[1]<r[3])){c.label=a[1];break}if(6===a[0]&&c.label<r[1]){c.label=r[1],r=a;break}if(r&&c.label<r[2]){c.label=r[2],c.ops.push(a);break}r[2]&&c.ops.pop(),c.trys.pop();continue}a=n.call(e,c)}catch(e){a=[6,e],o=0}finally{t=r=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,i])}}};Object.defineProperty(o,"__esModule",{value:!0}),o.getS18n=void 0;var c=("undefined"!=typeof navigator&&navigator.languages||[])[0]||"en-US",i="__$s18n-instances",l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==e?e:(console.warn("[s18n] cannot resolve globalThis, sharing by namespace is disabled"),{}),u=l[i]||(l[i]={}),s={},f=function(e){return u[e]||(u[e]=d())};o.getS18n=f;var d=function(){var e,n=c,o=((e={})[n]={},e),i=o[n];function l(e){if("string"==typeof e){var n=i[e];return"string"==typeof n?n:e}if(e&&"number"==typeof e.length){for(var o=t.compile(e,i),r=arguments,a="",c=0;c<o.length;c++){var l=o[c];a+="number"==typeof l?String(r[l]):l}return a}return console.warn("[s18n] invalid input:",arguments),null==e?"":String(e)}l.x=function(e){if("number"==typeof e.length){for(var n=t.compile(e,i),o=arguments,r=[],a=0;a<n.length;a++){var c=n[a];r.push("number"==typeof c?o[c]:c)}return r}return console.warn("[s18n] invalid input:",arguments),[e]},l.addLocaleResource=function(e,n){o[e]||(o[e]={}),Object.assign(o[e],n),t.clearCompileCache()},l.setLocale=function(e){if("string"!=typeof e)throw new TypeError("'locale' is expect to be a string");o[n=e]||(o[n]={}),i=o[n],t.clearCompileCache()},l.getLocale=function(){return n},l.getS18n=f,l.DEBUG_reset=function(e){(void 0===e&&(e=!1),o={},i={},p={},n=c,t.clearCompileCache(),e)||[].concat(Object.values(u)).concat(Object.values(s)).forEach((function(e){e!==l&&e.DEBUG_reset(!0)}))},l.DEBUG_print=function(){var e=t.DEBUG_getCompileCache();return console.log(JSON.stringify({currentLocale:n,resources:o,resource:i,compileCache:e},null,2)),{currentLocale:n,resources:o,resource:i,compileCache:e}};var d=function(e){console.warn("[s18n:deprecated]",e)},p={};return l.configure=function(e){d("`s18n.configure()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p=e},l.setLocaleSync=function(e){d("`s18n.setLocaleSync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocaleSync?l.addLocaleResource(e,p.fetchLocaleSync(e)):console.warn("fetchLocaleSync not provided"),l.setLocale(e)},l.setLocaleAsync=function(e){return r(void 0,void 0,void 0,(function(){var n;return a(this,(function(t){switch(t.label){case 0:return d("`s18n.setLocaleAsync()` is deprecated and will be removed in next version, use setLocale() and addLocaleResource() instead"),p.fetchLocale?[4,p.fetchLocale(e)]:[3,2];case 1:return n=t.sent(),l.addLocaleResource(e,n),[3,3];case 2:console.warn("fetchLocaleSync not provided"),t.label=3;case 3:return l.setLocale(e),[2]}}))}))},l},p=s.__default_namespace__=d();n.exports=p,o.default=p})),r=(e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(o);"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),t=1;t<arguments.length;t++){var o=arguments[t];if(null!=o)for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(n[r]=o[r])}return n},writable:!0,configurable:!0});var a=window.lizardLocaleMessages;window.s18n=r.default,window.s18n.applyResource=function(){var e="ja"===document.documentElement.lang?"jp":document.documentElement.lang,n=function(){if(void 0===a||!Array.isArray(a)||0===a.length)return{};for(var e={},n=0,t=a;n<t.length;n++){var o=t[n];for(var r in o)if(o.hasOwnProperty(r))for(var c in o[r])o[r].hasOwnProperty(c)&&(e[c]=o[r][c]||e[c])}return e}();r.default.setLocale(e),r.default.addLocaleResource(e,n)},window.s18n.applyResource()}();
</script><script src="https://assets.shimonote.com/static/lizard-project-oops/runtime.b79c318b.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/vendors.c2e090cd.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script><script src="https://assets.shimonote.com/static/lizard-project-oops/oops.1fe0277e.js" crossorigin="anonymous" onerror="_E(event)" onload="_L(event)"></script></body></html>]]></content>
  </entry>
</search>
