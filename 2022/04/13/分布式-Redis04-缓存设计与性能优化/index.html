<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="缓存设计与性能优化">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式-Redis04-缓存设计与性能优化">
<meta property="og:url" content="http://example.com/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="24khandsome&#39;s Blog">
<meta property="og:description" content="缓存设计与性能优化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417105957154.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417111129125.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650178193285.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650179170290.png">
<meta property="article:published_time" content="2022-04-13T13:00:00.000Z">
<meta property="article:modified_time" content="2022-12-22T14:46:53.724Z">
<meta property="article:author" content="24khandsome">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png">

<link rel="canonical" href="http://example.com/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>分布式-Redis04-缓存设计与性能优化 | 24khandsome's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">24khandsome's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">24khandsome's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="24khandsome">
      <meta itemprop="description" content="24khandsome's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="24khandsome's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          分布式-Redis04-缓存设计与性能优化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 21:00:00" itemprop="dateCreated datePublished" datetime="2022-04-13T21:00:00+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-22 22:46:53" itemprop="dateModified" datetime="2022-12-22T22:46:53+08:00">2022-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <div class="post-description">缓存设计与性能优化</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="缓存设计与性能优化"><a href="#缓存设计与性能优化" class="headerlink" title="缓存设计与性能优化"></a>缓存设计与性能优化</h1><h2 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="img"></p>
<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417105957154.png" alt="image-20220417105957154"></p>
<p>​    <strong>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层</strong>：缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。：缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。</p>
<h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a><strong>造成缓存穿透的原因</strong></h4><p>1、恶意攻击、爬虫等照成大量空命中</p>
<p>2、自身业务代码或者数据出现错误</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1、缓存空对象（<strong>设置较短的过期时间</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、布隆过滤器(redisson有实现)</p>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。<strong>当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数</strong>。所谓无偏就是能够把元素的 hash 值算得 比较均匀。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417111129125.png" alt="image-20220417111129125"></p>
<p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p>
<p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p>
<p><strong>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是缓存空间占用很少</strong>。使用布隆过滤器需要把<strong>所有数据提前放入布隆过滤器</strong>，并且在增加数据时也要往布隆过滤器里放。</p>
<p><strong>注意事项</strong></p>
<p>1、提前放入所有key</p>
<p>2、布隆过滤器不能删除数据，如果要删除得重新初始化数据。</p>
<p>3、用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景</p>
<p>布隆过滤器缓存过滤伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化布隆过滤器</span><br>RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="hljs-string">&quot;nameList&quot;</span>);<br><span class="hljs-comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span><br>bloomFilter.tryInit(<span class="hljs-number">100000000L</span>,<span class="hljs-number">0.03</span>);<br>        <br><span class="hljs-comment">//把所有数据存入布隆过滤器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (String key: keys) &#123;<br>        bloomFilter.put(key);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从布隆过滤器这一级缓存判断下key是否存在</span><br>    Boolean exist = bloomFilter.contains(key);<br>    <span class="hljs-keyword">if</span>(!exist)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="缓存失效（击穿）"><a href="#缓存失效（击穿）" class="headerlink" title="缓存失效（击穿）"></a>缓存失效（击穿）</h3><p>定义：热点数据过期失效后，大量用户并发请求同时读缓存没有读取到，又同时去数据库查询，造成数据库瞬间压力巨大甚至挂掉</p>
<p>解决办法：</p>
<p>1、<strong>避免多个热点key同时失效：缓存过期时间设置为一个时间段内的不同时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">//设置一个过期时间(300到600之间的一个随机数)</span><br>        <span class="hljs-keyword">int</span> expireTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">300</span>)  + <span class="hljs-number">300</span>;<br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, expireTime);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、<strong>单个热点key失效设置缓存时设置互斥锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从Redis中获取数据</span><br>    String value = redis.get(key);<br>    <span class="hljs-comment">// 如果value为空， 则开始重构缓存</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex</span><br>        String mutexKey = <span class="hljs-string">&quot;mutext:key:&quot;</span> + key;<br>        <span class="hljs-keyword">if</span> (redis.set(mutexKey, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;ex 180&quot;</span>, <span class="hljs-string">&quot;nx&quot;</span>)) &#123;<br>             <span class="hljs-comment">// 从数据源获取数据</span><br>            value = db.get(key);<br>            <span class="hljs-comment">// 回写Redis， 并设置过期时间</span><br>            redis.setex(key, timeout, value);<br>            <span class="hljs-comment">// 删除key_mutex</span><br>            redis.delete(mutexKey);<br>        &#125;<span class="hljs-comment">// 其他线程休息50毫秒后重试</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            get(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：<strong>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层</strong>，最终可能导致数据库层崩溃进而整个服务挂掉。由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。 </p>
<h4 id="预防和解决缓存雪崩问题"><a href="#预防和解决缓存雪崩问题" class="headerlink" title="预防和解决缓存雪崩问题"></a>预防和解决缓存雪崩问题</h4><p>1、保证缓存层服务的高可用性，比如采用集群或者哨兵模式</p>
<p>2、依赖隔离组件为后端限流熔断并降级。比如使用Sentinel或Hystrix限流降级组件。</p>
<p>3、提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p>
<h3 id="热点缓存key重建优化"><a href="#热点缓存key重建优化" class="headerlink" title="热点缓存key重建优化"></a>热点缓存key重建优化</h3><p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写， 又保证数据的定期更新， 这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现， 可能就会对应用造成致命的危害：</p>
<ul>
<li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</li>
<li>重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。</li>
</ul>
<p>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。</p>
<p>要解决这个问题主要就是要避免大量线程同时重建缓存。</p>
<p>我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</p>
<p>示例伪代码：上边已出现</p>
<h3 id="缓存与数据库不一致"><a href="#缓存与数据库不一致" class="headerlink" title="缓存与数据库不一致"></a>缓存与数据库不一致</h3><p>这里不一致指的是：<strong>数据库的数据跟缓存的数据不一致</strong></p>
<p><strong>双写不一致</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard.png" alt="img"></p>
<p><strong>读写不一致</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650178193285.png" alt="img"></p>
<p><strong>解决方案：</strong></p>
<p>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p>
<p>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</p>
<p>3、如果不能容忍缓存数据不一致，可以通过加<strong>分布式读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong></p>
<p>4、对于双写不一致，可以采用把更新和删除缓存统一为<strong>删除缓存</strong>，减少维护复杂度，避免双写问题。</p>
<p>5、用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650179170290.png" alt="img"></p>
<h2 id="开发规范与性能优化"><a href="#开发规范与性能优化" class="headerlink" title="开发规范与性能优化"></a>开发规范与性能优化</h2><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1-key名设计"><a href="#1-key名设计" class="headerlink" title="1. key名设计"></a>1. key名设计</h4><p><strong>1. key名设计</strong></p>
<ul>
<li>(1)【建议】: 可读性和可管理性</li>
</ul>
<p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p>
<p>​                trade:order:1              </p>
<ul>
<li>(2)【建议】：简洁性</li>
</ul>
<p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>
<p>​                user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}              </p>
<ul>
<li>(3)【强制】：不要包含特殊字符</li>
</ul>
<p>反例：包含空格、换行、单双引号以及其他转义字符</p>
<h4 id="2-value设计"><a href="#2-value设计" class="headerlink" title="2. value设计"></a>2. value设计</h4><ul>
<li>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)</li>
</ul>
<p>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。</p>
<ol>
<li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li>
<li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li>
</ol>
<p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p>
<p>反例：一个包含200万个元素的list。</p>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p>
<h4 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h4><p>1.导致redis阻塞</p>
<p>2.网络拥塞（占用网络带宽）</p>
<h4 id="bigkey的产生"><a href="#bigkey的产生" class="headerlink" title="bigkey的产生"></a>bigkey的产生</h4><p>(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。</p>
<p>(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。</p>
<p>(3) 缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。</p>
<h4 id="如何优化bigkey"><a href="#如何优化bigkey" class="headerlink" title="如何优化bigkey"></a>如何优化bigkey</h4><p>1、分拆法</p>
<p>big list： list1、list2、…listN</p>
<p>big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</p>
<p>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。</p>
<p>2、选择适合的数据类型。</p>
<p>例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)</p>
<p>反例：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:name tom <span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:age <span class="hljs-number">19</span> <span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:favor football              <br></code></pre></td></tr></table></figure>

<p>正例:  </p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hmset user:<span class="hljs-number">1</span> name tom age <span class="hljs-number">19</span> favor football              <br></code></pre></td></tr></table></figure>

<p>3、控制key的生命周期，redis不是垃圾桶。</p>
<p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。           </p>
<h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><p>1、O(N)命令关注N的数量</p>
<p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p>
<p>2、禁用命令</p>
<p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p>
<p>3、合理使用select</p>
<p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p>
<p>4、使用批量操作提高效率：</p>
<p>原生命令：例如mget、mset。 </p>
<p>非原生命令：可以使用pipeline提高效率。          </p>
<p><strong>pipeline与lua的区别</strong>    ：lua具备原子性，pipeling仅仅是批量传输，不具备原子性</p>
<p>5、Redis事务功能较弱，不建议过多使用，可以用lua替代</p>
<h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><p>1.【推荐】避免多个应用使用一个Redis实例</p>
<p>正例：不相干的业务拆分，公共数据做服务化。</p>
<p>固定使用database=0 且一个应用使用一个实例，尽量不共享使用redis</p>
<p>2、使用redis连接池，可以有效控制连接，同时提高效率</p>
<p>连接池参数含义：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数名</th>
<th>含义</th>
<th>默认值</th>
<th>使用建议</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>maxTotal</td>
<td>资源池中最大连接数</td>
<td>8</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>2</td>
<td>maxIdle</td>
<td>资源池允许最大空闲的连接数</td>
<td>8</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>3</td>
<td>minIdle</td>
<td>资源池确保最少空闲的连接数</td>
<td>0</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>4</td>
<td>blockWhenExhausted</td>
<td>当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效</td>
<td>true</td>
<td>建议使用默认值</td>
</tr>
<tr>
<td>5</td>
<td>maxWaitMillis</td>
<td>当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)</td>
<td>-1：表示永不超时</td>
<td>不建议使用默认值</td>
</tr>
<tr>
<td>6</td>
<td>testOnBorrow</td>
<td>向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除</td>
<td>false</td>
<td>业务量很大时候建议设置为false(多一次ping的开销)。</td>
</tr>
<tr>
<td>7</td>
<td>testOnReturn</td>
<td>向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除</td>
<td>false</td>
<td>业务量很大时候建议设置为false(多一次ping的开销)。</td>
</tr>
<tr>
<td>8</td>
<td>jmxEnabled</td>
<td>是否开启jmx监控，可用于监控</td>
<td>true</td>
<td>建议开启，但应用本身也要开启</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<p>1）<strong>maxTotal</strong>：最大连接数，早期的版本叫maxActive实际上这个是一个很难回答的问题，考虑的因素比较多：</p>
<ul>
<li>业务希望Redis并发量</li>
<li>客户端执行命令时间</li>
<li>Redis资源：例如 nodes(例如应用个数) * maxTotal 是不能超过redis的最大连接数maxclients。</li>
<li>资源开销：例如虽然希望控制<strong>空闲连接</strong>(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。</li>
</ul>
<p><strong>以一个例子说明</strong>，假设:</p>
<ul>
<li>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000</li>
<li>业务期望的QPS是50000</li>
</ul>
<p>那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。</p>
<p>但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。</p>
<p>2）<strong>maxIdle和minIdle</strong></p>
<p>maxIdle实际上才是业务需要的最大连接数，maxTotal是为了<strong>给出余量</strong>，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。</p>
<p><strong>连接池的最佳性能是maxTotal = maxIdle</strong>，这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。</p>
<p>minIdle（最小空闲连接数），与其说是最小空闲连接数，不如说是”<strong>至少需要保持的空闲连接数</strong>“，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。</p>
<p>如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做<strong>预热</strong>，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。</p>
<p><strong>连接池预热示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Jedis&gt; minIdleJedisList = <span class="hljs-keyword">new</span> ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;<br>    Jedis jedis = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        jedis = pool.getResource();<br>        minIdleJedisList.add(jedis);<br>        jedis.ping();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。</span><br>        <span class="hljs-comment">//jedis.close();</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//统一将预热的连接还回连接池</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;<br>    Jedis jedis = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        jedis = minIdleJedisList.get(i);<br>        <span class="hljs-comment">//将连接归还回连接池</span><br>        jedis.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对于过期键有三种清除策略"><a href="#对于过期键有三种清除策略" class="headerlink" title="对于过期键有三种清除策略"></a>对于过期键有三种清除策略</h4><ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批<strong>已过期</strong>的key，这里的一批只是部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清理策略</strong></li>
</ol>
<h4 id="主动清理策略"><a href="#主动清理策略" class="headerlink" title="主动清理策略"></a>主动清理策略</h4><p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li><strong>volatile-lru</strong>：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理（默认策略）：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用</p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p>
<p>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。</p>
<p>根据自身业务类型，配置好maxmemory-policy(默认是<strong>noeviction</strong>)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。</p>
<p>当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/04/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/" rel="prev" title="分布式-Redis02-持久化和集群">
      <i class="fa fa-chevron-left"></i> 分布式-Redis02-持久化和集群
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis03-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E6%88%98/" rel="next" title="分布式-Redis03-分布式锁实战">
      分布式-Redis03-分布式锁实战 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">缓存设计与性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">多级缓存架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">缓存设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">造成缓存穿透的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">解决办法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%EF%BC%88%E5%87%BB%E7%A9%BF%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">缓存失效（击穿）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.2.3.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E5%92%8C%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">预防和解决缓存雪崩问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98key%E9%87%8D%E5%BB%BA%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">热点缓存key重建优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">1.2.5.</span> <span class="nav-text">缓存与数据库不一致</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">开发规范与性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">一、键值设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-key%E5%90%8D%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1. key名设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-value%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2. value设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bigkey%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">bigkey的危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bigkey%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">bigkey的产生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96bigkey"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">如何优化bigkey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">二、命令使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">三、客户端使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E8%BF%87%E6%9C%9F%E9%94%AE%E6%9C%89%E4%B8%89%E7%A7%8D%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">对于过期键有三种清除策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%B8%85%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">主动清理策略</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="24khandsome"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">24khandsome</p>
  <div class="site-description" itemprop="description">24khandsome's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">24khandsome</span>
  
	<br/>
	<span id="busuanzi_container_site_pv">
		<span class="post-meta-item-icon">
			<i class="fa fa-user"></i>
		</span>
		访问量：<span id="busuanzi_value_site_pv"></span> 次数
	</span>

	<span class="post-meta-divider">|</span>
		<span id="busuanzi_container_site_uv">
			<i class="fa fa-eye"></i>
			访客数：<span id="busuanzi_value_site_uv"></span> 人次
	</span>

</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
<!-- 动态背景 -->
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</html>
